# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mongoid` gem.
# Please instead update this file by running `bin/tapioca gem mongoid`.


class ActiveSupport::TimeWithZone
  include ::Mongoid::Extensions::TimeWithZone
  include ::Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  extend ::Mongoid::Extensions::TimeWithZone::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
end

class Array
  include ::Enumerable
  include ::Mongoid::Extensions::Array
  include ::Mongoid::Criteria::Queryable::Extensions::Array
  extend ::Mongoid::Extensions::Array::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
end

class BSON::Binary
  include ::Mongoid::Extensions::Binary
  extend ::Mongoid::Extensions::Binary::ClassMethods
end

class BSON::Decimal128
  include ::Mongoid::Extensions::Decimal128
  extend ::Mongoid::Extensions::Decimal128::ClassMethods
end

class BSON::ObjectId
  include ::Mongoid::Extensions::ObjectId
  extend ::Mongoid::Extensions::ObjectId::ClassMethods
end

class BSON::Regexp::Raw
  include ::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  extend ::Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
end

class BigDecimal < ::Numeric
  include ::Mongoid::Extensions::BigDecimal
  extend ::Mongoid::Extensions::BigDecimal::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
end

class Date
  include ::Comparable
  include ::Mongoid::Extensions::Date
  include ::Mongoid::Criteria::Queryable::Extensions::Date
  extend ::Mongoid::Extensions::Date::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
end

class DateTime < ::Date
  include ::Mongoid::Extensions::DateTime
  include ::Mongoid::Criteria::Queryable::Extensions::DateTime
  extend ::Mongoid::Extensions::DateTime::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
end

class FalseClass
  include ::Mongoid::Extensions::FalseClass
end

class Float < ::Numeric
  include ::Mongoid::Extensions::Float
  include ::Mongoid::Criteria::Queryable::Extensions::Numeric
  extend ::Mongoid::Extensions::Float::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
end

class Hash
  include ::Enumerable
  include ::Mongoid::Extensions::Hash
  include ::Mongoid::Criteria::Queryable::Extensions::Hash
  extend ::Mongoid::Extensions::Hash::ClassMethods
end

class Integer < ::Numeric
  include ::Mongoid::Extensions::Integer
  include ::Mongoid::Criteria::Queryable::Extensions::Numeric
  extend ::Mongoid::Extensions::Integer::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
end

class Module
  include ::Mongoid::Extensions::Module
end

# Top-level module for project.
#
# source://mongoid//lib/mongoid/version.rb#3
module Mongoid
  extend ::Mongoid::Deprecable
  extend ::Forwardable
  extend ::Mongoid::Loggable
  extend ::Mongoid::Loadable
  extend ::Mongoid
  extend ::Mongoid::Clients::Sessions::ClassMethods
  extend ::Mongoid::GlobalDiscriminatorKeyAssignment

  # Instantiates a new Mongoid::RawValue object. Used as a syntax shortcut.
  #
  # @example Create a Mongoid::RawValue object.
  #   Mongoid::RawValue("Beagle")
  # @return [Mongoid::RawValue] The object.
  #
  # source://mongoid//lib/mongoid/extensions/raw_value.rb#13
  def RawValue(*args); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_bson5_decimal128(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_bson5_decimal128=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_bson5_decimal128?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_scopes_to_unset_default_scope(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_scopes_to_unset_default_scope=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def allow_scopes_to_unset_default_scope?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def app_name(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def app_name=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def app_name?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def around_callbacks_for_embeds(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def around_callbacks_for_embeds=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def around_callbacks_for_embeds?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def async_query_executor(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def async_query_executor=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def async_query_executor?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def background_indexing(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def background_indexing=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def background_indexing?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def belongs_to_required_by_default(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def belongs_to_required_by_default=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def belongs_to_required_by_default?(*_arg0, **_arg1, &_arg2); end

  # Convenience method for getting a named client.
  #
  # @example Get a named client.
  #   Mongoid.client(:default)
  # @return [Mongo::Client] The named client.
  #
  # source://mongoid//lib/mongoid.rb#119
  def client(name); end

  # source://mongoid//lib/mongoid.rb#128
  def clients(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def config(*_arg0, **_arg1, &_arg2); end

  # Sets the Mongoid configuration options. Best used by passing a block.
  #
  # @example Set up configuration options.
  #   Mongoid.configure do |config|
  #   config.connect_to("mongoid_test")
  #
  #   config.clients.default = {
  #   hosts: ["localhost:27017"],
  #   database: "mongoid_test",
  #   }
  #   end
  # @example Using a block without an argument. Use `config` inside
  #   the block to perform variable assignment.
  #
  #   Mongoid.configure do
  #   connect_to("mongoid_test")
  #
  #   config.preload_models = true
  # @return [Config] The configuration object.
  #
  # source://mongoid//lib/mongoid.rb#77
  def configure(&block); end

  # source://mongoid//lib/mongoid.rb#128
  def configured?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def connect_to(*_arg0, **_arg1, &_arg2); end

  # Convenience method for getting the default client.
  #
  # @example Get the default client.
  #   Mongoid.default_client
  # @return [Mongo::Client] The default client.
  #
  # source://mongoid//lib/mongoid.rb#89
  def default_client; end

  # source://mongoid//lib/mongoid.rb#128
  def deregister_model(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def destructive_fields(*_arg0, **_arg1, &_arg2); end

  # Disconnect all active clients.
  #
  # @example Disconnect all active clients.
  #   Mongoid.disconnect_clients
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid.rb#99
  def disconnect_clients; end

  # source://mongoid//lib/mongoid.rb#128
  def discriminator_key(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def discriminator_key=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def discriminator_key?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def duplicate_fields_exception(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def duplicate_fields_exception=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def duplicate_fields_exception?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def global_executor_concurrency(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def global_executor_concurrency=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def global_executor_concurrency?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def immutable_ids(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def immutable_ids=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def immutable_ids?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_root_in_json(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_root_in_json=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_root_in_json?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_type_for_serialization(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_type_for_serialization=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def include_type_for_serialization?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def join_contexts(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def join_contexts=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def join_contexts?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_persistence_context_behavior(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_persistence_context_behavior=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_persistence_context_behavior?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_readonly(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_readonly=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def legacy_readonly?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def load!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def load_configuration(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def log_level=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def log_level?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def map_big_decimal_to_decimal128(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def map_big_decimal_to_decimal128=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def map_big_decimal_to_decimal128?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def models(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def options=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def override_client(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def override_database(*_arg0, **_arg1, &_arg2); end

  # Define persistence context that is used when a transaction method is called
  # on Mongoid module.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid.rb#134
  def persistence_context; end

  # source://mongoid//lib/mongoid.rb#128
  def preload_models(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def preload_models=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def preload_models?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def prevent_multiple_calls_of_embedded_callbacks(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def prevent_multiple_calls_of_embedded_callbacks=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def prevent_multiple_calls_of_embedded_callbacks?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def purge!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def raise_not_found_error(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def raise_not_found_error=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def raise_not_found_error?(*_arg0, **_arg1, &_arg2); end

  # Reconnect all active clients.
  #
  # @example Reconnect all active clients.
  #   Mongoid.reconnect_clients
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid.rb#109
  def reconnect_clients; end

  # source://mongoid//lib/mongoid.rb#128
  def register_model(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def running_with_passenger?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def scope_overwrite_exception(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def scope_overwrite_exception=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def scope_overwrite_exception?(*_arg0, **_arg1, &_arg2); end

  # Define client that is used when a transaction method is called
  # on Mongoid module. This MUST be the default client.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid.rb#142
  def storage_options; end

  # source://mongoid//lib/mongoid.rb#128
  def time_zone(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def truncate!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def use_utc(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def use_utc=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid.rb#128
  def use_utc?(*_arg0, **_arg1, &_arg2); end
end

# Mixin module which adds association behavior to a Mongoid document.
# Adds methods such as #embedded? which indicate a document's
# relative association state.
#
# source://mongoid//lib/mongoid/association/eager.rb#5
module Mongoid::Association
  include ::Mongoid::Association::Referenced::Syncable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods

  # Returns the value of attribute _association.
  #
  # source://mongoid//lib/mongoid/association.rb#51
  def _association; end

  # Sets the attribute _association
  #
  # @param value the value to set the attribute _association to.
  #
  # source://mongoid//lib/mongoid/association.rb#51
  def _association=(_arg0); end

  # Get the association name for this document. If no association was defined
  #   an error will be raised.
  #
  # @example Get the association name.
  #   document.association_name
  # @raise [Errors::NoMetadata] If no association metadata is present.
  # @return [Symbol] The association name.
  #
  # source://mongoid//lib/mongoid/association.rb#98
  def association_name; end

  # Determine if the document itself is embedded in another document via the
  # proper channels. (If it has a parent document.)
  #
  # @example Is the document embedded?
  #   address.embedded?
  # @return [true | false] True if the document has a parent document.
  #
  # source://mongoid//lib/mongoid/association.rb#65
  def embedded?; end

  # Determine if the document is part of an embeds_many association.
  #
  # @example Is the document in an embeds many?
  #   address.embedded_many?
  # @return [true | false] True if in an embeds many.
  #
  # source://mongoid//lib/mongoid/association.rb#75
  def embedded_many?; end

  # Determine if the document is part of an embeds_one association.
  #
  # @example Is the document in an embeds one?
  #   address.embedded_one?
  # @return [true | false] True if in an embeds one.
  #
  # source://mongoid//lib/mongoid/association.rb#85
  def embedded_one?; end

  # Determine if the document is part of an references_many association.
  #
  # @example Is the document in a references many?
  #   post.referenced_many?
  # @return [true | false] True if in a references many.
  #
  # source://mongoid//lib/mongoid/association.rb#109
  def referenced_many?; end

  # Determine if the document is part of an references_one association.
  #
  # @example Is the document in a references one?
  #   address.referenced_one?
  # @return [true | false] True if in a references one.
  #
  # source://mongoid//lib/mongoid/association.rb#119
  def referenced_one?; end

  # Convenience method for iterating through the loaded associations and
  # reloading them.
  #
  # @example Reload the associations.
  #   document.reload_relations
  # @return [Hash] The association metadata.
  #
  # source://mongoid//lib/mongoid/association.rb#130
  def reload_relations; end

  module GeneratedClassMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

# This module contains all the behavior related to accessing associations
# through the getters and setters, and how to delegate to builders to
# create new ones.
#
# source://mongoid//lib/mongoid/association/accessors.rb#10
module Mongoid::Association::Accessors
  extend ::ActiveSupport::Concern

  # Builds the related document and creates the association unless the
  # document is nil, then sets the association on this document.
  #
  # @example Build the association.
  #   person.__build__(:addresses, { :_id => 1 }, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param name [String | Symbol] The name of the association.
  # @param object [Hash | BSON::ObjectId] The id or attributes to use.
  # @param selected_fields [Hash] Fields which were retrieved via #only.
  #   If selected_fields is specified, fields not listed in it will not be
  #   accessible in the built document.
  # @return [Proxy] The association.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#27
  def __build__(name, object, association, selected_fields = T.unsafe(nil)); end

  # Create an association from an object and association metadata.
  #
  # @example Create the association.
  #   person.create_relation(document, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param object [Document | Array<Document>] The association target.
  # @param selected_fields [Hash] Fields which were retrieved via #only.
  #   If selected_fields is specified, fields not listed in it will not be
  #   accessible in the created association document.
  # @return [Proxy] The association.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#44
  def create_relation(object, association, selected_fields = T.unsafe(nil)); end

  # Resets the criteria inside the association proxy. Used by many-to-many
  # associations to keep the underlying ids array in sync.
  #
  # @example Reset the association criteria.
  #   person.reset_relation_criteria(:preferences)
  # @param name [Symbol] The name of the association.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#73
  def reset_relation_criteria(name); end

  # Set the supplied association to an instance variable on the class with the
  # provided name. Used as a helper just for code cleanliness.
  #
  # @example Set the proxy on the document.
  #   person.set(:addresses, addresses)
  # @param name [String | Symbol] The name of the association.
  # @param relation [Proxy] The association to set.
  # @return [Proxy] The association.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#89
  def set_relation(name, relation); end

  private

  # Returns a subset of __selected_fields attribute applicable to the
  # (embedded) association with the given key, or nil if no projection
  # is to be performed.
  #
  # Also returns nil if exclusionary projection was requested but it does
  # not exclude the field of the association.
  #
  # For example, if __selected_fields is {'a' => 1, 'b.c' => 2, 'b.c.f' => 3},
  # and assoc_key is 'b', return value would be {'c' => 2, 'c.f' => 3}.
  #
  # @api private
  # @param assoc_key [String]
  # @return [Hash | nil]
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#158
  def _mongoid_filter_selected_fields(assoc_key); end

  # Get the association. Extracted out from the getter method to avoid
  # infinite recursion when overriding the getter.
  #
  # @api private
  # @example Get the association.
  #   document.get_relation(:name, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param name [Symbol] The name of the association.
  # @param object [Object] The object used to build the association.
  # @param reload [true | false] If the association is to be reloaded.
  # @return [Proxy] The association.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#109
  def get_relation(name, association, object, reload = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#224
  def needs_no_database_query?(object, association); end

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # @example Parse the args.
  #   doc.parse_args(:name => "Joe")
  # @param *args [Hash...] The arguments.
  # @return [Array<Hash>] The attributes and options.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#263
  def parse_args(*args); end

  # Yield to the block with autobuild functionality turned off.
  #
  # @example Execute without autobuild.
  #   document.without_autobuild do
  #   document.name
  #   end
  # @return [Object] The result of the yield.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#247
  def without_autobuild; end

  # Is the current code executing without autobuild functionality?
  #
  # @example Is autobuild disabled?
  #   document.without_autobuild?
  # @return [true | false] If autobuild is disabled.
  #
  # source://mongoid//lib/mongoid/association/accessors.rb#235
  def without_autobuild?; end

  class << self
    # Defines a builder method for an embeds_one association. This is
    # defined as #build_name.
    #
    # @example
    #   Person.define_builder!(association)
    # @param association [Mongoid::Association::Relatable] The association for the association.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#394
    def define_builder!(association); end

    # Defines a creator method for an embeds_one association. This is
    # defined as #create_name. After the object is built it will
    # immediately save.
    #
    # @example
    #   Person.define_creator!(association)
    # @param association [Mongoid::Association::Relatable] The association for the association.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#419
    def define_creator!(association); end

    # Adds the existence check for associations.
    #
    # @example Add the existence check.
    #   Person.define_existence_check!(association)
    # @example Check if an association exists.
    #   person = Person.new
    #   person.has_game?
    #   person.game?
    # @param association [Mongoid::Association::Relatable] The association.
    # @return [Class] The model being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#280
    def define_existence_check!(association); end

    # Defines the getter for the association. Nothing too special here: just
    # return the instance variable for the association if it exists or build
    # the thing.
    #
    # @example Set up the getter for the association.
    #   Person.define_getter!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata for the association.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#302
    def define_getter!(association); end

    # Defines the getter for the ids of documents in the association. Should
    # be specify only for referenced many associations.
    #
    # @example Set up the ids getter for the association.
    #   Person.define_ids_getter!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata for the association.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#324
    def define_ids_getter!(association); end

    # Defines the setter method that allows you to set documents
    # in this association by their ids. The defined setter, finds
    # documents with given ids and invokes regular association setter
    # with found documents. Ids setters should be defined only for
    # referenced many associations.
    #
    #  @param [ Mongoid::Association::Relatable ] association The association for the association.
    #
    #  @return [ Class ] The class being set up.
    #
    # @example Set up the id_setter for the association.
    #   Person.define_ids_setter!(association)
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#375
    def define_ids_setter!(association); end

    # Defines the setter for the association. This does a few things based on
    # some conditions. If there is an existing association, a target
    # substitution will take place, otherwise a new association will be
    # created with the supplied target.
    #
    # @example Set up the setter for the association.
    #   Person.define_setter!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata for the association.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/accessors.rb#344
    def define_setter!(association); end
  end
end

# Superclass for all objects that bind associations together.
#
# source://mongoid//lib/mongoid/association/bindable.rb#8
module Mongoid::Association::Bindable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  # Create the new binding.
  #
  # @example Initialize a binding.
  #   Binding.new(base, target, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The base of the binding.
  # @param target [Document | Array<Document>] The target of the binding.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#21
  def initialize(base, target, association); end

  # Returns the value of attribute _association.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#11
  def _association; end

  # Returns the value of attribute _base.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#11
  def _base; end

  # Returns the value of attribute _target.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#11
  def _target; end

  # Execute the provided block inside a binding.
  #
  # @example Execute the binding block.
  #   binding.binding do
  #   base.foreign_key = 1
  #   end
  # @return [Object] The result of the yield.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#33
  def binding; end

  private

  # Set the id of the related document in the foreign key field on the
  # keyed document.
  #
  # @api private
  # @example Bind the foreign key.
  #   binding.bind_foreign_key(post, person._id)
  # @param id [Object] The id of the bound document.
  # @param keyed [Document] The document that stores the foreign key.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#121
  def bind_foreign_key(keyed, id); end

  # Bind the provided document with the base from the parent association.
  #
  # @api private
  # @example Bind the document with the base.
  #   binding.bind_from_relational_parent(doc)
  # @param doc [Document] The document to bind.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#183
  def bind_from_relational_parent(doc); end

  # Bind the inverse document to the child document so that the in memory
  # instances are the same.
  #
  # @api private
  # @example Bind the inverse.
  #   binding.bind_inverse(post, person)
  # @param doc [Document] The base document.
  # @param inverse [Document] The inverse document.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#169
  def bind_inverse(doc, inverse); end

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # @api private
  # @example Bind the polymorphic type.
  #   binding.bind_polymorphic_inverse_type(post, "Person")
  # @param name [String] The name of the model.
  # @param typed [Document] The document that stores the type field.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#153
  def bind_polymorphic_inverse_type(typed, name); end

  # Set the type of the related document on the foreign type field, used
  # when associations are polymorphic.
  #
  # @api private
  # @example Bind the polymorphic type.
  #   binding.bind_polymorphic_type(post, "Person")
  # @param name [String] The name of the model.
  # @param typed [Document] The document that stores the type field.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#137
  def bind_polymorphic_type(typed, name); end

  # Check if the inverse is properly defined.
  #
  # @api private
  # @example Check the inverse definition.
  #   binding.check_inverse!(doc)
  # @param doc [Document] The document getting bound.
  # @raise [Errors::InverseNotFound] If no inverse found.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#53
  def check_inverse!(doc); end

  # source://mongoid//lib/mongoid/association/bindable.rb#191
  def record_id(_base); end

  # Remove the associated document from the inverse's association.
  #
  # @param doc [Document] The document to remove.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#67
  def remove_associated(doc); end

  # Remove the associated document from the inverse's association.
  #
  # This method removes associated on belongs_to and embedded_in
  # associations.
  #
  # @param doc [Document] The document to remove.
  # @param inverse [Symbol] The name of the inverse.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#103
  def remove_associated_in_to(doc, inverse); end

  # Remove the associated document from the inverse's association.
  #
  # This method removes the associated on *_many relationships.
  #
  # @param doc [Document] The document to remove.
  # @param inverse [Symbol] The name of the inverse.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#83
  def remove_associated_many(doc, inverse); end

  # Ensure that the association on the base is correct, for the cases
  # where we have multiple belongs to definitions and were are setting
  # different parents in memory in order.
  #
  # @api private
  # @example Set the base association.
  #   binding.set_base_association
  # @return [true | false] If the association changed.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#205
  def set_base_association; end

  # Convenience method to perform +#try+ but return
  # nil if the method argument is nil.
  #
  # @example Call method if it exists.
  #   object.try_method(:use, "The Force")
  # @example Return nil if method argument is nil.
  #   object.try_method(nil, "The Force") #=> nil
  # @param *args [Object...] The arguments.
  # @param method_name [String | Symbol] The method name.
  # @return [Object | nil] The result of the try or nil if the
  #   method does not exist.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#241
  def try_method(object, method_name, *args); end

  # Bind the provided document with the base from the parent association.
  #
  # @api private
  # @example Bind the document with the base.
  #   unbinding.unbind_from_relational_parent(doc)
  # @param doc [Document] The document to unbind.
  #
  # source://mongoid//lib/mongoid/association/bindable.rb#220
  def unbind_from_relational_parent(doc); end
end

# This module is responsible for defining the build and create methods used
# in one to one associations.
#
# @example Methods that get created.
#
#   class Person
#   include Mongoid::Document
#   embeds_one :name
#   end
#
#   # The following methods get created:
#   person.build_name({ :first_name => "Durran" })
#   person.create_name({ :first_name => "Durran" })
#
# source://mongoid//lib/mongoid/association/builders.rb#20
module Mongoid::Association::Builders
  extend ::ActiveSupport::Concern

  private

  # Parse out the attributes and the options from the args passed to a
  # build_ or create_ methods.
  #
  # @example Parse the args.
  #   doc.parse_args(:name => "Joe")
  # @param *args [Hash...] The arguments.
  # @return [Array<Hash>] The attributes and options.
  #
  # source://mongoid//lib/mongoid/association/builders.rb#34
  def parse_args(*args); end

  class << self
    # Defines a builder method. This is defined as #build_name.
    #
    # @example
    #   Person.define_builder!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/builders.rb#46
    def define_builder!(association); end

    # Defines a creator method. This is defined as #create_name.
    # After the object is built it will immediately save.
    #
    # @example
    #   Person.define_creator!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata.
    # @return [Class] The class being set up.
    #
    # source://mongoid//lib/mongoid/association/builders.rb#70
    def define_creator!(association); end
  end
end

# Used for converting foreign key values to the correct type based on the
# types of ids that the document stores.
#
# source://mongoid//lib/mongoid/association/constrainable.rb#9
module Mongoid::Association::Constrainable
  # Convert the supplied object to the appropriate type to set as the
  # foreign key for an association.
  #
  # @example Convert the object.
  #   constraint.convert("12345")
  # @param object [Object] The object to convert.
  # @return [Object] The object cast to the correct type.
  #
  # source://mongoid//lib/mongoid/association/constrainable.rb#20
  def convert_to_foreign_key(object); end

  private

  # source://mongoid//lib/mongoid/association/constrainable.rb#34
  def convert_polymorphic(object); end
end

# This module defines the behavior for setting up cascading deletes and
# nullifies for associations, and how to delegate to the appropriate strategy.
#
# source://mongoid//lib/mongoid/association/depending.rb#9
module Mongoid::Association::Depending
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods

  # Perform all cascading deletes, destroys, or nullifies. Will delegate to
  # the appropriate strategy to perform the operation.
  #
  # @example Execute cascades.
  #   document.apply_destroy_dependencies!
  #
  # source://mongoid//lib/mongoid/association/depending.rb#92
  def apply_destroy_dependencies!; end

  private

  # source://mongoid//lib/mongoid/association/depending.rb#102
  def _dependent_delete_all!(association); end

  # source://mongoid//lib/mongoid/association/depending.rb#112
  def _dependent_destroy!(association); end

  # source://mongoid//lib/mongoid/association/depending.rb#123
  def _dependent_nullify!(association); end

  # source://mongoid//lib/mongoid/association/depending.rb#135
  def _dependent_restrict_with_error!(association); end

  # source://mongoid//lib/mongoid/association/depending.rb#129
  def _dependent_restrict_with_exception!(association); end

  class << self
    # Attempt to add the cascading information for the document to know how
    # to handle associated documents on a removal.
    #
    # @example Set up cascading information
    #   Mongoid::Association::Depending.define_dependency!(association)
    # @param association [Mongoid::Association::Relatable] The association metadata.
    # @return [Class] The class of the document.
    #
    # source://mongoid//lib/mongoid/association/depending.rb#57
    def define_dependency!(association); end

    # Validates that an association's dependent strategy is
    # within the allowed enumeration.
    #
    # @param association [Mongoid::Association::Relatable] The association to validate.
    #
    # source://mongoid//lib/mongoid/association/depending.rb#79
    def validate!(association); end
  end

  module GeneratedClassMethods
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
  end

  module GeneratedInstanceMethods
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
  end
end

module Mongoid::Association::Depending::ClassMethods
  # source://mongoid//lib/mongoid/association/depending.rb#30
  def _all_dependents; end
end

# The valid dependent strategies.
#
# source://mongoid//lib/mongoid/association/depending.rb#40
Mongoid::Association::Depending::STRATEGIES = T.let(T.unsafe(nil), Array)

# Base class for eager load preload functions.
#
# source://mongoid//lib/mongoid/association/eager.rb#8
class Mongoid::Association::Eager
  # Instantiate the eager load class.
  #
  # @example Create the new belongs to eager load preloader.
  #   BelongsTo.new(association, parent_docs)
  # @param associations [Array<Mongoid::Association::Relatable>] Associations to eager load
  # @param docs [Array<Document>] Documents to preload the associations
  # @return [Base] The eager load preloader
  #
  # source://mongoid//lib/mongoid/association/eager.rb#19
  def initialize(associations, docs); end

  # Run the preloader.
  #
  # @example Preload the associations into the documents.
  #   loader.run
  # @return [Array] The list of documents given.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#31
  def run; end

  protected

  # Retrieves the documents referenced by the association, and
  # yields each one sequentially to the provided block. If the
  # association is not polymorphic, all documents are retrieved in
  # a single query. If the association is polymorphic, one query is
  # issued per association target class.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#57
  def each_loaded_document(&block); end

  # Return the key to group the current documents.
  #
  # This method should be implemented in the subclass
  #
  # @example Return the key for group
  #   loader.group_by_key
  # @raise [NotImplementedError]
  # @return [Symbol] Key to group by the current documents.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#132
  def group_by_key; end

  # Return a hash with the current documents grouped by key.
  #
  # Documents that do not have a value for the association being loaded
  # are not returned.
  #
  # @example Return a hash with the current documents grouped by key.
  #   loader.grouped_docs
  # @return [Hash] hash with grouped documents.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#103
  def grouped_docs; end

  # Group the documents and return the keys.
  #
  # This method omits nil keys (i.e. keys from documents that do not
  # have a value for the association being loaded).
  #
  # @example
  #   loader.keys_from_docs
  # @return [Array] keys, ids
  #
  # source://mongoid//lib/mongoid/association/eager.rb#120
  def keys_from_docs; end

  # Preload the current association.
  #
  # This method should be implemented in the subclass
  #
  # @example Preload the current association into the documents.
  #   loader.preload
  # @raise [NotImplementedError]
  #
  # source://mongoid//lib/mongoid/association/eager.rb#48
  def preload; end

  # Set the pre-loaded document into its parent.
  #
  # @example Set docs into parent with pk = "foo"
  #   loader.set_on_parent("foo", docs)
  # @param element [Document | Array] to push into the parent
  # @param id [ObjectId] parent`s id
  #
  # source://mongoid//lib/mongoid/association/eager.rb#88
  def set_on_parent(id, element); end

  # Set the pre-loaded document into its parent.
  #
  # @example Set docs into parent using the current association name.
  #   loader.set_relation(doc, docs)
  # @param doc [Document] The object to set the association on
  # @param element [Document | Array] to set into the parent
  #
  # source://mongoid//lib/mongoid/association/eager.rb#143
  def set_relation(doc, element); end

  private

  # Retrieves the documents of the specified class, that have the
  # foreign key included in the specified list of keys.
  #
  # When the documents are retrieved, the set of inclusions applied
  # is the set of inclusions applied to the host document minus the
  # association that is being eagerly loaded.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#67
  def each_loaded_document_of_class(cls, keys); end

  # Shift the current association metadata
  #
  # @example Shift the current association.
  #   loader.shift_association
  # @return [Mongoid::Association::Relatable] The association object.
  #
  # source://mongoid//lib/mongoid/association/eager.rb#155
  def shift_association; end
end

# This module defines the eager loading behavior for criteria.
#
# source://mongoid//lib/mongoid/association/eager_loadable.rb#10
module Mongoid::Association::EagerLoadable
  # Load the associations for the given documents.
  #
  # @param docs [Array<Mongoid::Document>] The documents.
  # @return [Array<Mongoid::Document>] The given documents.
  #
  # source://mongoid//lib/mongoid/association/eager_loadable.rb#25
  def eager_load(docs); end

  # Indicates whether the criteria has association
  # inclusions which should be eager loaded.
  #
  # @return [true | false] Whether to eager load.
  #
  # source://mongoid//lib/mongoid/association/eager_loadable.rb#16
  def eager_loadable?; end

  # Load the associations for the given documents. This will be done
  # recursively to load the associations of the given documents'
  # associated documents.
  #
  # @param associations [Array<Mongoid::Association::Relatable>] The associations to load.
  # @param docs [Array<Mongoid::Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/eager_loadable.rb#40
  def preload(associations, docs); end
end

# source://mongoid//lib/mongoid/association/embedded/cyclic.rb#6
module Mongoid::Association::Embedded; end

# Contains behavior for executing operations in batch on embedded
# documents.
#
# source://mongoid//lib/mongoid/association/embedded/batchable.rb#10
module Mongoid::Association::Embedded::Batchable
  include ::Mongoid::Positional

  # Clear all of the docs out of the association in a single swipe.
  #
  # @example Clear all docs.
  #   batchable.batch_clear(docs)
  # @param docs [Array<Document>] The docs to clear.
  # @return [Array] The empty array.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#35
  def batch_clear(docs); end

  # Insert new documents as a batch push ($push with $each). This ensures that
  # all callbacks are run at the appropriate time and only 1 request is
  # made to the database.
  #
  # @example Execute the batch push.
  #   batchable.batch_insert([ doc_one, doc_two ])
  # @param docs [Array<Document>] The docs to add.
  # @return [Array<Hash>] The inserts.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#23
  def batch_insert(docs); end

  # Batch remove the provided documents as a $pullAll or $pull.
  #
  # @example Batch remove the documents.
  #   batchable.batch_remove([ doc_one, doc_two ])
  # @param docs [Array<Document>] The docs to remove.
  # @param method [Symbol] Delete or destroy.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#59
  def batch_remove(docs, method = T.unsafe(nil)); end

  # Batch replace the provided documents as a $set.
  #
  # @example Batch replace the documents.
  #   batchable.batch_replace([ doc_one, doc_two ])
  # @param docs [Array<Document> | Array<Hash>] The docs to replace with.
  # @return [Array<Hash>] The inserts.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#102
  def batch_replace(docs); end

  private

  # Add the atomic sets to the base document.
  #
  # @api private
  # @example Add the atomic sets.
  #   batchable.add_atomic_sets([{ field: value }])
  # @param sets [Array<Hash>] The atomic sets.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#135
  def add_atomic_sets(sets); end

  # Clear the cache for path and atomic_paths. This method is used when
  # the path method is used, and the association has not been set on the
  # document yet, which can cause path and atomic_paths to be calculated
  # incorrectly later.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#274
  def clear_atomic_path_cache; end

  # Perform a batch persist of the provided documents with $push and $each.
  #
  # @api private
  # @example Perform a batch push.
  #   batchable.execute_batch_push(docs)
  # @param docs [Array<Document>] The docs to persist.
  # @return [Array<Hash>] The inserts.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#178
  def execute_batch_push(docs); end

  # Perform a batch persist of the provided documents with a $set.
  #
  # @api private
  # @example Perform a batch $set.
  #   batchable.execute_batch_set(docs)
  # @param docs [Array<Document>] The docs to persist.
  # @return [Array<Hash>] The inserts.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#155
  def execute_batch_set(docs); end

  # Are we in a state to be able to batch insert?
  #
  # @api private
  # @example Can inserts be performed?
  #   batchable.insertable?
  # @return [true | false] If inserts can be performed.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#199
  def insertable?; end

  # Are the inserts currently valid?
  #
  # @api private
  # @example Are the inserts currently valid.
  #   batchable.inserts_valid
  # @return [true | false] If inserts are currently valid.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#211
  def inserts_valid; end

  # Set the inserts valid flag.
  #
  # @api private
  # @example Set the flag.
  #   batchable.inserts_valid = true
  # @param value [true | false] The flag.
  # @return [true | false] The flag.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#225
  def inserts_valid=(value); end

  # Normalize the documents, in case they were provided as an array of
  # hashes.
  #
  # @api private
  # @example Normalize the docs.
  #   batchable.normalize_docs(docs)
  # @param docs [Array<Document> | Array<Hash>] The docs to normalize.
  # @return [Array<Document>] The docs.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#240
  def normalize_docs(docs); end

  # Get the atomic path.
  #
  # @api private
  # @example Get the atomic path.
  #   batchable.path
  # @return [String] The atomic path.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#260
  def path; end

  # Set the atomic path.
  #
  # @api private
  # @example Set the atomic path.
  #   batchable.path = "addresses"
  # @param value [String] The path.
  # @return [String] The path.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#289
  def path=(value); end

  # Post process the documents after batch insert.
  #
  # @api private
  # @example Post process the documents.
  #   batchable.post_process_batch_insert(docs)
  # @param docs [Array<Documents>] The inserted docs.
  # @return [Enumerable] The document enum.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#369
  def post_process_batch_insert(docs); end

  # Post process the batch removal.
  #
  # @api private
  # @example Post process the documents.
  #   batchable.post_process_batch_remove(docs, :delete)
  # @param docs [Array<Document>] The documents.
  # @param method [Symbol] Delete or destroy.
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#388
  def post_process_batch_remove(docs, method); end

  # Pre processes the batch insert for the provided documents.
  #
  # @api private
  # @example Pre process the documents.
  #   batchable.pre_process_batch_insert(docs)
  # @param docs [Array<Document>] The documents.
  # @return [Array<Hash>] The documents as an array of hashes.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#315
  def pre_process_batch_insert(docs); end

  # Pre process the batch removal.
  #
  # @api private
  # @example Pre process the documents.
  #   batchable.pre_process_batch_remove(docs, :delete)
  # @param docs [Array<Document>] The documents.
  # @param method [Symbol] Delete or destroy.
  # @return [Array<Hash>] The documents as hashes.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#343
  def pre_process_batch_remove(docs, method); end

  # Get the selector for executing atomic operations on the collection.
  #
  # @api private
  # @example Get the selector.
  #   batchable.selector
  # @return [Hash] The atomic selector.
  #
  # source://mongoid//lib/mongoid/association/embedded/batchable.rb#301
  def selector; end
end

# This module provides convenience macros for using cyclic embedded
# associations.
#
# source://mongoid//lib/mongoid/association/embedded/cyclic.rb#10
module Mongoid::Association::Embedded::Cyclic
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods

  module GeneratedClassMethods
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
  end

  module GeneratedInstanceMethods
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
  end
end

# source://mongoid//lib/mongoid/association/embedded/cyclic.rb#17
module Mongoid::Association::Embedded::Cyclic::ClassMethods
  # Create a cyclic embedded association that creates a tree hierarchy for
  # the document and many embedded child documents.
  #
  # This provides the default nomenclature for accessing a parent document
  # or its children.
  #
  # @example Set up a recursive embeds many.
  #
  #   class Role
  #   include Mongoid::Document
  #   recursively_embeds_many
  #   end
  # @example The previous example is a shortcut for this.
  #
  #   class Role
  #   include Mongoid::Document
  #   embeds_many :child_roles, :class_name => "Role", :cyclic => true
  #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
  #   end
  #
  # source://mongoid//lib/mongoid/association/embedded/cyclic.rb#39
  def recursively_embeds_many(options = T.unsafe(nil)); end

  # Create a cyclic embedded association that creates a single self
  # referencing relationship for a parent and a single child.
  #
  # This provides the default nomenclature for accessing a parent document
  # or its children.
  #
  # @example Set up a recursive embeds one.
  #
  #   class Role
  #   include Mongoid::Document
  #   recursively_embeds_one
  #   end
  # @example The previous example is a shortcut for this.
  #
  #   class Role
  #   include Mongoid::Document
  #   embeds_one :child_role, :class_name => "Role", :cyclic => true
  #   embedded_in :parent_role, :class_name => "Role", :cyclic => true
  #   end
  #
  # source://mongoid//lib/mongoid/association/embedded/cyclic.rb#67
  def recursively_embeds_one(options = T.unsafe(nil)); end

  private

  # Determines the child name given the class.
  #
  # @example Determine the child name.
  #   Role.cyclic_child_name
  # @param many [true | false] Is the a many association?
  # @return [String] "child_" plus the class name underscored in
  #   singular or plural form.
  #
  # source://mongoid//lib/mongoid/association/embedded/cyclic.rb#96
  def cyclic_child_name(many = T.unsafe(nil)); end

  # Determines the parent name given the class.
  #
  # @example Determine the parent name.
  #   Role.cyclic_parent_name
  # @return [String] "parent_" plus the class name underscored.
  #
  # source://mongoid//lib/mongoid/association/embedded/cyclic.rb#83
  def cyclic_parent_name; end
end

# Eager class for embedded associations (embedded_in, embeds_many,
# embeds_one).
#
# source://mongoid//lib/mongoid/association/embedded/eager.rb#10
class Mongoid::Association::Embedded::Eager < ::Mongoid::Association::Eager
  private

  # Embedded associations have no preload phase, since the embedded
  # documents are loaded with the parent document. This method is
  # implemented as a no-op to represent that.
  #
  # source://mongoid//lib/mongoid/association/embedded/eager.rb#17
  def preload; end
end

# The EmbeddedIn type association.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in/binding.rb#7
class Mongoid::Association::Embedded::EmbeddedIn
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbeddedIn::Buildable

  # Is this association type embedded?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#47
  def embedded?; end

  # The key that is used to get the attributes for the associated object.
  #
  # @return [String] The name of the association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#67
  def key; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::One] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#91
  def nested_builder(attributes, options); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#81
  def polymorphic?; end

  # The primary key
  #
  # @return [nil] Not relevant for this association
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#52
  def primary_key; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::Embedded::EmbeddedIn::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#74
  def relation; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#37
  def setup!; end

  # Does this association type store the foreign key?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#57
  def stores_foreign_key?; end

  # The default for validating the association object.
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#62
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#129
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#117
  def polymorphic_inverses(other = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#112
  def relation_complements; end

  # Set up default values for any options used by this association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#98
  def setup_defaults!; end

  # source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#102
  def setup_instance_methods!; end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#21
Mongoid::Association::Embedded::EmbeddedIn::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# The Binding object for embedded_in associations.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in/binding.rb#10
class Mongoid::Association::Embedded::EmbeddedIn::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # @example Bind the documents.
  #   name.person.bind(:continue => true)
  #   name.person = Person.new
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/binding.rb#22
  def bind_one; end

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # @example Unbind the document.
  #   name.person.unbind(:continue => true)
  #   name.person = nil
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/binding.rb#42
  def unbind_one; end

  private

  # Check for problems with multiple inverse definitions.
  #
  # @api private
  # @example Check for inverses errors.
  #   binding.check_inverses!(doc)
  # @param doc [Document] The document to check.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/binding.rb#62
  def check_polymorphic_inverses!(doc); end
end

# The Builder behavior for embedded_in associations.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in/buildable.rb#10
module Mongoid::Association::Embedded::EmbeddedIn::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  # This builder doesn't actually build anything, just returns the
  # parent since it should already be instantiated.
  #
  # @example Build the document.
  #   Builder.new(meta, attrs).build
  # @param base [Document] The object.
  # @param object [Document | Hash] The parent hash or document.
  # @param selected_fields [Hash] Fields which were retrieved via
  #   #only. If selected_fields are specified, fields not listed in it
  #   will not be accessible in the built document.
  # @param type [String] Not used in this context.
  # @return [Document] A single document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/buildable.rb#27
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

# Transparent proxy for embedded_in associations.
# An instance of this class is returned when calling the
# association getter method on the child document. This
# class inherits from Mongoid::Association::Proxy and forwards
# most of its methods to the target of the association, i.e.
# the parent document.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#13
class Mongoid::Association::Embedded::EmbeddedIn::Proxy < ::Mongoid::Association::One
  # Instantiate a new embedded_in association.
  #
  # @example Create the new association.
  #   Association::Embedded::EmbeddedIn.new(person, address, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The document the association hangs off of.
  # @param target [Document] The target (parent) of the association.
  # @return [In] The proxy.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#24
  def initialize(base, target, association); end

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # @example Substitute the new document.
  #   person.name.substitute(new_name)
  # @param replacement [Document | Hash] A document to replace the target.
  # @return [Document | nil] The association or nil.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#40
  def substitute(replacement); end

  private

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding.
  #   binding([ address ])
  # @return [Binding] A binding object.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#61
  def binding; end

  # Characterize the document.
  #
  # @example Set the base association.
  #   object.characterize_one(document)
  # @param document [Document] The document to set the association metadata on.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#71
  def characterize_one(document); end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#81
  def persistable?; end

  class << self
    # Returns the eager loader for this association.
    #
    # @param associations [Array<Mongoid::Association>] The
    #   associations to be eager loaded
    # @param docs [Array<Mongoid::Document>] The parent documents
    #   that possess the given associations, which ought to be
    #   populated by the eager-loaded documents.
    # @return [Mongoid::Association::Embedded::Eager]
    #
    # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#95
    def eager_loader(associations, docs); end

    # Returns true if the association is an embedded one. In this case
    # always true.
    #
    # @example Is this association embedded?
    #   Association::Embedded::EmbeddedIn.embedded?
    # @return [true] true.
    #
    # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#106
    def embedded?; end

    # Get the path calculator for the supplied document.
    #
    # @example Get the path calculator.
    #   Proxy.path(document)
    # @param document [Document] The document to calculate on.
    # @return [Root] The root atomic path calculator.
    #
    # source://mongoid//lib/mongoid/association/embedded/embedded_in/proxy.rb#118
    def path(document); end
  end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embedded_in.rb#32
Mongoid::Association::Embedded::EmbeddedIn::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# The EmbedsMany type association.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many/binding.rb#7
class Mongoid::Association::Embedded::EmbedsMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbedsMany::Buildable

  # Get a criteria object for searching given a parent and children documents.
  #
  # @param base [Document] The base document.
  # @param target [Document] The children documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#137
  def criteria(base, target); end

  # Is this association type embedded?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#66
  def embedded?; end

  # The key that is used to get the attributes for the associated object.
  #
  # @return [String] The name of the field used to store the association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#59
  def key; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::Many] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#116
  def nested_builder(attributes, options); end

  # Get the path calculator for the supplied document.
  #
  # @example Get the path calculator.
  #   Proxy.path(document)
  # @param document [Document] The document to calculate on.
  # @return [Mongoid::Atomic::Paths::Embedded::Many] The embedded many atomic path calculator.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#129
  def path(document); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#97
  def polymorphic?; end

  # The primary key
  #
  # @return [nil] Not relevant for this association
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#85
  def primary_key; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::Embedded::EmbedsMany::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#90
  def relation; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#42
  def setup!; end

  # The field key used to store the list of association objects.
  #
  # @return [String] The field name.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#52
  def store_as; end

  # Does this association type store the foreign key?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#80
  def stores_foreign_key?; end

  # The field used to store the type of the related object.
  #
  # @note Only relevant if the association is polymorphic.
  # @return [String | nil] The field for storing the associated object's type.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#106
  def type; end

  # Get the default validation setting for the association. Determines if
  # by default a validates associated will occur.
  #
  # @example Get the validation default.
  #   Proxy.validation_default
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#75
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#148
  def apply_ordering(criteria); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#170
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#166
  def polymorphic_inverses(other = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#162
  def relation_complements; end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#152
  def setup_instance_methods!; end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#21
Mongoid::Association::Embedded::EmbedsMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for all embeds_many associations.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many/binding.rb#10
class Mongoid::Association::Embedded::EmbedsMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # @example Bind one document.
  #   person.addresses.bind_one(address)
  # @param doc [Document] The single document to bind.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/binding.rb#20
  def bind_one(doc); end

  # Unbind a single document.
  #
  # @example Unbind the document.
  #   person.addresses.unbind_one(document)
  # @param doc [Document] The single document to unbind.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/binding.rb#34
  def unbind_one(doc); end
end

# Builder class for embeds_many associations.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many/buildable.rb#10
module Mongoid::Association::Embedded::EmbedsMany::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  # Builds the document out of the attributes using the provided
  # association metadata. Instantiates through the factory in order
  # to make sure subclasses and allocation are used if fitting. This
  # case will return many documents.
  #
  # @example Build the documents.
  #   Builder.new(meta, attrs).build
  # @param base [Document] The base object.
  # @param object [Array<Document> | Array<Hash>] The object to use
  #   to build the association.
  # @param selected_fields [Hash] Fields which were retrieved via
  #   #only. If selected_fields are specified, fields not listed in it
  #   will not be accessible in the built documents.
  # @param type [String] Not used in this context.
  # @return [Array<Document ] The documents.] Array<Document ] The documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/buildable.rb#30
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

# Transparent proxy for embeds_many associations.
# An instance of this class is returned when calling the
# association getter method on the parent document. This
# class inherits from Mongoid::Association::Proxy and forwards
# most of its methods to the target of the association, i.e.
# the array of child documents.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#15
class Mongoid::Association::Embedded::EmbedsMany::Proxy < ::Mongoid::Association::Many
  include ::Mongoid::Positional
  include ::Mongoid::Association::Embedded::Batchable
  extend ::Mongoid::Association::Embedded::EmbedsMany::Proxy::ClassMethods

  # Instantiate a new embeds_many association.
  #
  # @example Create the new association.
  #   Many.new(person, addresses, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The document this association hangs off of.
  # @param target [Array<Document>] The child documents of the association.
  # @return [Many] The proxy.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#70
  def initialize(base, target, association); end

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.addresses << address
  # @example Push a document.
  #   person.addresses.push(address)
  # @param *args [Document...] Any number of documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#92
  def <<(*args); end

  # Removes a single document from the collection *in memory only*.
  # It will *not* persist the change.
  #
  # @api private
  # @param document [Document] The document to delete.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#239
  def _remove(document); end

  # Get this association as as its representation in the database.
  #
  # @example Convert the association to an attributes hash.
  #   person.addresses.as_document
  # @return [Array<Hash>] The association as stored in the db.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#113
  def as_document; end

  # Builds a new document in the association and appends it to the target.
  # Takes an optional type if you want to specify a subclass.
  #
  # @example Build a new document on the association.
  #   person.people.build(:name => "Bozo")
  # @param attributes [Hash] The attributes to build the document with.
  # @param type [Class] Optional class to build the document with.
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#141
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # Clear the association. Will delete the documents from the db
  # if they are already persisted.
  #
  # If the host document is not persisted but its _id matches a
  # persisted document, calling #clear on an association will remove
  # the association's documents from the database even though the
  # set of documents in the application (as loaded in the host)
  # is different from what is in the database, and the host may
  # not contain any persisted documents in the association either.
  #
  # @example Clear the association.
  #   person.addresses.clear
  # @return [self] The empty association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#168
  def clear; end

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # @example Concat with other documents.
  #   person.addresses.concat([ address_one, address_two ])
  # @param docs [Array<Document>] The docs to add.
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#126
  def concat(docs); end

  # Returns a count of the number of documents in the association that have
  # actually been persisted to the database.
  #
  # Use #size if you want the total number of documents.
  #
  # If args or block are present, #count will delegate to the
  # #count method on +target+ and will include both persisted
  # and non-persisted documents.
  #
  # @example Get the count of all documents matching a block.
  #   person.addresses.count { |a| a.country == "FR" }
  # @example Get the count of persisted documents.
  #   person.addresses.count
  # @example Use #persisted? inside block to count persisted documents.
  #   person.addresses.count { |a| a.persisted? && a.country == "FR" }
  # @param *args [Object...] Args to delegate to the target.
  # @return [Integer] The total number of persisted embedded docs, as
  #   flagged by the #persisted? method.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#196
  def count(*args, &block); end

  # Delete the supplied document from the target. This method is proxied
  # in order to reindex the array after the operation occurs.
  #
  # @example Delete the document from the association.
  #   person.addresses.delete(address)
  # @param document [Document] The document to be deleted.
  # @return [Document | nil] The deleted document or nil if nothing deleted.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#211
  def delete(document); end

  # Delete all the documents in the association without running callbacks.
  #
  # @example Conditionally delete documents from the association.
  #   person.addresses.delete_all({ :street => "Bond" })
  # @example Delete all documents from the association.
  #   person.addresses.delete_all
  # @param conditions [Hash] Conditions on which documents to delete.
  # @return [Integer] The number of documents deleted.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#257
  def delete_all(conditions = T.unsafe(nil)); end

  # Delete all the documents for which the provided block returns true.
  #
  # @example Delete the matching documents.
  #   person.addresses.delete_if do |doc|
  #   doc.state == "GA"
  #   end
  # @return [EmbedsMany::Proxy | Enumerator] The proxy or an
  #   enumerator if no block was provided.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#270
  def delete_if; end

  # Delete the supplied document from the target. This method is proxied
  # in order to reindex the array after the operation occurs.
  # Mongoid::Extensions::Array defines Array#delete_one, so we need
  # to make sure that method behaves reasonably on proxies, too.
  #
  # @example Delete the document from the association.
  #   person.addresses.delete(address)
  # @param document [Document] The document to be deleted.
  # @return [Document | nil] The deleted document or nil if nothing deleted.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#231
  def delete_one(document); end

  # Destroy all the documents in the association whilst running callbacks.
  #
  # @example Conditionally destroy documents from the association.
  #   person.addresses.destroy_all({ :street => "Bond" })
  # @example Destroy all documents from the association.
  #   person.addresses.destroy_all
  # @param conditions [Hash] Conditions on which documents to destroy.
  # @return [Integer] The number of documents destroyed.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#289
  def destroy_all(conditions = T.unsafe(nil)); end

  # Determine if any documents in this association exist in the database.
  #
  # @example Are there persisted documents?
  #   person.posts.exists?
  # @param id_or_conditions [:none | nil | false | Hash | Object] When :none (the default), returns true if any persisted
  #   documents exist in the association. When nil or false, this
  #   will always return false. When a Hash is given, this queries
  #   the documents in the association for those that match the given
  #   conditions, and returns true if any match which have been
  #   persisted. Any other argument is interpreted as an id, and
  #   queries for the existence of persisted documents in the
  #   association with a matching _id.
  # @return [true | false] True if persisted documents exist, false if not.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#309
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#58
  def find(*_arg0, **_arg1, &_arg2); end

  # Get all the documents in the association that are loaded into memory.
  #
  # @example Get the in memory documents.
  #   relation.in_memory
  # @return [Array<Document>] The documents in memory.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#324
  def in_memory; end

  # Builds a new document in the association and appends it to the target.
  # Takes an optional type if you want to specify a subclass.
  #
  # @example Build a new document on the association.
  #   person.people.build(:name => "Bozo")
  # @param attributes [Hash] The attributes to build the document with.
  # @param type [Class] Optional class to build the document with.
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#152
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#58
  def pluck(*_arg0, **_arg1, &_arg2); end

  # Pop documents off the association. This can be a single document or
  # multiples, and will automatically persist the changes.
  #
  # @example Pop a single document.
  #   relation.pop
  # @example Pop multiple documents.
  #   relation.pop(3)
  # @param count [Integer] The number of documents to pop, or 1 if not
  #   provided.
  # @return [Document | Array<Document> | nil] The popped document(s).
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#339
  def pop(count = T.unsafe(nil)); end

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.addresses << address
  # @example Push a document.
  #   person.addresses.push(address)
  # @param *args [Document...] Any number of documents.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#105
  def push(*args); end

  # Shift documents off the association. This can be a single document or
  # multiples, and will automatically persist the changes.
  #
  # @example Shift a single document.
  #   relation.shift
  # @example Shift multiple documents.
  #   relation.shift(3)
  # @param count [Integer] The number of documents to shift, or 1 if not
  #   provided.
  # @return [Document | Array<Document> | nil] The shifted document(s).
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#359
  def shift(count = T.unsafe(nil)); end

  # Substitutes the supplied target documents for the existing documents
  # in the relation.
  #
  # @example Substitute the association's target.
  #   person.addresses.substitute([ address ])
  # @param docs [Array<Document> | Array<Hash>] The replacement docs.
  # @return [Many] The proxied association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#375
  def substitute(docs); end

  # Return the association with all previous scoping removed. This is the
  # exact representation of the docs in the database.
  #
  # @example Get the unscoped documents.
  #   person.addresses.unscoped
  # @return [Criteria] The unscoped association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#388
  def unscoped; end

  private

  # Returns the value of attribute _unscoped.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#397
  def _unscoped; end

  # Sets the attribute _unscoped
  #
  # @param value the value to set the attribute _unscoped to.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#397
  def _unscoped=(_arg0); end

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # @example Append to the document.
  #   relation.append(document)
  # @param document [Document] The document to append to the target.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#410
  def append(document); end

  # Optimized version of #append that handles multiple documents
  # in a more efficient way.
  #
  # @param documents [Array<Document>] The documents to append.
  # @return [EmbedsMany::Proxy] This proxy instance.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#432
  def append_many(documents, &block); end

  # Returns a list of attributes hashes for each document.
  #
  # @return [Array<Hash>] The list of attributes hashes
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#595
  def as_attributes; end

  # Instantiate the binding associated with this association.
  #
  # @example Create the binding.
  #   relation.binding([ address ])
  # @return [Binding] The many binding.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#487
  def binding; end

  # Returns the +Criteria+ object for the target class with its
  # documents set to the list of target documents in the association.
  #
  # @return [Criteria] A new criteria.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#495
  def criteria; end

  # Returns a unique id for the document, which is either
  # its _id or its object_id.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#422
  def id_of(doc); end

  # Integrate the document into the association. will set its metadata and
  # attempt to bind the inverse.
  #
  # @example Integrate the document.
  #   relation.integrate(document)
  # @param document [Document] The document to integrate.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#506
  def integrate(document); end

  # If the target array does not respond to the supplied method then try to
  # find a named scope or criteria on the class and send the call there.
  #
  # If the method exists on the array, use the default proxy behavior.
  #
  # TODO: make sure we are consistingly using respond_to_missing
  #   anywhere we define method_missing.
  #
  # @param &block Optional block to pass.
  # @param *args [Object...] The method args.
  # @param name [Symbol | String] The name of the method.
  # @return [Criteria | Object] A Criteria or return value from the target.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#525
  def method_missing(name, *args, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#399
  def object_already_related?(document); end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#540
  def persistable?; end

  # Processes the list of documents, building a list of those
  # that are not already in the association, and preparing
  # each unique document to be integrated into the association.
  #
  # The :before_add callback is executed for each unique document
  # as part of this step.
  #
  # @param documents [Array<Document>] The incoming documents to
  #   process.
  # @return [Array<Document>] The list of unique documents that
  #   do not yet exist in the association.
  # @yield [Document] Optional block to call for each unique
  #   document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#459
  def process_incoming_docs(documents, &block); end

  # Reindex all the target elements. This is useful when performing
  # operations on the proxied target directly and the indices need to
  # match that on the database side.
  #
  # @example Reindex the association.
  #   person.addresses.reindex
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#550
  def reindex; end

  # Remove all documents from the association, either with a delete or a
  # destroy depending on what this was called through.
  #
  # @example Destroy documents from the association.
  #   relation.remove_all({ :num => 1 }, true)
  # @param conditions [Hash] Conditions to filter by.
  # @param method [true | false] :delete or :destroy.
  # @return [Integer] The number of documents removed.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#584
  def remove_all(conditions = T.unsafe(nil), method = T.unsafe(nil)); end

  # Apply the association ordering and default scoping (defined on
  # association's target class) to the provided documents.
  #
  # @example Apply scoping.
  #   person.addresses.scope(target)
  # @param docs [Array<Document>] The documents to scope.
  # @return [Array<Document>] The scoped docs.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#565
  def scope(docs); end

  # Update the _base's attributes hash with the _target's attributes
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#602
  def update_attributes_hash; end
end

# Class-level methods for the Proxy class.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#20
module Mongoid::Association::Embedded::EmbedsMany::Proxy::ClassMethods
  # Returns the eager loader for this association.
  #
  # @param associations [Array<Mongoid::Association>] The
  #   associations to be eager loaded
  # @param docs [Array<Mongoid::Document>] The parent documents
  #   that possess the given associations, which ought to be
  #   populated by the eager-loaded documents.
  # @return [Mongoid::Association::Embedded::Eager]
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#30
  def eager_loader(associations, docs); end

  # Returns true if the association is an embedded one. In this case
  # always true.
  #
  # @example Is the association embedded?
  #   Association::Embedded::EmbedsMany.embedded?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#41
  def embedded?; end

  # Returns the suffix of the foreign key field, either "_id" or "_ids".
  #
  # @example Get the suffix for the foreign key.
  #   Association::Embedded::EmbedsMany.foreign_key_suffix
  # @return [nil] nil.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_many/proxy.rb#51
  def foreign_key_suffix; end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_many.rb#37
Mongoid::Association::Embedded::EmbedsMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# The EmbedsOne type association.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one/binding.rb#7
class Mongoid::Association::Embedded::EmbedsOne
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Embedded::EmbedsOne::Buildable

  # Is this association type embedded?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#62
  def embedded?; end

  # The key that is used to get the attributes for the associated object.
  #
  # @return [String] The name of the field used to store the association.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#55
  def key; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::One] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#112
  def nested_builder(attributes, options); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#93
  def polymorphic?; end

  # The primary key
  #
  # @return [nil] Not relevant for this association
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#81
  def primary_key; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::Embedded::EmbedsMany::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#86
  def relation; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#38
  def setup!; end

  # The field key used to store the association object.
  #
  # @return [String] The field name.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#48
  def store_as; end

  # Does this association type store the foreign key?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#76
  def stores_foreign_key?; end

  # The field used to store the type of the related object.
  #
  # @note Only relevant if the association is polymorphic.
  # @return [String | nil] The field for storing the associated object's type.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#102
  def type; end

  # Get the default validation setting for the association. Determines if
  # by default a validates associated will occur.
  #
  # @example Get the validation default.
  #   Proxy.validation_default
  # @return [true | false] The validation default.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#71
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#136
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#132
  def polymorphic_inverses(other = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#128
  def relation_complements; end

  # source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#118
  def setup_instance_methods!; end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#21
Mongoid::Association::Embedded::EmbedsOne::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for all embeds_one associations.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one/binding.rb#10
class Mongoid::Association::Embedded::EmbedsOne::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # @example Bind the document.
  #   person.name.bind(:continue => true)
  #   person.name = Name.new
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/binding.rb#22
  def bind_one; end

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # @example Unbind the document.
  #   person.name.unbind(:continue => true)
  #   person.name = nil
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/binding.rb#35
  def unbind_one; end
end

# Builder class for embeds_one associations.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one/buildable.rb#10
module Mongoid::Association::Embedded::EmbedsOne::Buildable
  include ::Mongoid::Threaded::Lifecycle
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  # Builds the document out of the attributes using the provided
  # association metadata on the association. Instantiates through the factory in order
  # to make sure subclasses and allocation are used if fitting.
  #
  # @example Build the document.
  #   Builder.new(meta, attrs).build
  # @param _type [String] Not used in this context.
  # @param base [Document] The document this association hangs off of.
  # @param object [Document | Hash] The related document.
  # @param selected_fields [Hash] Fields which were retrieved via
  #   #only. If selected_fields are specified, fields not listed in it
  #   will not be accessible in the built document.
  # @return [Document] A single document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/buildable.rb#28
  def build(base, object, _type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/association/embedded/embeds_one/buildable.rb#43
  def clear_associated(doc); end
end

# Transparent proxy for embeds_one associations.
# An instance of this class is returned when calling the
# association getter method on the parent document. This
# class inherits from Mongoid::Association::Proxy and forwards
# most of its methods to the target of the association, i.e.
# the child document.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#13
class Mongoid::Association::Embedded::EmbedsOne::Proxy < ::Mongoid::Association::One
  # Instantiate a new embeds_one association.
  #
  # @example Create the new proxy.
  #   One.new(person, name, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The document this association hangs off of.
  # @param target [Document] The child document in the association.
  # @return [Proxy] a new instance of Proxy
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#33
  def initialize(base, target, association); end

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # @example Substitute the new document.
  #   person.name.substitute(new_name)
  # @param replacement [Document | Hash] A document to replace the target.
  # @return [Document | nil] The association or nil.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#53
  def substitute(replacement); end

  private

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding.
  #   relation.binding([ address ])
  # @return [Binding] The association's binding.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#79
  def binding; end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#89
  def persistable?; end

  # Replaces the current document with the given replacement
  # document, which may be a Hash of attributes.
  #
  # @param replacement [Mongoid::Document | Hash] the document to
  #   substitute in place of the current document.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#171
  def replace_with(replacement); end

  # Checks the argument. If it is non-nil, this method does nothing.
  # Otherwise, it performs the logic for replacing the current
  # document with nil.
  #
  # @param replacement [Mongoid::Document | Hash | nil] the document
  #   to check.
  # @return [true | false] whether a nil document was substituted
  #   or not.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#150
  def replace_with_nil_document(replacement); end

  # Update the _base's attributes hash with the _target's attributes
  #
  # @api private
  # @param replacement [Document | nil] The doc to use to update the
  #   attributes hash.
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#99
  def update_attributes_hash(replacement); end

  # When not ``_assigning?``, the target may need to be destroyed, and
  # may need to be marked as a new record. This method takes care of
  # that, with extensive documentation for why it is necessary.
  #
  # @param replacement [Mongoid::Document] the replacement document
  #
  # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#112
  def update_target_when_not_assigning(replacement); end

  class << self
    # Returns the eager loader for this association.
    #
    # @param associations [Array<Mongoid::Association>] The
    #   associations to be eager loaded
    # @param docs [Array<Mongoid::Document>] The parent documents
    #   that possess the given associations, which ought to be
    #   populated by the eager-loaded documents.
    # @return [Mongoid::Association::Embedded::Eager]
    #
    # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#190
    def eager_loader(associations, docs); end

    # Returns true if the association is an embedded one. In this case
    # always true.
    #
    # @example Is this association embedded?
    #   Association::Embedded::EmbedsOne.embedded?
    # @return [true] true.
    #
    # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#201
    def embedded?; end

    # Get the path calculator for the supplied document.
    #
    # @example Get the path calculator.
    #   Proxy.path(document)
    # @param document [Document] The document to calculate on.
    # @return [Mongoid::Atomic::Paths::Embedded::One] The embedded one atomic path calculator.
    #
    # source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#214
    def path(document); end
  end
end

# The valid options when defining this association.
#
# @return [Array<Symbol>] The allowed options when defining this association.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one/proxy.rb#17
Mongoid::Association::Embedded::EmbedsOne::Proxy::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/embedded/embeds_one.rb#33
Mongoid::Association::Embedded::EmbedsOne::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# Map the macros to their corresponding Association classes.
#
# @return [Hash] The mapping from macros to their Association class.
#
# source://mongoid//lib/mongoid/association.rb#41
Mongoid::Association::MACRO_MAPPING = T.let(T.unsafe(nil), Hash)

# This module contains the core macros for defining associations between
# documents. They can be either embedded or referenced.
#
# source://mongoid//lib/mongoid/association/macros.rb#7
module Mongoid::Association::Macros
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods

  # This is convenience for libraries still on the old API.
  #
  # @example Get the associations.
  #   person.associations
  # @return [Hash] The associations.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#54
  def associations; end

  module GeneratedClassMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

# Class methods for associations.
#
# source://mongoid//lib/mongoid/association/macros.rb#59
module Mongoid::Association::Macros::ClassMethods
  # Adds a referenced association from the child Document to a Document
  # in another database or collection.
  #
  # @example Define the association.
  #
  #   class Game
  #   include Mongoid::Document
  #   belongs_to :person
  #   end
  #
  #   class Person
  #   include Mongoid::Document
  #   has_one :game
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#148
  def belongs_to(name, options = T.unsafe(nil), &block); end

  # Adds the association back to the parent document. This macro is
  # necessary to set the references from the child back to the parent
  # document. If a child does not define this association calling
  # persistence methods on the child object will cause a save to fail.
  #
  # @example Define the association.
  #
  #   class Person
  #   include Mongoid::Document
  #   embeds_many :addresses
  #   end
  #
  #   class Address
  #   include Mongoid::Document
  #   embedded_in :person
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#80
  def embedded_in(name, options = T.unsafe(nil), &block); end

  # Adds the association from a parent document to its children. The name
  # of the association needs to be a pluralized form of the child class
  # name.
  #
  # @example Define the association.
  #
  #   class Person
  #   include Mongoid::Document
  #   embeds_many :addresses
  #   end
  #
  #   class Address
  #   include Mongoid::Document
  #   embedded_in :person
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#103
  def embeds_many(name, options = T.unsafe(nil), &block); end

  # Adds the association from a parent document to its child. The name
  # of the association needs to be a singular form of the child class
  # name.
  #
  # @example Define the association.
  #
  #   class Person
  #   include Mongoid::Document
  #   embeds_one :name
  #   end
  #
  #   class Name
  #   include Mongoid::Document
  #   embedded_in :person
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#126
  def embeds_one(name, options = T.unsafe(nil), &block); end

  # Adds a referenced many-to-many association between many of this
  # Document and many of another Document.
  #
  # @example Define the association.
  #
  #   class Person
  #   include Mongoid::Document
  #   has_and_belongs_to_many :preferences
  #   end
  #
  #   class Preference
  #   include Mongoid::Document
  #   has_and_belongs_to_many :people
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#194
  def has_and_belongs_to_many(name, options = T.unsafe(nil), &block); end

  # Adds a referenced association from a parent Document to many
  # Documents in another database or collection.
  #
  # @example Define the association.
  #
  #   class Person
  #   include Mongoid::Document
  #   has_many :posts
  #   end
  #
  #   class Game
  #   include Mongoid::Document
  #   belongs_to :person
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#172
  def has_many(name, options = T.unsafe(nil), &block); end

  # Adds a referenced association from the child Document to a Document
  # in another database or collection.
  #
  # @example Define the association.
  #
  #   class Game
  #   include Mongoid::Document
  #   belongs_to :person
  #   end
  #
  #   class Person
  #   include Mongoid::Document
  #   has_one :game
  #   end
  # @param &block Optional block for defining extensions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/macros.rb#216
  def has_one(name, options = T.unsafe(nil), &block); end

  private

  # source://mongoid//lib/mongoid/association/macros.rb#224
  def define_association!(macro_name, name, options = T.unsafe(nil), &block); end
end

# This is the superclass for all many to one and many to many association
# proxies.
#
# source://mongoid//lib/mongoid/association/many.rb#9
class Mongoid::Association::Many < ::Mongoid::Association::Proxy
  include ::Enumerable

  # source://mongoid//lib/mongoid/association/many.rb#14
  def any?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/many.rb#13
  def avg(*_arg0, **_arg1, &_arg2); end

  # Is the association empty?
  #
  # @example Is the association empty??
  #   person.addresses.blank?
  # @return [true | false] If the association is empty or not.
  #
  # source://mongoid//lib/mongoid/association/many.rb#22
  def blank?; end

  # Creates a new document on the references many association. This will
  # save the document if the parent has been persisted.
  #
  # @example Create and save the new document.
  #   person.posts.create(:text => "Testing")
  # @param attributes [Hash] The attributes to create with.
  # @param type [Class] The optional type of document to create.
  # @return [Document] The newly created document.
  #
  # source://mongoid//lib/mongoid/association/many.rb#36
  def create(attributes = T.unsafe(nil), type = T.unsafe(nil), &block); end

  # Creates a new document on the references many association. This will
  # save the document if the parent has been persisted and will raise an
  # error if validation fails.
  #
  # @example Create and save the new document.
  #   person.posts.create!(:text => "Testing")
  # @param attributes [Hash] The attributes to create with.
  # @param type [Class] The optional type of document to create.
  # @raise [Errors::Validations] If validation failed.
  # @return [Document] The newly created document.
  #
  # source://mongoid//lib/mongoid/association/many.rb#59
  def create!(attributes = T.unsafe(nil), type = T.unsafe(nil), &block); end

  # Find the first document given the conditions, or creates a new document
  # with the conditions that were supplied.
  #
  #  @param [ Hash ] attrs The attributes to search or create with.
  #  @param [ Class ] type The optional type of document to create.
  #
  # @example Find or create.
  #   person.posts.find_or_create_by(:title => "Testing")
  # @return [Document] An existing document or newly created one.
  #
  # source://mongoid//lib/mongoid/association/many.rb#84
  def find_or_create_by(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end

  # Find the first document given the conditions, or creates a new document
  # with the conditions that were supplied. This will raise an error if validation fails.
  #
  # @example Find or create.
  #   person.posts.find_or_create_by!(:title => "Testing")
  # @param attrs [Hash] The attributes to search or create with.
  # @param type [Class] The optional type of document to create.
  # @raise [Errors::Validations] If validation failed.
  # @return [Document] An existing document or newly created one.
  #
  # source://mongoid//lib/mongoid/association/many.rb#100
  def find_or_create_by!(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end

  # Find the first +Document+ given the conditions, or instantiates a new document
  # with the conditions that were supplied
  #
  # @example Find or initialize.
  #   person.posts.find_or_initialize_by(:title => "Test")
  # @param attrs [Hash] The attributes to search or initialize with.
  # @param type [Class] The optional subclass to build.
  # @return [Document] An existing document or newly instantiated one.
  #
  # source://mongoid//lib/mongoid/association/many.rb#114
  def find_or_initialize_by(attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end

  # source://mongoid//lib/mongoid/association/many.rb#14
  def length(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/many.rb#13
  def max(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/many.rb#13
  def min(*_arg0, **_arg1, &_arg2); end

  # This proxy can never be nil.
  #
  # @example Is the proxy nil?
  #   relation.nil?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/many.rb#124
  def nil?; end

  # Since method_missing is overridden we should override this as well.
  #
  # @example Does the proxy respond to the method?
  #   relation.respond_to?(:name)
  # @param include_private [true | false] Whether to include private methods.
  # @param name [Symbol] The method name.
  # @return [true | false] If the proxy responds to the method.
  #
  # source://mongoid//lib/mongoid/association/many.rb#137
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # This is public access to the association's criteria.
  #
  # @example Get the scoped association.
  #   relation.scoped
  # @return [Criteria] The scoped criteria.
  #
  # source://mongoid//lib/mongoid/association/many.rb#148
  def scoped; end

  # Gets the document as a serializable hash, used by ActiveModel's JSON and
  # XML serializers. This override is just to be able to pass the :include
  # and :except options to get associations in the hash.
  #
  # @example Get the serializable hash.
  #   relation.serializable_hash
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options to pass.
  # @return [Hash] The documents, ready to be serialized.
  #
  # source://mongoid//lib/mongoid/association/many.rb#166
  def serializable_hash(options = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/association/many.rb#14
  def size(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/many.rb#13
  def sum(*_arg0, **_arg1, &_arg2); end

  # Get a criteria for the embedded documents without the default scoping
  # applied.
  #
  # @example Get the unscoped criteria.
  #   person.addresses.unscoped
  # @return [Criteria] The unscoped criteria.
  #
  # source://mongoid//lib/mongoid/association/many.rb#177
  def unscoped; end

  private

  # source://mongoid//lib/mongoid/association/many.rb#183
  def _session; end

  # Find the first object given the supplied attributes or create/initialize it.
  #
  # @example Find or create|initialize.
  #   person.addresses.find_or(:create, :street => "Bond")
  #
  #   @param [ Symbol ] method The method name, create or new.
  #   @param [ Hash ] attrs The attributes to search or build with.
  #   @param [ Class ] type The optional subclass to build.
  # @return [Document] A matching document or a new/created one.
  #
  # source://mongoid//lib/mongoid/association/many.rb#197
  def find_or(method, attrs = T.unsafe(nil), type = T.unsafe(nil), &block); end
end

# Mixin module for Mongoid::Association::Proxy which adds
# custom Marshal.dump functionality.
#
# source://mongoid//lib/mongoid/association/marshalable.rb#9
module Mongoid::Association::Marshalable
  # Provides the data needed to Marshal.dump an association proxy.
  #
  # @example Dump the proxy.
  #   Marshal.dump(proxy)
  # @return [Array<Object>] The dumped data.
  #
  # source://mongoid//lib/mongoid/association/marshalable.rb#17
  def marshal_dump; end

  # Takes the provided data and sets it back on the proxy.
  #
  # @example Load the proxy.
  #   Marshal.load(proxy)
  # @param data [Array<Object>] The data to set on the proxy.
  # @return [Array<Object>] The loaded data.
  #
  # source://mongoid//lib/mongoid/association/marshalable.rb#29
  def marshal_load(data); end
end

# source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#6
module Mongoid::Association::Nested; end

# Mixin module containing common functionality used to
# perform #accepts_nested_attributes_for attribute assignment
# on associations.
#
# source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#11
module Mongoid::Association::Nested::Buildable
  # Determines if destroys are allowed for this document.
  #
  # @example Do we allow a destroy?
  #   builder.allow_destroy?
  # @return [true | false] True if the allow destroy option was set.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#21
  def allow_destroy?; end

  # Returns the value of attribute association.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def association; end

  # Sets the attribute association
  #
  # @param value the value to set the attribute association to.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def association=(_arg0); end

  # Returns the value of attribute attributes.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def attributes=(_arg0); end

  # Convert an id to its appropriate type.
  #
  # @example Convert the id.
  #   builder.convert_id(Person, "4d371b444835d98b8b000010")
  # @param id [String] The id, usually coming from the form.
  # @param klass [Class] The class we're trying to convert for.
  # @return [BSON::ObjectId | String | Object] The converted id.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#65
  def convert_id(klass, id); end

  # Returns the value of attribute existing.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def existing; end

  # Sets the attribute existing
  #
  # @param value the value to set the attribute existing to.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def existing=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#13
  def options=(_arg0); end

  # Returns the reject if option defined with the macro.
  #
  # @example Is there a reject proc?
  #   builder.reject?
  # @param attrs [Hash] The attributes to check for rejection.
  # @param document [Document] The parent document of the association
  # @return [true | false] True and call proc or method if rejectable, false if not.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#34
  def reject?(document, attrs); end

  # Determines if only updates can occur. Only valid for one-to-one
  # associations.
  #
  # @example Is this update only?
  #   builder.update_only?
  # @return [true | false] True if the update_only option was set.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#52
  def update_only?; end

  private

  # Deletes the id key from the given hash.
  #
  # @example Delete an id value.
  #   delete_id({ "_id" => 1 })
  # @param hash [Hash] The hash from which to delete.
  # @return [Object] The deleted value, or nil.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#92
  def delete_id(hash); end

  # Get the id attribute from the given hash, whether it's
  # prefixed with an underscore or is a symbol.
  #
  # @example Get the id.
  #   extract_id({ _id: 1 })
  # @param hash [Hash] The hash from which to extract.
  # @return [Object] The value of the id.
  #
  # source://mongoid//lib/mongoid/association/nested/nested_buildable.rb#80
  def extract_id(hash); end
end

# The flags indicating that an association can be destroyed.
#
# source://mongoid//lib/mongoid/association/nested.rb#13
Mongoid::Association::Nested::DESTROY_FLAGS = T.let(T.unsafe(nil), Array)

# Builder class used to perform #accepts_nested_attributes_for
# attribute assignment on many-to-n associations.
#
# source://mongoid//lib/mongoid/association/nested/many.rb#10
class Mongoid::Association::Nested::Many
  include ::Mongoid::Association::Nested::Buildable

  # Create the new builder for nested attributes on one-to-many
  # associations.
  #
  # @example Initialize the builder.
  #   Many.new(association, attributes, options)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param attributes [Hash] The attributes hash to attempt to set.
  # @param options [Hash] The options defined.
  # @return [Many] a new instance of Many
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#50
  def initialize(association, attributes, options = T.unsafe(nil)); end

  # Builds the association depending on the attributes and the options
  # passed to the macro.
  #
  # This attempts to perform 3 operations, either one of an update of
  # the existing association, a replacement of the association with a new
  # document, or a removal of the association.
  #
  # @example Build the nested attrs.
  #   many.build(person)
  # @param options [Hash] The options.
  # @param parent [Document] The parent document of the association.
  # @return [Array] The attributes.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#27
  def build(parent, options = T.unsafe(nil)); end

  private

  # Destroy the child document, needs to do some checking for embedded
  # associations and delay the destroy in case parent validation fails.
  #
  # @api private
  # @example Destroy the child.
  #   builder.destroy(parent, relation, doc)
  # @param doc [Document] The doc to destroy.
  # @param parent [Document] The parent document.
  # @param relation [Proxy] The association proxy.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#123
  def destroy(parent, relation, doc); end

  # Destroy the document.
  #
  # @api private
  # @example Destroy the document.
  #   builder.destroy_document(relation, doc)
  # @param doc [Document] The document to delete.
  # @param relation [Proxy] The association proxy.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#141
  def destroy_document(relation, doc); end

  # Can the existing association potentially be deleted?
  #
  # @example Is the document destroyable?
  #   destroyable?({ :_destroy => "1" })
  # @param attributes [Hash] The attributes to pull the flag from.
  # @return [true | false] If the association can potentially be deleted.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#73
  def destroyable?(attributes); end

  # Are the supplied attributes of greater number than the supplied
  # limit?
  #
  # @example Are we over the set limit?
  #   builder.over_limit?({ "street" => "Bond" })
  # @param attributes [Hash] The attributes being set.
  # @return [true | false] If the attributes exceed the limit.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#87
  def over_limit?(attributes); end

  # Process each set of attributes one at a time for each potential
  # new, existing, or ignored document.
  #
  # @api private
  # @example Process the attributes
  #   builder.process_attributes({ "id" => 1, "street" => "Bond" })
  # @param attrs [Hash] The single document attributes to process.
  # @param parent [Document] The parent document.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#102
  def process_attributes(parent, attrs); end

  # Update the document.
  #
  # @api private
  # @example Update the document.
  #   builder.update_document(doc, {}, options)
  # @param attrs [Hash] The attributes.
  # @param doc [Document] The document to update.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#156
  def update_document(doc, attrs); end

  # Update nested association.
  #
  # @api private
  # @example Update nested association.
  #   builder.update_nested_relation(parent, id, attrs)
  # @param attrs [Hash] The single document attributes to process.
  # @param id [String | BSON::ObjectId] of the related document.
  # @param parent [Document] The parent document.
  #
  # source://mongoid//lib/mongoid/association/nested/many.rb#175
  def update_nested_relation(parent, id, attrs); end
end

# Builder class used to perform #accepts_nested_attributes_for
# attribute assignment on one-to-n associations.
#
# source://mongoid//lib/mongoid/association/nested/one.rb#10
class Mongoid::Association::Nested::One
  include ::Mongoid::Association::Nested::Buildable

  # Create the new builder for nested attributes on one-to-one
  # associations.
  #
  # @example Instantiate the builder.
  #   One.new(association, attributes)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param attributes [Hash] The attributes hash to attempt to set.
  # @param options [Hash] The options defined.
  # @return [One] a new instance of One
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#52
  def initialize(association, attributes, options); end

  # Builds the association depending on the attributes and the options
  # passed to the macro.
  #
  # @example Build a 1-1 nested document.
  #   one.build(person, as: :admin)
  # @note This attempts to perform 3 operations, either one of an update of
  #   the existing association, a replacement of the association with a new
  #   document, or a removal of the association.
  # @param parent [Document] The parent document.
  # @return [Document] The built document.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#28
  def build(parent); end

  # Returns the value of attribute destroy.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#13
  def destroy; end

  # Sets the attribute destroy
  #
  # @param value the value to set the attribute destroy to.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#13
  def destroy=(_arg0); end

  private

  # Is the id in the attributes acceptable for allowing an update to
  # the existing association?
  #
  # @api private
  # @example Is the id acceptable?
  #   one.acceptable_id?
  # @return [true | false] If the id part of the logic will allow an update.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#95
  def acceptable_id?; end

  # Checks to see if the _id attribute (which is supposed to be
  # immutable) is being asked to change. If so, raise an exception.
  #
  # If Mongoid::Config.immutable_ids is false, this will do nothing,
  # and the update operation will fail silently.
  #
  # @raise [Errors::ImmutableAttribute] if _id has changed, and
  #   the document has been persisted.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#150
  def check_for_id_violation!; end

  # Coerces the argument into a class, or defaults to the association's class.
  #
  # @param name_or_class [String | Mongoid::Document | nil] the value to coerce
  # @return [Mongoid::Document] the resulting class
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#67
  def class_from(name_or_class); end

  # Can the existing association be deleted?
  #
  # @example Can the existing object be deleted?
  #   one.delete?
  # @return [true | false] If the association should be deleted.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#106
  def delete?; end

  # Can the existing association potentially be destroyed?
  #
  # @example Is the object destroyable?
  #   one.destroyable?({ :_destroy => "1" })
  # @return [true | false] If the association can potentially be
  #   destroyed.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#118
  def destroyable?; end

  # Extracts and converts the id to the expected type.
  #
  # @return [BSON::ObjectId | String | Object | nil] The converted id,
  #   or nil if no id is present in the attributes hash.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#79
  def extracted_id; end

  # Is the document to be replaced?
  #
  # @example Is the document to be replaced?
  #   one.replace?
  # @return [true | false] If the document should be replaced.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#128
  def replace?; end

  # Should the document be updated?
  #
  # @example Should the document be updated?
  #   one.update?
  # @return [true | false] If the object should have its attributes updated.
  #
  # source://mongoid//lib/mongoid/association/nested/one.rb#138
  def update?; end
end

# This is the superclass for one to one relations and defines the common
# behavior or those proxies.
#
# source://mongoid//lib/mongoid/association/one.rb#9
class Mongoid::Association::One < ::Mongoid::Association::Proxy
  # Evolve the proxy document into an object id.
  #
  # @example Evolve the proxy document.
  #   proxy.__evolve_object_id__
  # @return [Object] The proxy document's id.
  #
  # source://mongoid//lib/mongoid/association/one.rb#49
  def __evolve_object_id__; end

  # Clear this relation - same as calling #delete on the document.
  #
  # @example Clear the relation.
  #   relation.clear
  # @return [true | false] If the delete succeeded.
  #
  # source://mongoid//lib/mongoid/association/one.rb#17
  def clear; end

  # Get all the documents in the relation that are loaded into memory.
  #
  # @example Get the in memory documents.
  #   relation.in_memory
  # @return [Array<Document>] The documents in memory.
  #
  # source://mongoid//lib/mongoid/association/one.rb#27
  def in_memory; end

  # Since method_missing is overridden we should override this as well.
  #
  # @example Does the proxy respond to the method?
  #   relation.respond_to?(:name)
  # @param name [Symbol] The method name.
  # @return [true | false] If the proxy responds to the method.
  #
  # source://mongoid//lib/mongoid/association/one.rb#39
  def respond_to?(name, include_private = T.unsafe(nil)); end
end

# Options context used for all association types.
#
# source://mongoid//lib/mongoid/association/options.rb#8
module Mongoid::Association::Options
  # Returns the name of the parent to a polymorphic child.
  #
  # @return [String | Symbol] The name.
  #
  # source://mongoid//lib/mongoid/association/options.rb#13
  def as; end

  # Whether the association is autobuilding.
  #
  # @return [true | false]
  #
  # source://mongoid//lib/mongoid/association/options.rb#41
  def autobuilding?; end

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # @return [true | false] The autosave option.
  #
  # source://mongoid//lib/mongoid/association/options.rb#71
  def autosave; end

  # Options to save any loaded members and destroy members that are marked for destruction
  # when the parent object is saved.
  #
  # @return [true | false] The autosave option.
  #
  # source://mongoid//lib/mongoid/association/options.rb#74
  def autosave?; end

  # Whether the association has callbacks cascaded down from the parent.
  #
  # @return [true | false] Whether callbacks are cascaded.
  #
  # source://mongoid//lib/mongoid/association/options.rb#91
  def cascading_callbacks?; end

  # Whether the association is counter-cached.
  #
  # @return [true | false]
  #
  # source://mongoid//lib/mongoid/association/options.rb#79
  def counter_cached?; end

  # Is the association cyclic.
  #
  # @return [true | false] Whether the association is cyclic.
  #
  # source://mongoid//lib/mongoid/association/options.rb#48
  def cyclic?; end

  # Specify what happens to the associated object when the owner is destroyed.
  #
  # @return [String] The dependent option.
  #
  # source://mongoid//lib/mongoid/association/options.rb#20
  def dependent; end

  # Whether the association has forced nil inverse (So no foreign keys are saved).
  #
  # @return [false] Default is false.
  #
  # source://mongoid//lib/mongoid/association/options.rb#103
  def forced_nil_inverse?; end

  # Whether to index the primary or foreign key field.
  #
  # @return [true | false]
  #
  # source://mongoid//lib/mongoid/association/options.rb#34
  def indexed?; end

  # The name the owning object uses to refer to this association.
  #
  # @return [String] The inverse_of option.
  #
  # source://mongoid//lib/mongoid/association/options.rb#55
  def inverse_of; end

  # The custom sorting options on the association.
  #
  # @return [Criteria::Queryable::Key] The custom sorting options.
  #
  # source://mongoid//lib/mongoid/association/options.rb#27
  def order; end

  # Whether this association is polymorphic.
  #
  # @return [true | false] Whether the association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/options.rb#86
  def polymorphic?; end

  # Mongoid assumes that the field used to hold the primary key of the association is id.
  # You can override this and explicitly specify the primary key with the :primary_key option.
  #
  # @return [Symbol | String] The primary key.
  #
  # source://mongoid//lib/mongoid/association/options.rb#63
  def primary_key; end

  # The store_as option.
  #
  # @return [nil] Default is nil.
  #
  # source://mongoid//lib/mongoid/association/options.rb#98
  def store_as; end

  # The field for saving the associated object's type.
  #
  # @return [nil] Default is nil.
  #
  # source://mongoid//lib/mongoid/association/options.rb#113
  def touch_field; end

  # Whether the association object should be automatically touched
  # when its inverse object is updated.
  #
  # @api private
  # @return [true | false] returns true if this association is
  #   automatically touched, false otherwise. The default is false.
  #
  # source://mongoid//lib/mongoid/association/options.rb#124
  def touchable?; end

  # The field for saving the associated object's type.
  #
  # @return [nil] Default is nil.
  #
  # source://mongoid//lib/mongoid/association/options.rb#108
  def type; end
end

# This class is the superclass for all association proxy objects, and contains
# common behavior for all of them.
#
# source://mongoid//lib/mongoid/association/proxy.rb#9
class Mongoid::Association::Proxy
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Marshalable
  extend ::Forwardable
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods

  # Sets the target and the association metadata properties.
  #
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The base document on the proxy.
  # @param target [Document | Array<Document>] The target of the proxy.
  # @return [Proxy] a new instance of Proxy
  # @yield [_self]
  # @yieldparam _self [Mongoid::Association::Proxy] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#60
  def initialize(base, target, association); end

  # Returns the value of attribute _association.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#41
  def _association; end

  # Sets the attribute _association
  #
  # @param value the value to set the attribute _association to.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#41
  def _association=(_arg0); end

  # Model instance for the base of the association.
  #
  # For example, if a Post embeds_many Comments, _base is a particular
  # instance of the Post model.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#39
  def _base; end

  # Model instance for the base of the association.
  #
  # For example, if a Post embeds_many Comments, _base is a particular
  # instance of the Post model.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#39
  def _base=(_arg0); end

  # Model instance for one to one associations, or array of model instances
  # for one to many associations, for the target of the association.
  #
  # For example, if a Post embeds_many Comments, _target is an array of
  # Comment models embedded in a particular Post.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#48
  def _target; end

  # Model instance for one to one associations, or array of model instances
  # for one to many associations, for the target of the association.
  #
  # For example, if a Post embeds_many Comments, _target is an array of
  # Comment models embedded in a particular Post.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#48
  def _target=(_arg0); end

  # source://mongoid//lib/mongoid/association/proxy.rb#52
  def bind_one(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/proxy.rb#53
  def collection_name(*_arg0, **_arg1, &_arg2); end

  # Allow extension to be an array and extend each module
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#67
  def extend_proxies(*extension); end

  # source://mongoid//lib/mongoid/association/proxy.rb#12
  def extend_proxy(*_arg0); end

  # source://mongoid//lib/mongoid/association/proxy.rb#51
  def foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/proxy.rb#51
  def inverse_foreign_key(*_arg0, **_arg1, &_arg2); end

  # Get the class from the association, or return nil if no association present.
  #
  # @example Get the class.
  #   proxy.klass
  # @return [Class] The association class.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#77
  def klass; end

  # Resets the criteria inside the association proxy. Used by many to many
  # associations to keep the underlying ids array in sync.
  #
  # @example Reset the association criteria.
  #   person.preferences.reset_relation_criteria
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#86
  def reset_unloaded; end

  # The default substitutable object for an association proxy is the clone of
  # the target.
  #
  # @example Get the substitutable.
  #   proxy.substitutable
  # @return [Object] A clone of the target.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#97
  def substitutable; end

  # source://mongoid//lib/mongoid/association/proxy.rb#52
  def unbind_one(*_arg0, **_arg1, &_arg2); end

  protected

  # Takes the supplied document and sets the association on it.
  #
  # @example Set the association metadata.
  #   proxt.characterize_one(name)
  # @param document [Document] The document to set on.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#120
  def characterize_one(document); end

  # Get the collection from the root of the hierarchy.
  #
  # @example Get the collection.
  #   relation.collection
  # @return [Collection] The root's collection.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#109
  def collection; end

  # Executes a callback method
  #
  # @example execute the before add callback
  #   execute_callback(:before_add)
  # @param callback [Symbol] to be executed
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#174
  def execute_callback(callback, doc); end

  # Execute the before and after callbacks for the given method.
  #
  # @param name [Symbol] The name of the callbacks to execute.
  # @return [Object] The result of the given block
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#189
  def execute_callbacks_around(name, doc); end

  # source://mongoid//lib/mongoid/association/proxy.rb#130
  def method_missing(name, *args, **_arg2, &block); end

  # When the base document illegally references an embedded document this
  # error will get raised.
  #
  # @example Raise the error.
  #   relation.raise_mixed
  # @raise [Errors::MixedRelations] The error.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#151
  def raise_mixed; end

  # When the base is not yet saved and the user calls create or create!
  # on the association, this error will get raised.
  #
  # @example Raise the error.
  #   relation.raise_unsaved(post)
  # @param doc [Document] The child document getting created.
  # @raise [Errors::UnsavedDocument] The error.
  #
  # source://mongoid//lib/mongoid/association/proxy.rb#164
  def raise_unsaved(doc); end

  private

  # source://mongoid//lib/mongoid/association/proxy.rb#140
  def respond_to_missing?(name, *args, **_arg2); end

  class << self
    # Apply ordering to the criteria if it was defined on the association.
    #
    # @example Apply the ordering.
    #   Proxy.apply_ordering(criteria, association)
    # @param association [Mongoid::Association::Relatable] The association metadata.
    # @param criteria [Criteria] The criteria to modify.
    # @return [Criteria] The ordered criteria.
    #
    # source://mongoid//lib/mongoid/association/proxy.rb#206
    def apply_ordering(criteria, association); end
  end
end

# specific methods to prevent from being undefined
#
# source://mongoid//lib/mongoid/association/proxy.rb#15
Mongoid::Association::Proxy::KEEPER_METHODS = T.let(T.unsafe(nil), Array)

# source://mongoid//lib/mongoid/association/referenced/auto_save.rb#6
module Mongoid::Association::Referenced; end

# Mixin module included into Mongoid::Document which adds
# the ability to automatically save opposite-side documents
# in referenced associations when saving the subject document.
#
# source://mongoid//lib/mongoid/association/referenced/auto_save.rb#11
module Mongoid::Association::Referenced::AutoSave
  extend ::ActiveSupport::Concern

  # Begin the associated autosave.
  #
  # @example Begin autosave.
  #   document.__autosaving__
  #
  # source://mongoid//lib/mongoid/association/referenced/auto_save.rb#28
  def __autosaving__; end

  # Used to prevent infinite loops in associated autosaves.
  #
  # @example Is the document autosaved?
  #   document.autosaved?
  # @return [true | false] Has the document already been autosaved?
  #
  # source://mongoid//lib/mongoid/association/referenced/auto_save.rb#20
  def autosaved?; end

  # Check if there is changes for auto-saving
  #
  #   document.changed_for_autosave?
  #
  # @example Return true if there is changes on self or in
  #   autosaved associations.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/auto_save.rb#40
  def changed_for_autosave?(doc); end

  class << self
    # Define the autosave method on an association's owning class for
    # an associated object.
    #
    # @example Define the autosave method:
    #   Association::Referenced::Autosave.define_autosave!(association)
    # @param association [Mongoid::Association::Relatable] The association for which autosaving is enabled.
    # @return [Class] The association's owner class.
    #
    # source://mongoid//lib/mongoid/association/referenced/auto_save.rb#53
    def define_autosave!(association); end
  end
end

# The BelongsTo type association.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to/binding.rb#7
class Mongoid::Association::Referenced::BelongsTo
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::BelongsTo::Buildable

  # Is this association type embedded?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#77
  def embedded?; end

  # Get the foreign key field for saving the association reference.
  #
  # @return [String] The foreign key field for saving the association reference.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#87
  def foreign_key; end

  # The name of the field used to store the type of polymorphic association.
  #
  # @return [String] The field used to store the type of polymorphic association.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#124
  def inverse_type; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::One] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#134
  def nested_builder(attributes, options); end

  # Get the path calculator for the supplied document.
  #
  # @example Get the path calculator.
  #   association.path(document)
  # @param document [Document] The document to calculate on.
  # @return [Root] The root atomic path calculator.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#146
  def path(document); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#102
  def polymorphic?; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::BelongsTo::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#95
  def relation; end

  # The list of association complements.
  #
  # @return [Array<Mongoid::Association::Relatable>] The association complements.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#56
  def relation_complements; end

  # Returns the object responsible for converting polymorphic type references into
  # class objects, and vice versa. This is obtained via the `:polymorphic` option
  # that was given when the association was defined.
  #
  # See Mongoid::ModelResolver.resolver for how the `:polymorphic` option is
  # interpreted here.
  #
  # @raise KeyError if no such resolver has been registered under the given
  #   identifier.
  # @return [nil | Mongoid::ModelResolver] the resolver to use
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#117
  def resolver; end

  # Get the scope to be applied when querying the association.
  #
  # @return [Proc | Symbol | nil] The association scope, if any.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#153
  def scope; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#63
  def setup!; end

  # Does this association type store the foreign key?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#72
  def stores_foreign_key?; end

  # The default for validation the association object.
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#82
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#229
  def create_foreign_key_field!; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#188
  def default_foreign_key_field; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#184
  def default_primary_key; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#210
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#176
  def index_spec; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#192
  def polymorph!; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#199
  def polymorphic_inverses(other = T.unsafe(nil)); end

  # If set to true, then the associated object will be validated when this object is saved
  #
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#223
  def require_association?; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#159
  def setup_instance_methods!; end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#22
Mongoid::Association::Referenced::BelongsTo::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for belongs_to associations.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to/binding.rb#10
class Mongoid::Association::Referenced::BelongsTo::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association on the inverse object as well as the
  # document itself.
  #
  # @example Bind the documents.
  #   game.person.bind(:continue => true)
  #   game.person = Person.new
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/binding.rb#22
  def bind_one; end

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # @example Unbind the document.
  #   game.person.unbind(:continue => true)
  #   game.person = nil
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/binding.rb#52
  def unbind_one; end

  private

  # Check for problems with multiple inverse definitions.
  #
  # @api private
  # @example Check for inverses errors.
  #   binding.check_inverses!(doc)
  # @param doc [Document] The document to check.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/binding.rb#78
  def check_polymorphic_inverses!(doc); end
end

# The Builder behavior for belongs_to associations.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to/buildable.rb#10
module Mongoid::Association::Referenced::BelongsTo::Buildable
  # This method either takes an _id or an object and queries for the
  # inverse side using the id or sets the object.
  #
  # @example Build the document.
  #   relation.build(meta, attrs)
  # @param base [Object] The base object.
  # @param object [Object] The object to use to build the association.
  # @param selected_fields [nil] Must be nil.
  # @param type [String] The type of the association.
  # @return [Document] A single document.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/buildable.rb#24
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/association/referenced/belongs_to/buildable.rb#31
  def execute_query(object, type); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/buildable.rb#42
  def query?(object); end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to/buildable.rb#35
  def query_criteria(object, type); end
end

# Eager class for belongs_to associations.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#10
class Mongoid::Association::Referenced::BelongsTo::Eager < ::Mongoid::Association::Eager
  private

  # Retrieves the documents referenced by the association, and
  # yields each one sequentially to the provided block. If the
  # association is not polymorphic, all documents are retrieved in
  # a single query. If the association is polymorphic, one query is
  # issued per association target class.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#30
  def each_loaded_document(&block); end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#63
  def group_by_key; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#67
  def key; end

  # Returns a map from association target class name to foreign key
  # values for the documents of that association target class,
  # as referenced by this association.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#43
  def keys_by_type_from_docs; end

  # source://mongoid//lib/mongoid/association/referenced/belongs_to/eager.rb#14
  def preload; end
end

# The type of the field holding the foreign key.
#
# @return [Object]
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#46
Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_FIELD_TYPE = Object

# The default foreign key suffix.
#
# @return [String] '_id'
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#51
Mongoid::Association::Referenced::BelongsTo::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

# Transparent proxy for belong_to associations.
# An instance of this class is returned when calling the
# association getter method on the subject document.
# This class inherits from Mongoid::Association::Proxy and
# forwards most of its methods to the target of the association,
# i.e. the document on the opposite-side collection which must
# be loaded.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#14
class Mongoid::Association::Referenced::BelongsTo::Proxy < ::Mongoid::Association::One
  include ::Mongoid::Evolvable

  # Instantiate a new belongs_to association proxy.
  #
  # @example Create the new proxy.
  #   Association::BelongsTo::Proxy.new(game, person, association)
  # @param association [Mongoid::Association::Relatable] The association object.
  # @param base [Document] The document this association hangs off of.
  # @param target [Document | Array<Document>] The target (parent) of the
  #   association.
  # @return [Proxy] a new instance of Proxy
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#26
  def initialize(base, target, association); end

  # Removes the association between the base document and the target
  # document by deleting the foreign key and the reference, orphaning
  # the target document in the process.
  #
  # @example Nullify the association.
  #   person.game.nullify
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#39
  def nullify; end

  # Substitutes the supplied target documents for the existing document
  # in the association.
  #
  # @example Substitute the association.
  #   name.substitute(new_name)
  # @param replacement [Document | Array<Document>] The replacement.
  # @return [self | nil] The association or nil.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#53
  def substitute(replacement); end

  private

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding object.
  #   binding([ address ])
  # @return [Binding] The binding object.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#70
  def binding; end

  # Normalize the value provided as a replacement for substitution.
  #
  # @api private
  # @example Normalize the substitute.
  #   proxy.normalize(id)
  # @param replacement [Document | Object] The replacement object.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#84
  def normalize(replacement); end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#96
  def persistable?; end

  class << self
    # Get the Eager object for this type of association.
    #
    # @example Get the eager loader object
    # @param association [Mongoid::Association::Relatable] The association object.
    # @param docs [Array<Document>] The array of documents.
    # @return [Mongoid::Association::Referenced::BelongsTo::Eager] The eager loader.
    #
    # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#110
    def eager_loader(association, docs); end

    # Returns true if the association is an embedded one. In this case
    # always false.
    #
    # @example Is this association embedded?
    #   Association::BelongsTo::Proxy.embedded?
    # @return [false] Always false.
    #
    # source://mongoid//lib/mongoid/association/referenced/belongs_to/proxy.rb#121
    def embedded?; end
  end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/referenced/belongs_to.rb#41
Mongoid::Association::Referenced::BelongsTo::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# Mixin module included into Mongoid::Document which adds
# the ability to cache the count of opposite-side documents
# in referenced n-to-many associations.
#
# source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#11
module Mongoid::Association::Referenced::CounterCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods

  # Reset the given counter using the .count() query from the
  # db. This method is useful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # @example Reset the given counter cache
  #   post.reset_counters(:comments)
  # @param *counters [Symbol...] One or more counter caches to reset.
  #
  # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#22
  def reset_counters(*counters); end

  class << self
    # Add the callbacks responsible for update the counter cache field.
    #
    # @api private
    # @example Add the touchable.
    #   Mongoid::Association::Referenced::CounterCache.define_callbacks!(association)
    # @param association [Mongoid::Association::Relatable] The association.
    # @return [Class] The association's owning class.
    #
    # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#99
    def define_callbacks!(association); end
  end
end

# source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#28
module Mongoid::Association::Referenced::CounterCache::ClassMethods
  # Decrement the counter name from the entries that match the
  # id by one. This method is used on associations callbacks
  # when counter_cache is enabled
  #
  # @example Decrement comments counter
  #   Post.decrement_counter(:comments_count, '50e0edd97c71c17ea9000001')
  # @param counter_name [Symbol] Counter cache name
  # @param id [String] The id of the object that will have its counter decremented.
  #
  # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#84
  def decrement_counter(counter_name, id); end

  # Increment the counter name from the entries that match the
  # id by one. This method is used on associations callbacks
  # when counter_cache is enabled
  #
  # @example Increment comments counter
  #   Post.increment_counter(:comments_count, '50e0edd97c71c17ea9000001')
  # @param counter_name [Symbol] Counter cache name
  # @param id [String] The id of the object that will have its counter incremented.
  #
  # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#71
  def increment_counter(counter_name, id); end

  # Reset the given counter using the .count() query from the
  # db. This method is useful in case that a counter got
  # corrupted, or a new counter was added to the collection.
  #
  # @example Reset the given counter cache
  #   Post.reset_counters('50e0edd97c71c17ea9000001', :comments)
  # @param *counters [Symbol...] One or more counter caches to reset.
  # @param id [String] The id of the object that will be reset.
  #
  # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#39
  def reset_counters(id, *counters); end

  # Update the given counters by the value factor. It uses the
  # atomic $inc command.
  #
  # @example Add 5 to comments counter and remove 2 from likes
  #   counter.
  #   Post.update_counters('50e0edd97c71c17ea9000001',
  #   :comments_count => 5, :likes_count => -2)
  # @param counters [Hash]
  # @param id [String] The id of the object to update.
  #
  # source://mongoid//lib/mongoid/association/referenced/counter_cache.rb#58
  def update_counters(id, counters); end
end

# The HasAndBelongsToMany type association.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#7
class Mongoid::Association::Referenced::HasAndBelongsToMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # @param doc [Document] The document to be bound.
  # @return [true | false] Whether the document can be bound.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#136
  def bindable?(doc); end

  # The criteria used for querying this association.
  #
  # @return [Mongoid::Criteria] The criteria used for querying this association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#110
  def criteria(base, id_list = T.unsafe(nil)); end

  # Is this association type embedded?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#73
  def embedded?; end

  # Are ids only saved on this side of the association?
  #
  # @return [true | false] Whether this association has a forced nil inverse.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#83
  def forced_nil_inverse?; end

  # Get the foreign key field for saving the association reference.
  #
  # @return [String] The foreign key field for saving the association reference.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#102
  def foreign_key; end

  # Get the foreign key field on the inverse.
  #
  # @return [String] The foreign key field for saving the association reference
  #   on the inverse side.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#118
  def inverse_foreign_key; end

  # Get the foreign key setter on the inverse.
  #
  # @return [String] The foreign key setter for saving the association reference
  #   on the inverse side.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#144
  def inverse_foreign_key_setter; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::One] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#154
  def nested_builder(attributes, options); end

  # Get the path calculator for the supplied document.
  #
  # @example Get the path calculator.
  #   association.path(document)
  # @param document [Document] The document to calculate on.
  # @return [Root] The root atomic path calculator.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#166
  def path(document); end

  # Get the association proxy class for this association type.
  #
  # @return [Association::HasAndBelongsToMany::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#95
  def relation; end

  # The list of association complements.
  #
  # @return [Array<Mongoid::Association::Relatable>] The association complements.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#58
  def relation_complements; end

  # Get the scope to be applied when querying the association.
  #
  # @return [Proc | Symbol | nil] The association scope, if any.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#173
  def scope; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#65
  def setup!; end

  # Does this association type store the foreign key?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#90
  def stores_foreign_key?; end

  # The default for validation the association object.
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#78
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#233
  def create_foreign_key_field!; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#201
  def default_foreign_key_field; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#197
  def default_primary_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#245
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#193
  def index_spec; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#265
  def query_criteria(id_list); end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#179
  def setup_instance_methods!; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#205
  def setup_syncing!; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#212
  def synced_destroy; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#222
  def synced_save; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#257
  def with_ordering(criteria); end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#22
Mongoid::Association::Referenced::HasAndBelongsToMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for all has_and_belongs_to_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#10
class Mongoid::Association::Referenced::HasAndBelongsToMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # @example Bind one document.
  #   person.preferences.bind_one(preference)
  # @param doc [Document] The single document to bind.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#20
  def bind_one(doc); end

  # Find the inverse association given a document.
  #
  # @param doc [Mongoid::Document] The document for which
  #   to determine the inverse association.
  # @return [Mongoid::Association::Relatable] The inverse association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#77
  def determine_inverse_association(doc); end

  # Find the inverse id referenced by inverse_keys
  #
  # @param doc [Mongoid::Document] The document for which
  #   to determine the inverse id.
  # @return [BSON::ObjectId] The inverse id.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#58
  def inverse_record_id(doc); end

  # Unbind a single document.
  #
  # @example Unbind the document.
  #   person.preferences.unbind_one(document)
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/binding.rb#39
  def unbind_one(doc); end
end

# The Builder behavior for has_and_belongs_to_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/buildable.rb#10
module Mongoid::Association::Referenced::HasAndBelongsToMany::Buildable
  # This builder either takes a hash and queries for the
  # object or an array of documents, where it will just return them.
  #
  # @example Build the documents.
  #   relation.build(association, attrs)
  # @param base [Object] The base object.
  # @param object [Object] The object to use to build the association.
  # @param selected_fields [nil] Must be nil.
  # @param type [String] Not used in this context.
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/buildable.rb#24
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/buildable.rb#34
  def query?(object); end
end

# Eager class for has_and_belongs_to_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#10
class Mongoid::Association::Referenced::HasAndBelongsToMany::Eager < ::Mongoid::Association::Eager
  private

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#43
  def group_by_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#47
  def key; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#31
  def keys_from_docs; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#14
  def preload; end

  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/eager.rb#39
  def set_relation(doc, element); end
end

# The type of the field holding the foreign key.
#
# @return [Array]
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#48
Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_FIELD_TYPE = Array

# The default foreign key suffix.
#
# @return [String] '_ids'
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#53
Mongoid::Association::Referenced::HasAndBelongsToMany::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

# Transparent proxy for has_and_belongs_to_many associations.
# An instance of this class is returned when calling
# the association getter method on the subject document.
# This class inherits from Mongoid::Association::Proxy and
# forwards most of its methods to the target of the association,
# i.e. the array of documents on the opposite-side collection
# which must be loaded.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#14
class Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy < ::Mongoid::Association::Referenced::HasMany::Proxy
  extend ::Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy::ClassMethods

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.posts << post
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @example Push a document.
  #   person.posts.push(post)
  # @param *args [Document...] Any number of documents.
  # @return [Array<Document>] The loaded docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#56
  def <<(*args); end

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # @example Build a new document on the association.
  #   person.posts.build(:title => "A new post")
  # @param attributes [Hash] The attributes of the new document.
  # @param type [Class] The optional subclass to build.
  # @return [Document] The new document.
  # @yield [doc]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#120
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.preferences.nullify
  # @param replacement [Array<Document>] The replacement documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#173
  def clear(replacement = T.unsafe(nil)); end

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @param documents [Array<Document>] The docs to add.
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#102
  def concat(documents); end

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  #
  # @example Delete the document.
  #   person.posts.delete(post)
  # @param document [Document] The document to remove.
  # @return [Document] The matching document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#143
  def delete(document); end

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  # Mongoid::Extensions::Array defines Array#delete_one, so we need
  # to make sure that method behaves reasonably on proxies, too.
  #
  # @example Delete the document.
  #   person.posts.delete(post)
  # @param document [Document] The document to remove.
  # @return [Document] The matching document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#155
  def delete_one(document); end

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # @example Build a new document on the association.
  #   person.posts.build(:title => "A new post")
  # @param attributes [Hash] The attributes of the new document.
  # @param type [Class] The optional subclass to build.
  # @return [Document] The new document.
  # @yield [doc]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#131
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.preferences.nullify
  # @param replacement [Array<Document>] The replacement documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#165
  def nullify(replacement = T.unsafe(nil)); end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.preferences.nullify
  # @param replacement [Array<Document>] The replacement documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#172
  def nullify_all(replacement = T.unsafe(nil)); end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.preferences.nullify
  # @param replacement [Array<Document>] The replacement documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#174
  def purge(replacement = T.unsafe(nil)); end

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.posts << post
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @example Push a document.
  #   person.posts.push(post)
  # @param *args [Document...] Any number of documents.
  # @return [Array<Document>] The loaded docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#91
  def push(*args); end

  # Substitutes the supplied target documents for the existing documents
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # person.preferences.substitute([ new_post ])
  #
  # @example Replace the association.
  # @param replacement [Array<Document>] The replacement target.
  # @return [Many] The association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#186
  def substitute(replacement); end

  # Get a criteria for the documents without the default scoping
  # applied.
  #
  # @example Get the unscoped criteria.
  #   person.preferences.unscoped
  # @return [Criteria] The unscoped criteria.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#204
  def unscoped; end

  private

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # @example Append the document to the association.
  #   relation.append(document)
  # @param document [Document] The document to append to the target.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#240
  def append(document); end

  # Processes a single document as part of a ``concat`` command.
  #
  # @param doc [Mongoid::Document] the document to append
  # @param docs [Array] the list of new docs to be inserted later,
  #   in bulk
  # @param ids [Hash] the mapping of primary keys that have been
  #   visited
  # @param inserts [Array] the list of Hashes of attributes that will
  #   be inserted (corresponding to the ``docs`` list)
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#360
  def append_document(doc, ids, docs, inserts); end

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding.
  #   relation.binding([ address ])
  # @return [Binding] The binding.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#255
  def binding; end

  # Determine if the child document should be persisted.
  #
  # @api private
  # @example Is the child persistable?
  #   relation.child_persistable?(doc)
  # @param doc [Document] The document.
  # @return [true | false] If the document can be persisted.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#269
  def child_persistable?(doc); end

  # Does the cleanup for the inverse of the association when
  # replacing the relation with another list of documents.
  #
  # @param replacement [Array<Document> | nil] the list of documents
  #   that will replace the current list.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#306
  def cleanup_inverse_for(replacement); end

  # Clears the foreign key from the changed_attributes hash.
  #
  # This is, in general, used to clear the foreign key from the
  # changed_attributes hash for consistency with the other referenced
  # associations.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#217
  def clear_foreign_key_changes; end

  # Clears the _target list and executes callbacks for each document.
  # If an exception occurs in an after_remove hook, the exception is
  # saved, the processing completes, and *then* the exception is
  # re-raised.
  #
  # @return [Array<Document>] the replacement documents
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#333
  def clear_target_for_nullify; end

  # Returns the criteria object for the target class with its documents set
  # to target.
  #
  # @example Get a criteria for the association.
  #   relation.criteria
  # @return [Criteria] A new criteria.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#281
  def criteria(id_list = T.unsafe(nil)); end

  # The inverse primary key
  #
  # @return [Object] the inverse primary key
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#319
  def inverse_primary_key; end

  # Reset the value in the changed_attributes hash for the foreign key
  # to its value before executing the given block.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#225
  def reset_foreign_key_changes; end

  # Flag the base as unsynced with respect to the foreign key.
  #
  # @api private
  # @example Flag as unsynced.
  #   relation.unsynced(doc, :preference_ids)
  # @param doc [Document] The document to flag.
  # @param key [Symbol] The key to flag on the document.
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#296
  def unsynced(doc, key); end
end

# class-level methods for HasAndBelongsToMany::Proxy
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#16
module Mongoid::Association::Referenced::HasAndBelongsToMany::Proxy::ClassMethods
  # Get the Eager object for this type of association.
  #
  # @example Get the eager loader object
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param docs [Array<Document>] The array of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#23
  def eager_loader(association, docs); end

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # @example Is this association embedded?
  #   Referenced::ManyToMany.embedded?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many/proxy.rb#34
  def embedded?; end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_and_belongs_to_many.rb#43
Mongoid::Association::Referenced::HasAndBelongsToMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# The has_many association.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/binding.rb#7
class Mongoid::Association::Referenced::HasMany
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::HasMany::Buildable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria

  # Add polymorphic query criteria to a Criteria object, if this association is
  #  polymorphic.
  #
  # It appears as if this method is an artifact left over from a refactoring that renamed it
  # `with_polymorphic_criterion`, and made it private. Regardless, this method isn't referenced
  # anywhere else, and is unlikely to be useful to external clients. We should remove it.
  #
  # @deprecated in 9.0.x
  # @param criteria [Mongoid::Criteria] The criteria object to add to.
  # @param object_class [Class] The object class.
  # @return [Mongoid::Criteria] The criteria object.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#142
  def add_polymorphic_criterion(*args, **_arg1, &block); end

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # @param doc [Document] The document to be bound.
  # @return [true | false] Whether the document can be bound.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#164
  def bindable?(doc); end

  # The criteria used for querying this association.
  #
  # @return [Mongoid::Criteria] The criteria used for querying this association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#116
  def criteria(base); end

  # Is this association type embedded?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#94
  def embedded?; end

  # Get the foreign key field on the inverse for saving the association reference.
  #
  # @return [String] The foreign key field on the inverse for saving the
  #   association reference.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#86
  def foreign_key; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::Many] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#174
  def nested_builder(attributes, options); end

  # Get the path calculator for the supplied document.
  #
  # @example Get the path calculator.
  #   Proxy.path(document)
  # @param document [Document] The document to calculate on.
  # @return [Root] The root atomic path calculator.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#186
  def path(document); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#154
  def polymorphic?; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::HasMany::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#109
  def relation; end

  # The list of association complements.
  #
  # @return [Array<Mongoid::Association::Relatable>] The association complements.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#53
  def relation_complements; end

  # Get the scope to be applied when querying the association.
  #
  # @return [Proc | Symbol | nil] The association scope, if any.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#193
  def scope; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#60
  def setup!; end

  # Setup the instance methods on the class having this association type.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#68
  def setup_instance_methods!; end

  # Does this association type store the foreign key?
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#104
  def stores_foreign_key?; end

  # The type of this association if it's polymorphic.
  #
  # @note Only relevant for polymorphic associations.
  # @return [String | nil] The type field.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#125
  def type; end

  # The default for validation the association object.
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#99
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#199
  def default_foreign_key_field; end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#220
  def default_primary_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#207
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#203
  def polymorphic_inverses(other); end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#224
  def query_criteria(object, base); end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#242
  def with_inverse_field_criterion(criteria); end

  # source://mongoid//lib/mongoid/association/referenced/has_many.rb#234
  def with_ordering(criteria); end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_many.rb#25
Mongoid::Association::Referenced::HasMany::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for has_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/binding.rb#10
class Mongoid::Association::Referenced::HasMany::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds a single document with the inverse association. Used
  # specifically when appending to the proxy.
  #
  # @example Bind one document.
  #   person.posts.bind_one(post)
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/binding.rb#18
  def bind_one(doc); end

  # Unbind a single document.
  #
  # @example Unbind the document.
  #   person.posts.unbind_one(document)
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/binding.rb#28
  def unbind_one(doc); end
end

# The Builder behavior for has_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/buildable.rb#10
module Mongoid::Association::Referenced::HasMany::Buildable
  # This method either takes an _id or an object and queries for the
  # inverse side using the id or sets the object.
  #
  # @example Build the document.
  #   relation.build(meta, attrs)
  # @param base [Object] The base object.
  # @param object [Object] The object to use to build the association.
  # @param selected_fields [nil] Must be nil.
  # @param type [String] The type of document to query for.
  # @return [Document] A single document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/buildable.rb#24
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/buildable.rb#32
  def query?(object); end
end

# Eager class for has_many associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/eager.rb#10
class Mongoid::Association::Referenced::HasMany::Eager < ::Mongoid::Association::Eager
  private

  # source://mongoid//lib/mongoid/association/referenced/has_many/eager.rb#34
  def group_by_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_many/eager.rb#38
  def key; end

  # source://mongoid//lib/mongoid/association/referenced/has_many/eager.rb#14
  def preload; end

  # source://mongoid//lib/mongoid/association/referenced/has_many/eager.rb#30
  def set_relation(doc, element); end
end

# This class is the wrapper for all referenced associations that have a
# target that can be a criteria or array of _loaded documents. This
# handles both cases or a combination of the two.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#14
class Mongoid::Association::Referenced::HasMany::Enumerable
  include ::Enumerable
  include ::Mongoid::Pluckable
  extend ::Forwardable

  # Initialize the new enumerable either with a criteria or an array.
  #
  # @example Initialize the enumerable with a criteria.
  #   Enumberable.new(Post.where(:person_id => id))
  # @example Initialize the enumerable with an array.
  #   Enumerable.new([ post ])
  # @param target [Criteria | Array<Document>] The wrapped object.
  # @return [Enumerable] a new instance of Enumerable
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#265
  def initialize(target, base = T.unsafe(nil), association = T.unsafe(nil)); end

  # Append a document to the enumerable.
  #
  # @example Append the document.
  #   enumerable << document
  # @param document [Document] The document to append.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#63
  def <<(document); end

  # Check if the enumerable is equal to the other object.
  #
  # @example Check equality.
  #   enumerable == []
  # @param other [Enumerable] The other enumerable.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#36
  def ==(other); end

  # Check equality of the enumerable against the provided object for
  # case statements.
  #
  # @example Check case equality.
  #   enumerable === Array
  # @param other [Object] The object to check.
  # @return [true | false] If the objects are equal in a case.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#50
  def ===(other); end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _added; end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _added=(_arg0); end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _loaded; end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _loaded=(_arg0); end

  # Has the enumerable been _loaded? This will be true if the criteria has
  # been executed or we manually load the entire thing.
  #
  # @example Is the enumerable _loaded?
  #   enumerable._loaded?
  # @return [true | false] If the enumerable has been _loaded.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#356
  def _loaded?; end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _unloaded; end

  # The three main instance variables are collections of documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#24
  def _unloaded=(_arg0); end

  # Returns whether the association has any documents, optionally
  # subject to the provided filters.
  #
  # This method returns true if the association has any persisted
  # documents and if it has any not yet persisted documents.
  #
  # If the association is already loaded, this method inspects the
  # loaded documents and does not query the database. If the
  # association is not loaded, the argument-less and block-less
  # version does not load the association; the other versions
  # (that delegate to Enumerable) may or may not load the association
  # completely depending on whether it is iterated to completion.
  #
  # This method can take a parameter and a block. The behavior with
  # either the parameter or the block is delegated to the standard
  # library Enumerable module.
  #
  # Note that when Enumerable's any? method is invoked with both
  # a block and a pattern, it only uses the pattern.
  #
  # @param *args [Object...] The condition that documents
  #   must satisfy. See Enumerable documentation for details.
  # @return [true | false] If the association has any documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#228
  def any?(*args); end

  # Send #as_json to the entries, without encoding.
  #
  # @example Get the enumerable as json.
  #   enumerable.as_json
  # @param options [Hash] Optional parameters.
  # @return [Hash] The entries all _loaded as a hash.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#509
  def as_json(options = T.unsafe(nil)); end

  # Clears out all the documents in this enumerable. If passed a block it
  # will yield to each document that is in memory.
  #
  # @example Clear out the enumerable with a block.
  #   enumerable.clear do |doc|
  #   doc.unbind
  #   end
  # @example Clear out the enumerable.
  #   enumerable.clear
  # @return [Array<Document>] The cleared out _added docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#82
  def clear; end

  # Clones each document in the enumerable.
  #
  # @example Clone the enumerable.
  #   enumerable.clone
  # @note This loads all documents into memory.
  # @return [Array<Document>] An array clone of the enumerable.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#97
  def clone; end

  # Delete the supplied document from the enumerable.
  #
  # @example Delete the document.
  #   enumerable.delete(document)
  # @param document [Document] The document to delete.
  # @return [Document] The deleted document.
  # @yield [doc]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#109
  def delete(document); end

  # Deletes every document in the enumerable for where the block returns
  # true.
  #
  # @example Delete all matching documents.
  #   enumerable.delete_if do |doc|
  #   dod._id == _id
  #   end
  # @note This operation loads all documents from the database.
  # @return [Array<Document>] The remaining docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#132
  def delete_if(&block); end

  # Iterating over this enumerable has to handle a few different
  # scenarios.
  #
  # If the enumerable has its criteria _loaded into memory then it yields
  # to all the _loaded docs and all the _added docs.
  #
  # If the enumerable has not _loaded the criteria then it iterates over
  # the cursor while loading the documents and then iterates over the
  # _added docs.
  #
  # If no block is passed then it returns an enumerator containing all
  # docs.
  #
  # @example Iterate over the enumerable.
  #   enumerable.each do |doc|
  #   puts doc
  #   end
  # @example return an enumerator containing all the docs
  #
  #   a = enumerable.each
  # @return [true] That the enumerable is now _loaded.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#165
  def each; end

  # Is the enumerable empty? Will determine if the count is zero based on
  # whether or not it is _loaded.
  #
  # @example Is the enumerable empty?
  #   enumerable.empty?
  # @return [true | false] If the enumerable is empty.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#196
  def empty?; end

  # Get the first document in the enumerable. Will check the persisted
  # documents first. Does not load the entire enumerable.
  #
  # @example Get the first document.
  #   enumerable.first
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first or #last,
  #   use #take instead.
  #   Be aware that #take won't guarantee order.
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first document found.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#249
  def first(limit = T.unsafe(nil)); end

  # Return all the documents in the enumerable that have been _loaded or
  # _added.
  #
  # @example Get the in memory docs.
  #   enumerable.in_memory
  # @note When passed a block it yields to each document.
  # @return [Array<Document>] The in memory docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#312
  def in_memory; end

  # Does the target include the provided document?
  #
  # @example Does the target include the document?
  #   enumerable.include?(document)
  # @param doc [Document] The document to check.
  # @return [true | false] If the document is in the target.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#287
  def include?(doc); end

  # Inspection will just inspect the entries for nice array-style
  # printing.
  #
  # @example Inspect the enumerable.
  #   enumerable.inspect
  # @return [String] The inspected enum.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#299
  def inspect; end

  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#26
  def is_a?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#26
  def kind_of?(*_arg0, **_arg1, &_arg2); end

  # Get the last document in the enumerable. Will check the new
  # documents first. Does not load the entire enumerable.
  #
  # @example Get the last document.
  #   enumerable.last
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first or #last,
  #   use #take instead.
  #   Be aware that #take won't guarantee order.
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The last document found.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#334
  def last(limit = T.unsafe(nil)); end

  # Gets the total size of this enumerable. This is a combination of all
  # the persisted and unpersisted documents.
  #
  # @example Get the size.
  #   enumerable.size
  # @return [Integer] The size of the enumerable.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#487
  def length; end

  # Loads all the documents in the enumerable from the database.
  #
  # @example Load all the documents.
  #   enumerable.load_all!
  # @return [true] That the enumerable is _loaded.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#347
  def load_all!(*_arg0); end

  # Provides the data needed to Marshal.dump an enumerable proxy.
  #
  # @example Dump the proxy.
  #   Marshal.dump(proxy)
  # @return [Array<Object>] The dumped data.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#366
  def marshal_dump; end

  # Loads the data needed to Marshal.load an enumerable proxy.
  #
  # @example Load the proxy.
  #   Marshal.load(proxy)
  # @return [Array<Object>] The dumped data.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#376
  def marshal_load(data); end

  # Plucks the given field names from the documents in the target.
  # If the collection has been loaded, it plucks from the loaded
  # documents; otherwise, it plucks from the unloaded criteria.
  # Regardless, it also plucks from any added documents.
  #
  # @param *fields [Symbol...] The field names to pluck.
  # @return [Array | Array<Array>] The array of field values. If
  #   multiple fields are given, an array of arrays is returned.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#389
  def pluck(*keys); end

  # Append a document to the enumerable.
  #
  # @example Append the document.
  #   enumerable << document
  # @param document [Document] The document to append.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#68
  def push(document); end

  # Reset the enumerable back to its persisted state.
  #
  # @example Reset the enumerable.
  #   enumerable.reset
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#423
  def reset; end

  # Resets the underlying unloaded criteria object with a new one. Used
  # my HABTM associations to keep the underlying array in sync.
  #
  # @example Reset the unloaded documents.
  #   enumerable.reset_unloaded(criteria)
  # @param criteria [Criteria] The criteria to replace with.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#436
  def reset_unloaded(criteria); end

  # Does this enumerable respond to the provided method?
  #
  # @example Does the enumerable respond to the method?
  #   enumerable.respond_to?(:sum)
  # @param include_private [true | false] Whether to include private
  #   methods.
  # @param name [String | Symbol] The name of the method.
  # @return [true | false] Whether the enumerable responds.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#450
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # Gets the total size of this enumerable. This is a combination of all
  # the persisted and unpersisted documents.
  #
  # @example Get the size.
  #   enumerable.size
  # @return [Integer] The size of the enumerable.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#461
  def size; end

  # Send #to_json to the entries.
  #
  # @example Get the enumerable as json.
  #   enumerable.to_json
  # @param options [Hash] Optional parameters.
  # @return [String] The entries all _loaded as a string.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#497
  def to_json(options = T.unsafe(nil)); end

  # Return all the unique documents in the enumerable.
  #
  # @example Get all the unique documents.
  #   enumerable.uniq
  # @note This operation loads all documents from the database.
  # @return [Array<Document>] The unique documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#521
  def uniq; end

  private

  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#533
  def method_missing(name, *args, **_arg2, &block); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#527
  def set_base(document); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#537
  def unloaded_documents; end

  # Checks whether conditions in the given hash are known to be
  # unsatisfiable, i.e. querying with this hash will always return no
  # documents.
  #
  # This method only handles condition shapes that Mongoid itself uses when
  # it builds association queries. Return value true indicates the condition
  # always produces an empty document set. Note however that return value false
  # is not a guarantee that the condition won't produce an empty document set.
  #
  # @example Conditions which are unsatisfiable that this method does not handle
  #   unsatisfiable_criteria?({'foo' => {'$in' => []}})
  #   # => false
  # @example Conditions which may be satisfiable
  #   unsatisfiable_criteria?({'_id' => '123'})
  #   # => false
  # @example Unsatisfiable conditions
  #   unsatisfiable_criteria?({'_id' => {'$in' => []}})
  #   # => true
  # @param selector [Hash] The conditions to check.
  # @return [true | false] Whether hash contains known unsatisfiable
  #   conditions.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/enumerable.rb#570
  def unsatisfiable_criteria?(selector); end
end

# The default foreign key suffix.
#
# @return [String] '_id'
#
# source://mongoid//lib/mongoid/association/referenced/has_many.rb#48
Mongoid::Association::Referenced::HasMany::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

# Transparent proxy for has_many associations.
# An instance of this class is returned when calling the
# association getter method on the subject document. This class
# inherits from Mongoid::Association::Proxy and forwards most of its
# methods to the target of the association, i.e. the array of
# documents on the opposite-side collection which must be loaded.
#
# source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#13
class Mongoid::Association::Referenced::HasMany::Proxy < ::Mongoid::Association::Many
  extend ::Mongoid::Association::Referenced::HasMany::Proxy::ClassMethods

  # Instantiate a new references_many association. Will set the foreign key
  # and the base on the inverse object.
  #
  # @example Create the new association.
  #   Referenced::Many.new(base, target, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The document this association hangs off of.
  # @param target [Array<Document>] The target of the association.
  # @return [Proxy] a new instance of Proxy
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#48
  def initialize(base, target, association); end

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.posts << post
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @example Push a document.
  #   person.posts.push(post)
  # @param *args [Document...] Any number of documents.
  # @return [Array<Document>] The loaded docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#70
  def <<(*args); end

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # @example Build a new document on the association.
  #   person.posts.build(:title => "A new post")
  # @param attributes [Hash] The attributes of the new document.
  # @param type [Class] The optional subclass to build.
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#115
  def build(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # Clear the association. Will delete the documents from the db if they are
  # already persisted.
  #
  # @example Clear the association.
  #   person.posts.clear
  # @return [Many] The association emptied.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#328
  def clear; end

  # Appends an array of documents to the association. Performs a batch
  # insert of the documents instead of persisting one at a time.
  #
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @param documents [Array<Document>] The docs to add.
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#92
  def concat(documents); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#36
  def count(*_arg0, **_arg1, &_arg2); end

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  #
  # @example Delete the document.
  #   person.posts.delete(post)
  # @param document [Document] The document to remove.
  # @return [Document] The matching document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#137
  def delete(document); end

  # Deletes all related documents from the database given the supplied
  # conditions.
  #
  # @example Conditonally delete all documents in the association.
  #   person.posts.delete_all({ :title => "Testing" })
  # @example Delete all documents in the association.
  #   person.posts.delete_all
  # @param conditions [Hash] Optional conditions to delete with.
  # @return [Integer] The number of documents deleted.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#166
  def delete_all(conditions = T.unsafe(nil)); end

  # Delete the document from the association. This will set the foreign key
  # on the document to nil. If the dependent options on the association are
  # :delete_all or :destroy the appropriate removal will occur.
  # Mongoid::Extensions::Array defines Array#delete_one, so we need
  # to make sure that method behaves reasonably on proxies, too.
  #
  # @example Delete the document.
  #   person.posts.delete(post)
  # @param document [Document] The document to remove.
  # @return [Document] The matching document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#152
  def delete_one(document); end

  # Destroys all related documents from the database given the supplied
  # conditions.
  #
  # @example Conditionally destroy all documents in the association.
  #   person.posts.destroy_all({ :title => "Testing" })
  # @example Destroy all documents in the association.
  #   person.posts.destroy_all
  # @param conditions [Hash] Optional conditions to destroy with.
  # @return [Integer] The number of documents destroyed.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#182
  def destroy_all(conditions = T.unsafe(nil)); end

  # Iterate over each document in the association and yield to the provided
  # block.
  #
  # @example Iterate over the documents.
  #   person.posts.each do |post|
  #   post.save
  #   end
  # @note This will load the entire association into memory.
  # @return [Array<Document>] The loaded docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#197
  def each(&block); end

  # Determine if any documents in this association exist in the database.
  #
  # If the association contains documents but all of the documents
  # exist only in the application, i.e. have not been persisted to the
  # database, this method returns false.
  #
  # This method queries the database on each invocation even if the
  # association is already loaded into memory.
  #
  # @example Are there persisted documents?
  #   person.posts.exists?
  # @param id_or_conditions [:none | nil | false | Hash | Object] When :none (the default), returns true if any persisted
  #   documents exist in the association. When nil or false, this
  #   will always return false. When a Hash is given, this queries
  #   the documents in the association for those that match the given
  #   conditions, and returns true if any match. Any other argument is
  #   interpreted as an id, and queries for the existence of documents
  #   in the association with a matching _id.
  # @return [true | false] True is persisted documents exist, false if not.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#227
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # Find the matching document on the association, either based on id or
  # conditions.
  #
  # This method delegates to +Mongoid::Criteria#find+. If this method is
  # not given a block, it returns one or many documents for the provided
  # _id values.
  #
  # If this method is given a block, it returns the first document
  # of those found by the current Criteria object for which the block
  # returns a truthy value.
  #
  # @example Find by an id.
  #   person.posts.find(BSON::ObjectId.new)
  # @example Find by multiple ids.
  #   person.posts.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
  # @example Finds the first matching document using a block.
  #   person.addresses.find { |addr| addr.state == 'CA' }
  # @note Each argument can be an individual id, an array of ids or
  #   a nested array. Each array will be flattened.
  # @note This will keep matching documents in memory for iteration
  #   later.
  # @param &block Optional block to pass.
  # @param *args [[ Object | Array<Object> ]...] The ids.
  # @return [Document | Array<Document> | nil] A document or matching documents.
  # @yield [Object] Yields each enumerable element to the block.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#262
  def find(*args, &block); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#37
  def first(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#37
  def in_memory(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#37
  def last(*_arg0, **_arg1, &_arg2); end

  # Build a new document from the attributes and append it to this
  # association without saving.
  #
  # @example Build a new document on the association.
  #   person.posts.build(:title => "A new post")
  # @param attributes [Hash] The attributes of the new document.
  # @param type [Class] The optional subclass to build.
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#125
  def new(attributes = T.unsafe(nil), type = T.unsafe(nil)); end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.posts.nullify
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#274
  def nullify; end

  # Removes all associations between the base document and the target
  # documents by deleting the foreign keys and the references, orphaning
  # the target documents in the process.
  #
  # @example Nullify the association.
  #   person.posts.nullify
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#282
  def nullify_all; end

  # Plucks the given field names from the documents in the
  # association. It is safe to use whether the association is
  # loaded or not, and whether there are unsaved documents in the
  # association or not.
  #
  # @example Pluck the titles of all posts.
  #   person.posts.pluck(:title)
  # @param *fields [Symbol...] The field names to pluck.
  # @return [Array | Array<Array>] The array of field values. If
  #   multiple fields are given, an array of arrays is returned.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#296
  def pluck(*fields); end

  # Clear the association. Will delete the documents from the db if they are
  # already persisted.
  #
  # @example Clear the association.
  #   person.posts.clear
  # @return [Many] The association emptied.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#307
  def purge; end

  # Appends a document or array of documents to the association. Will set
  # the parent and update the index in the process.
  #
  # @example Append a document.
  #   person.posts << post
  # @example Concat with other documents.
  #   person.posts.concat([ post_one, post_two ])
  # @example Push a document.
  #   person.posts.push(post)
  # @param *args [Document...] Any number of documents.
  # @return [Array<Document>] The loaded docs.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#81
  def push(*args); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#37
  def reset(*_arg0, **_arg1, &_arg2); end

  # Substitutes the supplied target documents for the existing documents
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # @example Replace the association.
  #   person.posts.substitute([ new_post ])
  # @param replacement [Array<Document>] The replacement target.
  # @return [Many] The association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#340
  def substitute(replacement); end

  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#37
  def uniq(*_arg0, **_arg1, &_arg2); end

  # Get a criteria for the documents without the default scoping
  # applied.
  #
  # @example Get the unscoped criteria.
  #   person.posts.unscoped
  # @return [Criteria] The unscoped criteria.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#362
  def unscoped; end

  private

  # Whether the document and the base already have a persisted association.
  #
  # @example Is the document already related to the base.
  #   relation.already_related?(document)
  # @param document [Document] The document to possibly append to the target.
  # @return [true | false] Whether the document is already related to the base and the
  #   association is persisted.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#407
  def already_related?(document); end

  # Appends the document to the target array, updating the index on the
  # document at the same time.
  #
  # @example Append the document to the association.
  #   relation.append(document)
  # @param document [Document] The document to append to the target.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#375
  def append(document); end

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding.
  #   relation.binding([ address ])
  # @return [Binding] The binding.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#420
  def binding; end

  # Perform the necessary cascade operations for documents that just got
  # deleted or nullified.
  #
  # @example Cascade the change.
  #   relation.cascade!(document)
  # @param document [Document] The document to cascade on.
  # @return [true | false] If the association is destructive.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#454
  def cascade!(document); end

  # Get the collection of the association in question.
  #
  # @example Get the collection of the association.
  #   relation.collection
  # @return [Collection] The collection of the association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#430
  def collection; end

  # Returns the criteria object for the target class with its documents set
  # to target.
  #
  # @example Get a criteria for the association.
  #   relation.criteria
  # @return [Criteria] A new criteria.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#441
  def criteria; end

  # If the target array does not respond to the supplied method then try to
  # find a named scope or criteria on the class and send the call there.
  #
  # If the method exists on the array, use the default proxy behavior.
  #
  # TODO: make sure we are consistingly using respond_to_missing
  #   anywhere we define method_missing.
  #
  # @param &block Optional block to pass.
  # @param *args [Object...] The method args
  # @param name [Symbol | String] The name of the method.
  # @return [Criteria | Object] A Criteria or return value from the target.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#481
  def method_missing(name, *args, **_arg2, &block); end

  # Persist all the delayed batch inserts.
  #
  # @api private
  # @example Persist the delayed batch inserts.
  #   relation.persist_delayed([ doc ])
  # @param docs [Array<Document>] The delayed inserts.
  # @param inserts [Array<Hash>] The raw insert document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#501
  def persist_delayed(docs, inserts); end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#518
  def persistable?; end

  # Deletes all related documents from the database given the supplied
  # conditions.
  #
  # @example Conditonally delete all documents in the association.
  #   person.posts.delete_all({ :title => "Testing" })
  # @example Delete all documents in the association.
  #   person.posts.delete_all
  # @param conditions [Hash] Optional conditions to delete with.
  # @param method [Symbol] The deletion method to call.
  # @return [Integer] The number of documents deleted.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#535
  def remove_all(conditions = T.unsafe(nil), method = T.unsafe(nil)); end

  # Remove all the documents in the proxy that do not have the provided
  # ids.
  #
  # @example Remove all documents without the ids.
  #   proxy.remove_not_in([ id ])
  # @param ids [Array<Object>] The ids.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#553
  def remove_not_in(ids); end

  # Save a persisted document immediately or delay a new document for
  # batch insert.
  #
  # @api private
  # @example Save or delay the document.
  #   relation.save_or_delay(doc, [])
  # @param doc [Document] The document.
  # @param inserts [Array<Document>] The inserts.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#590
  def save_or_delay(doc, docs, inserts); end

  # If the association is destructive, the matching documents will
  # be removed. Otherwise, their foreign keys will be set to nil.
  #
  # @param removed [Criteria] The criteria for the documents to
  #   remove.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#572
  def update_or_delete_all(removed); end

  # Execute before/after add callbacks around the block unless the objects
  # already have a persisted association.
  #
  # @example Execute before/after add callbacks around the block.
  #   relation.with_add_callbacks(document, false)
  # @param already_related [true | false] Whether the document is already related
  #   to the target.
  # @param document [Document] The document to append to the target.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#392
  def with_add_callbacks(document, already_related); end
end

# class-level methods for HasMany::Proxy
#
# source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#17
module Mongoid::Association::Referenced::HasMany::Proxy::ClassMethods
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#18
  def eager_loader(association, docs); end

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # @example Is this association embedded?
  #   Referenced::Many.embedded?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_many/proxy.rb#29
  def embedded?; end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_many.rb#43
Mongoid::Association::Referenced::HasMany::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# The has_one association.
#
# source://mongoid//lib/mongoid/association/referenced/has_one/binding.rb#7
class Mongoid::Association::Referenced::HasOne
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options
  include ::Mongoid::Association::Relatable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria
  include ::Mongoid::Association::Referenced::HasOne::Buildable

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # @param doc [Document] The document to be bound.
  # @return [true | false] Whether the document can be bound.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#116
  def bindable?(doc); end

  # Is this association type embedded?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#70
  def embedded?; end

  # Get the foreign key field for saving the association reference.
  #
  # @return [String] The foreign key field for saving the
  #   association reference.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#62
  def foreign_key; end

  # The nested builder object.
  #
  # @param attributes [Hash] The attributes to use to build the association object.
  # @param options [Hash] The options for the association.
  # @return [Association::Nested::Many] The Nested Builder object.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#90
  def nested_builder(attributes, options); end

  # Get the path calculator for the supplied document.
  #
  # @example Get the path calculator.
  #   Proxy.path(document)
  # @param document [Document] The document to calculate on.
  # @return [Root] The root atomic path calculator.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#133
  def path(document); end

  # Is this association polymorphic?
  #
  # @return [true | false] Whether this association is polymorphic.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#97
  def polymorphic?; end

  # Get the association proxy class for this association type.
  #
  # @return [Association::HasOne::Proxy] The proxy class.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#80
  def relation; end

  # The list of association complements.
  #
  # @return [Array<Mongoid::Association::Relatable>] The association complements.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#46
  def relation_complements; end

  # Get the scope to be applied when querying the association.
  #
  # @return [Proc | Symbol | nil] The association scope, if any.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#140
  def scope; end

  # Setup the instance methods, fields, etc. on the association owning class.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#53
  def setup!; end

  # Does this association type store the foreign key?
  #
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#123
  def stores_foreign_key?; end

  # The type of this association if it's polymorphic.
  #
  # @note Only relevant for polymorphic associations.
  # @return [String | nil] The type field.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#106
  def type; end

  # The default for validation the association object.
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#75
  def validation_default; end

  private

  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#162
  def default_foreign_key_field; end

  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#182
  def default_primary_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#170
  def determine_inverses(other); end

  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#166
  def polymorphic_inverses(other); end

  # Setup the instance methods on the class having this association type.
  #
  # @return [self]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one.rb#149
  def setup_instance_methods!; end
end

# The options available for this type of association, in addition to the
# common ones.
#
# @return [Array<Symbol>] The extra valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_one.rb#22
Mongoid::Association::Referenced::HasOne::ASSOCIATION_OPTIONS = T.let(T.unsafe(nil), Array)

# Binding class for has_one associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_one/binding.rb#10
class Mongoid::Association::Referenced::HasOne::Binding
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Association::Bindable

  # Binds the base object to the inverse of the association. This is so we
  # are referenced to the actual objects themselves on both sides.
  #
  # This case sets the association metadata on the inverse object as well as the
  # document itself.
  #
  # @example Bind the document.
  #   person.game.bind(:continue => true)
  #   person.game = Game.new
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/binding.rb#22
  def bind_one; end

  # Unbinds the base object and the inverse, caused by setting the
  # reference to nil.
  #
  # @example Unbind the document.
  #   person.game.unbind(:continue => true)
  #   person.game = nil
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/binding.rb#34
  def unbind_one; end
end

# The Builder behavior for has_one associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#12
module Mongoid::Association::Referenced::HasOne::Buildable
  include ::Mongoid::Association::Referenced::WithPolymorphicCriteria

  # This method either takes an _id or an object and queries for the
  # inverse side using the id or sets the object after clearing the
  # associated object.
  #
  # @param base [Object] The base object.
  # @param object [Object] The object to use to build the association.
  # @param selected_fields [nil] Must be nil.
  # @param type [String] The type of the association.
  # @return [Document] A single document.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#25
  def build(base, object, type = T.unsafe(nil), selected_fields = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#38
  def clear_associated(object); end

  # source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#59
  def execute_query(object, base); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#63
  def query?(object); end

  # source://mongoid//lib/mongoid/association/referenced/has_one/buildable.rb#52
  def query_criteria(object, base); end
end

# Eager class for has_one associations.
#
# source://mongoid//lib/mongoid/association/referenced/has_one/eager.rb#9
class Mongoid::Association::Referenced::HasOne::Eager < ::Mongoid::Association::Eager
  private

  # source://mongoid//lib/mongoid/association/referenced/has_one/eager.rb#24
  def group_by_key; end

  # source://mongoid//lib/mongoid/association/referenced/has_one/eager.rb#28
  def key; end

  # source://mongoid//lib/mongoid/association/referenced/has_one/eager.rb#13
  def preload; end
end

# The default foreign key suffix.
#
# @return [String] '_id'
#
# source://mongoid//lib/mongoid/association/referenced/has_one.rb#41
Mongoid::Association::Referenced::HasOne::FOREIGN_KEY_SUFFIX = T.let(T.unsafe(nil), String)

# Transparent proxy for has_one associations.
# An instance of this class is returned when calling the
# association getter method on the subject document. This class
# inherits from Mongoid::Association::Proxy and forwards most of
# its methods to the target of the association, i.e. the
# document on the opposite-side collection which must be loaded.
#
# source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#13
class Mongoid::Association::Referenced::HasOne::Proxy < ::Mongoid::Association::One
  extend ::Mongoid::Association::Referenced::HasOne::Proxy::ClassMethods

  # Instantiate a new references_one association. Will set the foreign key
  # and the base on the inverse object.
  #
  # @example Create the new association.
  #   Referenced::One.new(base, target, association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param base [Document] The document this association hangs off of.
  # @param target [Document] The target (child) of the association.
  # @return [Proxy] a new instance of Proxy
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#43
  def initialize(base, target, association); end

  # Removes the association between the base document and the target
  # document by deleting the foreign key and the reference, orphaning
  # the target document in the process.
  #
  # @example Nullify the association.
  #   person.game.nullify
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#58
  def nullify; end

  # Substitutes the supplied target document for the existing document
  # in the association. If the new target is nil, perform the necessary
  # deletion.
  #
  # @example Replace the association.
  #   person.game.substitute(new_game)
  # @param replacement [Array<Document>] The replacement target.
  # @return [One] The association.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#73
  def substitute(replacement); end

  private

  # Instantiate the binding associated with this association.
  #
  # @example Get the binding.
  #   relation.binding([ address ])
  # @return [Binding] The binding object.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#86
  def binding; end

  # Are we able to persist this association?
  #
  # @example Can we persist the association?
  #   relation.persistable?
  # @return [true | false] If the association is persistable.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#96
  def persistable?; end

  # Takes the necessary steps to prepare for the current document
  # to be replaced by a non-nil substitute.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#102
  def prepare_for_replacement; end
end

# class-level methods for the HasOne::Proxy
#
# source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#15
module Mongoid::Association::Referenced::HasOne::Proxy::ClassMethods
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#16
  def eager_loader(association, docs); end

  # Returns true if the association is an embedded one. In this case
  # always false.
  #
  # @example Is this association embedded?
  #   Referenced::One.embedded?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/association/referenced/has_one/proxy.rb#27
  def embedded?; end
end

# The complete list of valid options for this association, including
# the shared ones.
#
# @return [Array<Symbol>] The valid options.
#
# source://mongoid//lib/mongoid/association/referenced/has_one.rb#36
Mongoid::Association::Referenced::HasOne::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# This module handles the behavior for synchronizing foreign keys between
# both sides of a many to many associations.
#
# source://mongoid//lib/mongoid/association/referenced/syncable.rb#10
module Mongoid::Association::Referenced::Syncable
  # Is the document able to be synced on the inverse side? This is only if
  # the key has changed and the association bindings have not been run.
  #
  # @example Are the foreign keys syncable?
  #   document._syncable?(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [true | false] If we can sync.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#21
  def _syncable?(association); end

  # Get the synced foreign keys.
  #
  # @example Get the synced foreign keys.
  #   document._synced
  # @return [Hash] The synced foreign keys.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#31
  def _synced; end

  # Has the document been synced for the foreign key?
  #
  # @example Has the document been synced?
  #   document._synced?
  # @param foreign_key [String] The foreign key.
  # @return [true | false] If we can sync.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#43
  def _synced?(foreign_key); end

  # Update the inverse keys on destroy.
  #
  # @example Update the inverse keys.
  #   document.remove_inverse_keys(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [Object] The updated values.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#55
  def remove_inverse_keys(association); end

  # Update the inverse keys for the association.
  #
  # @example Update the inverse keys
  #   document.update_inverse_keys(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [Object] The updated values.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#70
  def update_inverse_keys(association); end
end

# source://mongoid//lib/mongoid/association/referenced/syncable.rb#95
module Mongoid::Association::Referenced::Syncable::ClassMethods
  # Set up the syncing of many to many foreign keys.
  #
  # @example Set up the syncing.
  #   Person._synced(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#103
  def _synced(association); end

  private

  # Set up the sync of inverse keys that needs to happen on a destroy.
  #
  # @example Set up the destroy syncing.
  #   Person.synced_destroy(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [Class] The class getting set up.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#143
  def synced_destroy(association); end

  # Set up the sync of inverse keys that needs to happen on a save.
  #
  # If the foreign key field has changed and the document is not
  # synced, $addToSet the new ids, $pull the ones no longer in the
  # array from the inverse side.
  #
  # @example Set up the save syncing.
  #   Person.synced_save(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [Class] The class getting set up.
  #
  # source://mongoid//lib/mongoid/association/referenced/syncable.rb#124
  def synced_save(association); end
end

# Implements the `with_polymorphic_criteria` shared behavior.
#
# @api private
#
# source://mongoid//lib/mongoid/association/referenced/with_polymorphic_criteria.rb#9
module Mongoid::Association::Referenced::WithPolymorphicCriteria
  # If the receiver represents a polymorphic association, applies
  # the polymorphic search criteria to the given `criteria` object.
  #
  # @api private
  # @param base [Mongoid::Document] the document to use when resolving
  #   the polymorphic type keys.
  # @param criteria [Mongoid::Criteria] the criteria to append to
  #   if receiver is polymorphic.
  # @return [Mongoid::Criteria] the resulting criteria, which may be
  #   the same as the input.
  #
  # source://mongoid//lib/mongoid/association/referenced/with_polymorphic_criteria.rb#20
  def with_polymorphic_criterion(criteria, base); end
end

# The reflections module provides convenience methods that can retrieve
# useful information about associations.
#
# source://mongoid//lib/mongoid/association/reflections.rb#9
module Mongoid::Association::Reflections
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods

  # Returns all association metadata for the supplied macros.
  #
  # @example Find multiple association metadata by macro.
  #   person.reflect_on_all_associations(:embeds_many)
  # @param *macros [Symbol...] The association macros.
  # @return [Array<Mongoid::Association::Relatable>] The matching association metadata.
  #
  # source://mongoid//lib/mongoid/association/reflections.rb#32
  def reflect_on_all_association(*macros); end

  # Returns the association metadata for the supplied name.
  #
  # @example Find association metadata by name.
  #   person.reflect_on_association(:addresses)
  # @param name [String | Symbol] The name of the association to find.
  # @return [Mongoid::Association::Relatable] The matching association metadata.
  #
  # source://mongoid//lib/mongoid/association/reflections.rb#20
  def reflect_on_association(name); end
end

# source://mongoid//lib/mongoid/association/reflections.rb#36
module Mongoid::Association::Reflections::ClassMethods
  # Returns all association metadata for the supplied macros.
  #
  # @example Find multiple association metadata by macro.
  #   Person.reflect_on_all_associations(:embeds_many)
  # @param *macros [Symbol...] The association macros.
  # @return [Array<Mongoid::Association::Relatable>] The matching association metadata.
  #
  # source://mongoid//lib/mongoid/association/reflections.rb#58
  def reflect_on_all_associations(*macros); end

  # Returns the association metadata for the supplied name.
  #
  # @example Find association metadata by name.
  #   Person.reflect_on_association(:addresses)
  # @param name [String | Symbol] The name of the association to find.
  # @return [Mongoid::Association::Relatable] The matching association metadata.
  #
  # source://mongoid//lib/mongoid/association/reflections.rb#46
  def reflect_on_association(name); end
end

# This module provides behaviors shared between Association types.
#
# source://mongoid//lib/mongoid/association/relatable.rb#11
module Mongoid::Association::Relatable
  include ::Mongoid::Association::Constrainable
  include ::Mongoid::Association::Options

  # Initialize the Association.
  #
  # @param _class [Class] The class of the model who owns this association.
  # @param block [Block] The optional block.
  # @param name [Symbol] The name of the association.
  # @param opts [Hash] The association options.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#46
  def initialize(_class, name, opts = T.unsafe(nil), &block); end

  # Compare this association to another.
  #
  # @return [Object] The object to compare to this association.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#62
  def ==(other); end

  # Whether trying to bind an object using this association should raise
  # an error.
  #
  # @param doc [Document] The document to be bound.
  # @return [true | false] Whether the document can be bound.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#93
  def bindable?(doc); end

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # @note The return value of this method should not be used to determine
  #   whether two associations have the same target class, because the
  #   return value is not always a fully qualified class name. To compare
  #   classes, retrieve the class instance of the association target using
  #   the +relation_class+ method.
  # @return [String] The association objects' class name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#151
  def class_name; end

  # Get the counter cache column name.
  #
  # @return [String] The counter cache column name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#270
  def counter_cache_column_name; end

  # Create an association proxy object using the owner and target.
  #
  # @param owner [Document] The document this association hangs off of.
  # @param target [Document | Array<Document>] The target (parent) of the
  #   association.
  # @return [Proxy]
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#256
  def create_relation(owner, target); end

  # Whether the dependent method is destructive.
  #
  # @return [true | false] If the dependent method is destructive.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#263
  def destructive?; end

  # Get the extension.
  #
  # @return [Module] The extension module, if one has been defined.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#279
  def extension; end

  # Get the name of the method to check if the foreign key has changed.
  #
  # @example Get the foreign key check method.
  #   association.foreign_key_check
  # @return [String] The foreign key check.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#245
  def foreign_key_check; end

  # The name of the foreign key setter method.
  #
  # @return [String] The name of the foreign key setter.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#215
  def foreign_key_setter; end

  # Get the callbacks for a given type.
  #
  # @param callback_type [Symbol] The type of callback type.
  # @return [Array<Proc | Symbol>] A list of the callbacks, either method
  #   names or Procs.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#75
  def get_callbacks(callback_type); end

  # Is this association an embedded_in or belongs_to association?
  #
  # @return [true | false] true if it is an embedded_in or belongs_to
  #   association, false if not.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#333
  def in_to?; end

  # Get the inverse name.
  #
  # @return [Symbol] The inverse name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#286
  def inverse(other = T.unsafe(nil)); end

  # Get the inverse's association metadata.
  #
  # @param other [Object] The other model class or model object to use when
  #   determining inverses.
  # @return [Mongoid::Association::Relatable] The inverse's association metadata.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#118
  def inverse_association(other = T.unsafe(nil)); end

  # The class of the object owning this association.
  #
  # @return [String] The owning objects' class.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#185
  def inverse_class; end

  # The class name of the object owning this association.
  #
  # @return [String] The owning objects' class name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#178
  def inverse_class_name; end

  # The class of the object owning this association.
  #
  # @return [String] The owning objects' class.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#188
  def inverse_klass; end

  # The name of the inverse setter method.
  #
  # @return [String] The name of the inverse setter.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#208
  def inverse_setter(other = T.unsafe(nil)); end

  # Get the inverse type.
  #
  # @return [nil] Default is nil for an association.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#125
  def inverse_type; end

  # Gets the setter for the field that sets the type of document on a
  # polymorphic association.
  #
  # @example Get the inverse type setter.
  #   association.inverse_type_setter
  # @return [String] The name of the setter.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#235
  def inverse_type_setter; end

  # Get the inverse names.
  #
  # @param other [Object] The other model class or model object to use when
  #   determining inverses.
  # @return [Array<Symbol>] The list of inverse names.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#101
  def inverses(other = T.unsafe(nil)); end

  # The foreign key field if this association stores a foreign key.
  # Otherwise, the primary key.
  #
  # @return [Symbol | String] The primary key.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#194
  def key; end

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # @return [String] The association objects' class.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#173
  def klass; end

  # Is this association an embeds_many or has_many association?
  #
  # @return [true | false] true if it is a *_many association, false if not.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#318
  def many?; end

  # The name of the association.
  #
  # @return [Symbol] The name of the association.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#33
  def name; end

  # Is this association an embeds_one or has_one association?
  #
  # @return [true | false] true if it is a *_one association, false if not.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#325
  def one?; end

  # The options on this association.
  #
  # @return [Hash] The options.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#38
  def options; end

  # The associations above this one in the inclusion tree.
  #
  # @return [Array<String>] The associations.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#306
  def parent_inclusions; end

  # The associations above this one in the inclusion tree.
  #
  # @return [Array<String>] The associations.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#306
  def parent_inclusions=(_arg0); end

  # The atomic path for this association.
  #
  # @return [Mongoid::Atomic::Paths::Root] The atomic path object.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#224
  def path(document); end

  # The class of the association object(s).
  #
  # This method returns the class instance corresponding to
  # +relation_class_name+, resolved relative to the host document class.
  #
  # If the class does not exist, this method raises NameError. This can
  # happen because the target class has not yet been defined. Note that
  # polymorphic associations generally do not have a well defined target
  # class because the target class can change from one object to another,
  # and calling this method on a polymorphic association will generally
  # fail with a NameError or produce misleading results (if a class does
  # happen to be defined with the same name as the association name).
  #
  # @return [String] The association objects' class.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#167
  def relation_class; end

  # The class name, possibly unqualified or :: prefixed, of the association
  # object(s).
  #
  # This method returns the class name as it is used in the association
  # definition. If :class_name option is given in the association, the
  # exact value of that option is returned here. If :class_name option is
  # not given, the name of the class is calculated from association name
  # but is not resolved to the actual class.
  #
  # The class name returned by this method may not correspond to a defined
  # class, either because the corresponding class has not been loaded yet,
  # or because the association references a non-existent class altogether.
  # To obtain the association class, use +relation_class+ method.
  #
  # @note The return value of this method should not be used to determine
  #   whether two associations have the same target class, because the
  #   return value is not always a fully qualified class name. To compare
  #   classes, retrieve the class instance of the association target using
  #   the +relation_class+ method.
  # @return [String] The association objects' class name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#148
  def relation_class_name; end

  # The name of the setter on this object for assigning an associated object.
  #
  # @return [String] The setter name.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#201
  def setter; end

  # Get the type setter.
  #
  # @note Only relevant for polymorphic associations that take the :as option.
  # @return [String] The type setter method.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#83
  def type_setter; end

  # Whether the associated object(s) should be validated.
  #
  # @return [true | false] If the associated object(s)
  #   should be validated.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#295
  def validate?; end

  private

  # source://mongoid//lib/mongoid/association/relatable.rb#421
  def create_extension!(&block); end

  # source://mongoid//lib/mongoid/association/relatable.rb#431
  def default_inverse; end

  # source://mongoid//lib/mongoid/association/relatable.rb#355
  def define_autosaver!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#361
  def define_builder!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#389
  def define_counter_cache_callbacks!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#365
  def define_creator!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#395
  def define_dependency!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#377
  def define_existence_check!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#369
  def define_getter!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#381
  def define_ids_getter!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#385
  def define_ids_setter!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#373
  def define_setter!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#349
  def define_touchable!; end

  # Gets the model classes with inverse associations of this model. This is used to determine
  # the classes on the other end of polymorphic associations with models.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#341
  def inverse_association_classes; end

  # Returns an array of classes/modules forming the namespace hierarchy
  # where symbols referenced in the provided class/module would be looked
  # up by Ruby. For example, if mod is Foo::Bar, this method would return
  # [Foo::Bar, Foo, Object].
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#439
  def namespace_hierarchy(mod); end

  # source://mongoid//lib/mongoid/association/relatable.rb#415
  def polymorph!; end

  # Resolves the given class/module name in the context of the specified
  # module, as Ruby would when a constant is referenced in the source.
  #
  # @note This method can swallow exceptions produced during class loading,
  #   because it rescues NameError internally. Since this method attempts
  #   to load classes, failure during the loading process may also lead to
  #   there being incomplete class definitions.
  #
  # source://mongoid//lib/mongoid/association/relatable.rb#461
  def resolve_name(mod, name); end

  # source://mongoid//lib/mongoid/association/relatable.rb#345
  def setup_index!; end

  # source://mongoid//lib/mongoid/association/relatable.rb#401
  def validate!; end
end

# The primary key default.
#
# @return [String] The primary key field default.
#
# source://mongoid//lib/mongoid/association/relatable.rb#28
Mongoid::Association::Relatable::PRIMARY_KEY_DEFAULT = T.let(T.unsafe(nil), String)

# The options shared between all association types.
#
# @return [Array<Symbol>] The shared options.
#
# source://mongoid//lib/mongoid/association/relatable.rb#18
Mongoid::Association::Relatable::SHARED_OPTIONS = T.let(T.unsafe(nil), Array)

# This module contains the logic for supporting atomic operations against the
# database.
#
# source://mongoid//lib/mongoid/atomic/modifiers.rb#5
module Mongoid::Atomic
  extend ::ActiveSupport::Concern

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  #
  # @example Get the updates that need to occur.
  #   person.atomic_updates(children)
  # @note MongoDB does not allow "conflicting modifications" to be
  #   performed in a single operation. Conflicting modifications are
  #   detected by the 'haveConflictingMod' function in MongoDB.
  #   Examination of the code suggests that two modifications (a $set
  #   and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  #   So a $set of 'addresses.0.street' will conflict with a $push and $each
  #   to 'addresses', and we will need to split our update into two
  #   pieces. We do not, however, attempt to match MongoDB's logic
  #   exactly. Instead, we assume that two updates conflict if the
  #   first component of the two key paths matches.
  # @return [Hash] The updates and their modifiers.
  #
  # source://mongoid//lib/mongoid/atomic.rb#129
  def _updates(_use_indexes = T.unsafe(nil)); end

  # Add the document as an atomic pull.
  #
  # @example Add the atomic pull.
  #   person.add_atomic_pull(address)
  # @param document [Document] The embedded document to pull.
  #
  # source://mongoid//lib/mongoid/atomic.rb#34
  def add_atomic_pull(document); end

  # Add an atomic unset for the document.
  #
  # @example Add an atomic unset.
  #   document.add_atomic_unset(doc)
  # @param document [Document] The child document.
  # @return [Array<Document>] The children.
  #
  # source://mongoid//lib/mongoid/atomic.rb#49
  def add_atomic_unset(document); end

  # For array fields these are the unique adds that need to happen.
  #
  # @example Get the array unique adds.
  #   person.atomic_array_add_to_sets
  # @return [Hash] The array add_to_sets.
  #
  # source://mongoid//lib/mongoid/atomic.rb#92
  def atomic_array_add_to_sets; end

  # For array fields these are the pulls that need to happen.
  #
  # @example Get the array pulls.
  #   person.atomic_array_pulls
  # @return [Hash] The array pulls.
  #
  # source://mongoid//lib/mongoid/atomic.rb#82
  def atomic_array_pulls; end

  # For array fields these are the pushes that need to happen.
  #
  # @example Get the array pushes.
  #   person.atomic_array_pushes
  # @return [Hash] The array pushes.
  #
  # source://mongoid//lib/mongoid/atomic.rb#72
  def atomic_array_pushes; end

  # Returns path of the attribute for modification
  #
  # @example Get path of the attribute
  #   address.atomic_attribute_name(:city)
  # @return [String] The path to the document attribute in the database
  #
  # source://mongoid//lib/mongoid/atomic.rb#62
  def atomic_attribute_name(name); end

  # Get the removal modifier for the document. Will be nil on root
  # documents, $unset on embeds_one, $set on embeds_many.
  #
  # @example Get the removal operator.
  #   name.atomic_delete_modifier
  # @return [String] The pull or unset operation.
  #
  # source://mongoid//lib/mongoid/atomic.rb#139
  def atomic_delete_modifier; end

  # Get the insertion modifier for the document. Will be nil on root
  # documents, $set on embeds_one, $push on embeds_many.
  #
  # @example Get the insert operation.
  #   name.atomic_insert_modifier
  # @return [String] The pull or set operator.
  #
  # source://mongoid//lib/mongoid/atomic.rb#150
  def atomic_insert_modifier; end

  # Return the path to this +Document+ in JSON notation, used for atomic
  # updates via $set in MongoDB.
  #
  # @example Get the path to this document.
  #   address.atomic_path
  # @return [String] The path to the document in the database.
  #
  # source://mongoid//lib/mongoid/atomic.rb#161
  def atomic_path; end

  # Get the atomic paths utility for this document.
  #
  # @example Get the atomic paths.
  #   document.atomic_paths
  # @return [Object] The associated path.
  #
  # source://mongoid//lib/mongoid/atomic.rb#181
  def atomic_paths; end

  # Returns the positional operator of this document for modification.
  #
  # @example Get the positional operator.
  #   address.atomic_position
  # @return [String] The positional operator with indexes.
  #
  # source://mongoid//lib/mongoid/atomic.rb#171
  def atomic_position; end

  # Get all the attributes that need to be pulled.
  #
  # @example Get the pulls.
  #   person.atomic_pulls
  # @return [Array<Hash>] The $pullAll operations.
  #
  # source://mongoid//lib/mongoid/atomic.rb#199
  def atomic_pulls; end

  # Get all the push attributes that need to occur.
  #
  # @example Get the pushes.
  #   person.atomic_pushes
  # @return [Hash] The $push and $each operations.
  #
  # source://mongoid//lib/mongoid/atomic.rb#218
  def atomic_pushes; end

  # Get all the attributes that need to be set.
  #
  # @example Get the sets.
  #   person.atomic_sets
  # @return [Hash] The $set operations.
  #
  # source://mongoid//lib/mongoid/atomic.rb#228
  def atomic_sets; end

  # Get all the attributes that need to be unset.
  #
  # @example Get the unsets.
  #   person.atomic_unsets
  # @return [Array<Hash>] The $unset operations.
  #
  # source://mongoid//lib/mongoid/atomic.rb#244
  def atomic_unsets; end

  # Get all the atomic updates that need to happen for the current
  # +Document+. This includes all changes that need to happen in the
  # entire hierarchy that exists below where the save call was made.
  #
  #
  # @example Get the updates that need to occur.
  #   person.atomic_updates(children)
  # @note MongoDB does not allow "conflicting modifications" to be
  #   performed in a single operation. Conflicting modifications are
  #   detected by the 'haveConflictingMod' function in MongoDB.
  #   Examination of the code suggests that two modifications (a $set
  #   and a $push with $each, for example) conflict if:
  #   (1) the key paths being modified are equal.
  #   (2) one key path is a prefix of the other.
  #   So a $set of 'addresses.0.street' will conflict with a $push and $each
  #   to 'addresses', and we will need to split our update into two
  #   pieces. We do not, however, attempt to match MongoDB's logic
  #   exactly. Instead, we assume that two updates conflict if the
  #   first component of the two key paths matches.
  # @return [Hash] The updates and their modifiers.
  #
  # source://mongoid//lib/mongoid/atomic.rb#119
  def atomic_updates(_use_indexes = T.unsafe(nil)); end

  # Get a hash of atomic pulls that are pending.
  #
  # @example Get the atomic pulls.
  #   document.delayed_atomic_pulls
  # @return [Hash] name/document pairs.
  #
  # source://mongoid//lib/mongoid/atomic.rb#272
  def delayed_atomic_pulls; end

  # Get all the atomic sets that have had their saves delayed.
  #
  # @example Get the delayed atomic sets.
  #   person.delayed_atomic_sets
  # @return [Hash] The delayed $sets.
  #
  # source://mongoid//lib/mongoid/atomic.rb#262
  def delayed_atomic_sets; end

  # Get the delayed atomic unsets.
  #
  # @example Get the delayed atomic unsets.
  #   document.delayed_atomic_unsets
  # @return [Hash] The atomic unsets
  #
  # source://mongoid//lib/mongoid/atomic.rb#282
  def delayed_atomic_unsets; end

  # Flag the document as destroyed and return the atomic path.
  #
  # @example Flag destroyed and return path.
  #   document.flag_as_destroyed
  # @return [String] The atomic path.
  #
  # source://mongoid//lib/mongoid/atomic.rb#292
  def flag_as_destroyed; end

  # Get the flagged destroys.
  #
  # @example Get the flagged destroy.
  #   document.flagged_destroys
  # @return [Array<Proc>] The flagged destroys.
  #
  # source://mongoid//lib/mongoid/atomic.rb#304
  def flagged_destroys; end

  # Process all the pending flagged destroys from nested attributes.
  #
  # @example Process all the pending flagged destroys.
  #   document.process_flagged_destroys
  # @return [Array] The cleared array.
  #
  # source://mongoid//lib/mongoid/atomic.rb#314
  def process_flagged_destroys; end

  private

  # Generates the atomic updates in the correct order.
  #
  # @example Generate the updates.
  #   model.generate_atomic_updates(mods, doc)
  # @param doc [Document] The document to update for.
  # @param mods [Modifiers] The atomic modifications.
  #
  # source://mongoid//lib/mongoid/atomic.rb#337
  def generate_atomic_updates(mods, doc); end

  # Clears all pending atomic updates.
  #
  # source://mongoid//lib/mongoid/atomic.rb#324
  def reset_atomic_updates!; end
end

# This class contains the logic for supporting atomic operations against the
# database.
#
# source://mongoid//lib/mongoid/atomic/modifiers.rb#9
class Mongoid::Atomic::Modifiers < ::Hash
  # Add the atomic $addToSet modifiers to the hash.
  #
  # @example Add the $addToSet modifiers.
  #   modifiers.add_to_set({ "preference_ids" => [ "one" ] })
  # @param modifications [Hash] The add to set modifiers.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#17
  def add_to_set(modifications); end

  # Adds pull all modifiers to the modifiers hash.
  #
  # @example Add pull all operations.
  #   modifiers.pull({ "addresses" => { "_id" => { "$in" => [ 1, 2, 3 ]}}})
  # @param modifications [Hash] The pull all modifiers.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#48
  def pull(modifications); end

  # Adds pull all modifiers to the modifiers hash.
  #
  # @example Add pull all operations.
  #   modifiers.pull_all({ "addresses" => { "street" => "Bond" }})
  # @param modifications [Hash] The pull all modifiers.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#35
  def pull_all(modifications); end

  # Adds push modifiers to the modifiers hash.
  #
  # @example Add push operations.
  #   modifiers.push({ "addresses" => { "street" => "Bond" }})
  # @param modifications [Hash] The push modifiers.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#61
  def push(modifications); end

  # Adds set operations to the modifiers hash.
  #
  # @example Add set operations.
  #   modifiers.set({ "title" => "sir" })
  # @param modifications [Hash] The set modifiers.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#75
  def set(modifications); end

  # Adds unset operations to the modifiers hash.
  #
  # @example Add unset operations.
  #   modifiers.unset([ "addresses" ])
  # @param modifications [Array<String>] The unset association names.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#90
  def unset(modifications); end

  private

  # Adds or appends an array operation with the $each specifier used
  # in conjuction with $push.
  #
  # @example Add the operation.
  #   modifications.add_operation(mods, field, value)
  # @param field [String] The field.
  # @param mods [Hash] The modifications.
  # @param value [Hash] The atomic op.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#130
  def add_each_operation(mods, field, value); end

  # Add the operation to the modifications, either appending or creating a
  # new one.
  #
  # @example Add the operation.
  #   modifications.add_operation(mods, field, value)
  # @param field [String] The field.
  # @param mods [Hash] The modifications.
  # @param value [Hash] The atomic op.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#107
  def add_operation(mods, field, value); end

  # Get the $addToSet operations or initialize a new one.
  #
  # @example Get the $addToSet operations.
  #   modifiers.add_to_sets
  # @return [Hash] The $addToSet operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#146
  def add_to_sets; end

  # Get the conflicting pull modifications.
  #
  # @example Get the conflicting pulls.
  #   modifiers.conflicting_pulls
  # @return [Hash] The conflicting pull operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#183
  def conflicting_pulls; end

  # Get the conflicting push modifications.
  #
  # @example Get the conflicting pushs.
  #   modifiers.conflicting_pushs
  # @return [Hash] The conflicting push operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#193
  def conflicting_pushes; end

  # Get the conflicting set modifications.
  #
  # @example Get the conflicting sets.
  #   modifiers.conflicting_sets
  # @return [Hash] The conflicting set operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#203
  def conflicting_sets; end

  # Get the push operations that would have conflicted with the sets.
  #
  # @example Get the conflicts.
  #   modifiers.conflicts
  # @return [Hash] The conflicting modifications.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#213
  def conflicts; end

  # Get the $pullAll operations or initialize a new one.
  #
  # @example Get the $pullAll operations.
  #   modifiers.pull_alls
  # @return [Hash] The $pullAll operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#253
  def pull_alls; end

  # Get the names of the fields that need to be pulled.
  #
  # @example Get the pull fields.
  #   modifiers.pull_fields
  # @return [Array<String>] The pull fields.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#223
  def pull_fields; end

  # Get the $pull operations or initialize a new one.
  #
  # @example Get the $pull operations.
  #   modifiers.pulls
  # @return [Hash] The $pull operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#263
  def pulls; end

  # Is the operation going to be a conflict for a $push?
  #
  # @example Is this a conflict for a push?
  #   modifiers.push_conflict?(field)
  # @param field [String] The field.
  # @return [true | false] If this field is a conflict.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#171
  def push_conflict?(field); end

  # Get the names of the fields that need to be pushed.
  #
  # @example Get the push fields.
  #   modifiers.push_fields
  # @return [Array<String>] The push fields.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#233
  def push_fields; end

  # Get the $push/$each operations or initialize a new one.
  #
  # @example Get the $push/$each operations.
  #   modifiers.pushes
  # @return [Hash] The $push/$each operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#273
  def pushes; end

  # Is the operation going to be a conflict for a $set?
  #
  # @example Is this a conflict for a set?
  #   modifiers.set_conflict?(field)
  # @param field [String] The field.
  # @return [true | false] If this field is a conflict.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#158
  def set_conflict?(field); end

  # Get the names of the fields that need to be set.
  #
  # @example Get the set fields.
  #   modifiers.set_fields
  # @return [Array<String>] The set fields.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#243
  def set_fields; end

  # Get the $set operations or initialize a new one.
  #
  # @example Get the $set operations.
  #   modifiers.sets
  # @return [Hash] The $set operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#283
  def sets; end

  # Get the $unset operations or initialize a new one.
  #
  # @example Get the $unset operations.
  #   modifiers.unsets
  # @return [Hash] The $unset operations.
  #
  # source://mongoid//lib/mongoid/atomic/modifiers.rb#293
  def unsets; end
end

# source://mongoid//lib/mongoid/atomic/paths/embedded/one.rb#6
module Mongoid::Atomic::Paths; end

# Common functionality between the two different embedded paths.
#
# source://mongoid//lib/mongoid/atomic/paths/embedded/one.rb#7
module Mongoid::Atomic::Paths::Embedded
  # Returns the value of attribute delete_modifier.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded.rb#14
  def delete_modifier; end

  # Returns the value of attribute document.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded.rb#14
  def document; end

  # Returns the value of attribute insert_modifier.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded.rb#14
  def insert_modifier; end

  # Returns the value of attribute parent.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded.rb#14
  def parent; end

  # Get the path to the document in the hierarchy.
  #
  # @example Get the path.
  #   many.path
  # @return [String] The path to the document.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded.rb#22
  def path; end
end

# This class encapsulates behavior for locating and updating
# documents that are defined as an embedded 1-n.
#
# source://mongoid//lib/mongoid/atomic/paths/embedded/many.rb#11
class Mongoid::Atomic::Paths::Embedded::Many
  include ::Mongoid::Atomic::Paths::Embedded

  # Create the new path utility.
  #
  # @example Create the path util.
  #   Many.new(document)
  # @param document [Document] The document to generate the paths for.
  # @return [Many] a new instance of Many
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded/many.rb#20
  def initialize(document); end

  # Get the position of the document in the hierarchy. This will
  # include indexes of 1-n embedded associations that may sit above the
  # embedded many.
  #
  # @example Get the position.
  #   many.position
  # @return [String] The position of the document.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded/many.rb#33
  def position; end

  class << self
    # Get the position of where the document would go for the given
    # association. The use case for this function is when trying to
    # persist an empty list for an embedded association. All of the
    # existing functions for getting the position to store a document
    # require passing in a document to store, which we don't have when
    # trying to store the empty list.
    #
    # @param association [Mongoid::Association::Relatable] The association metadata.
    # @param parent [Document] The parent document to store in.
    # @return [String] The position string.
    #
    # source://mongoid//lib/mongoid/atomic/paths/embedded/many.rb#52
    def position_without_document(parent, association); end
  end
end

# This class encapsulates behavior for locating and updating
# documents that are defined as an embedded 1-1.
#
# source://mongoid//lib/mongoid/atomic/paths/embedded/one.rb#11
class Mongoid::Atomic::Paths::Embedded::One
  include ::Mongoid::Atomic::Paths::Embedded

  # Create the new path utility.
  #
  # @example Create the path util.
  #   One.new(document)
  # @param document [Document] The document to generate the paths for.
  # @return [One] a new instance of One
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded/one.rb#20
  def initialize(document); end

  # Get the position of the document in the hierarchy. This will
  # include indexes of 1-n embedded associations that may sit above the
  # embedded one.
  #
  # @example Get the position.
  #   one.position
  # @return [String] The position of the document.
  #
  # source://mongoid//lib/mongoid/atomic/paths/embedded/one.rb#33
  def position; end
end

# This class encapsulates behavior for locating and updating root
# documents atomically.
#
# source://mongoid//lib/mongoid/atomic/paths/root.rb#10
class Mongoid::Atomic::Paths::Root
  # Create the new root path utility.
  #
  # @example Create the root path util.
  #   Root.new(document)
  # @param document [Document] The document to generate the paths for.
  # @return [Root] a new instance of Root
  #
  # source://mongoid//lib/mongoid/atomic/paths/root.rb#20
  def initialize(document); end

  # Returns the value of attribute document.
  #
  # source://mongoid//lib/mongoid/atomic/paths/root.rb#12
  def document; end

  # Asking for the insert modifier on a document with a root path
  # indicates a mixed association most likely happened.
  #
  # @example Attempt to get the insert modifier.
  #   root.insert_modifier
  # @raise [Errors::InvalidPath] The error for the attempt.
  #
  # source://mongoid//lib/mongoid/atomic/paths/root.rb#31
  def insert_modifier; end

  # Returns the value of attribute path.
  #
  # source://mongoid//lib/mongoid/atomic/paths/root.rb#12
  def path; end

  # Returns the value of attribute position.
  #
  # source://mongoid//lib/mongoid/atomic/paths/root.rb#12
  def position; end
end

# source://mongoid//lib/mongoid/atomic.rb#12
Mongoid::Atomic::UPDATES = T.let(T.unsafe(nil), Array)

# A singleton class to assist with preparing attributes for atomic
# updates.
#
# Once the deprecated Hash#__consolidate__ method is removed entirely,
# these methods may be moved into Mongoid::Contextual::Mongo as private
# methods.
#
# @api private
#
# source://mongoid//lib/mongoid/atomic_update_preparer.rb#12
class Mongoid::AtomicUpdatePreparer
  class << self
    # Convert the key/values in the attributes into a hash of atomic updates.
    # Non-operator keys are assumed to use $set operation.
    #
    # @api private
    # @param attributes [Hash] The attributes to convert.
    # @param klass [Class] The model class.
    # @return [Hash] The prepared atomic updates.
    #
    # source://mongoid//lib/mongoid/atomic_update_preparer.rb#21
    def prepare(attributes, klass); end

    private

    # Mongoize for the klass, key and value.
    #
    # @api private
    # @param key [String | Symbol] The field key.
    # @param klass [Class] The model class.
    # @param operator [String] The operator.
    # @param value [Object] The value to mongoize.
    # @return [Object] The mongoized value.
    #
    # source://mongoid//lib/mongoid/atomic_update_preparer.rb#76
    def mongoize_for(operator, klass, key, value); end

    # Treats the key as if it were a MongoDB operator and prepares
    # the value accordingly.
    #
    # @api private
    # @param key [String | Symbol] the operator
    # @param klass [Class] the model class
    # @param value [Hash] the operand
    # @return [Hash] the prepared value.
    #
    # source://mongoid//lib/mongoid/atomic_update_preparer.rb#43
    def prepare_operation(klass, key, value); end

    # Get the value for the provided operator, klass, key and value.
    #
    # This is necessary for special cases like $rename, $addToSet, $push, $pull and $pop.
    #
    # @api private
    # @param key [String | Symbol] The field key.
    # @param klass [Class] The model class.
    # @param operator [String] The operator.
    # @param value [Object] The original value.
    # @return [Object] Value prepared for the provided operator.
    #
    # source://mongoid//lib/mongoid/atomic_update_preparer.rb#60
    def value_for(operator, klass, key, value); end
  end
end

# This module contains the logic for handling the internal attributes hash,
# and how to get and set values.
#
# source://mongoid//lib/mongoid/attributes/dynamic.rb#5
module Mongoid::Attributes
  include ::Mongoid::Attributes::Processing
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # @example Read an attribute (alternate syntax.)
  #   person[:title]
  # @example Read an attribute.
  #   person.read_attribute(:title)
  # @param name [String | Symbol] The name of the attribute to get.
  # @return [Object] The value of the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#93
  def [](name); end

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # @example Write the attribute (alternate syntax.)
  #   person[:title] = "Mr."
  # @example Write the attribute.
  #   person.write_attribute(:title, "Mr.")
  # @param name [String | Symbol] The name of the attribute to update.
  # @param value [Object] The value to set for the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#205
  def []=(name, value); end

  # Allows you to set all the attributes for a particular mass-assignment security role
  # by passing in a hash of attributes with keys matching the attribute names
  # (which again matches the column names)  and the role name using the :as option.
  # To bypass mass-assignment security you can use the :without_protection => true option.
  #
  # @example Assign the attributes (with a role).
  #   person.assign_attributes({ :title => "Mr." }, :as => :admin)
  # @example Assign the attributes.
  #   person.assign_attributes(:title => "Mr.")
  # @param attrs [Hash] The new attributes to set.
  #
  # source://mongoid//lib/mongoid/attributes.rb#219
  def assign_attributes(attrs = T.unsafe(nil)); end

  # Determine if the attribute is missing from the document, due to loading
  # it from the database with missing fields.
  #
  # @example Is the attribute missing?
  #   document.attribute_missing?("test")
  # @param name [String] The name of the attribute.
  # @return [true | false] If the attribute is missing.
  #
  # source://mongoid//lib/mongoid/attributes.rb#250
  def attribute_missing?(name); end

  # Determine if an attribute is present.
  #
  # @example Is the attribute present?
  #   person.attribute_present?("title")
  # @param name [String | Symbol] The name of the attribute.
  # @return [true | false] True if present, false if not.
  #
  # source://mongoid//lib/mongoid/attributes.rb#33
  def attribute_present?(name); end

  # Returns the value of attribute attributes.
  #
  # source://mongoid//lib/mongoid/attributes.rb#22
  def attributes; end

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # @example Write the attributes (alternate syntax.)
  #   person.attributes = { :title => "Mr." }
  # @example Write the attributes.
  #   person.write_attributes(:title => "Mr.")
  # @param attrs [Hash] The new attributes to set.
  #
  # source://mongoid//lib/mongoid/attributes.rb#239
  def attributes=(attrs = T.unsafe(nil)); end

  # Get the attributes that have not been cast.
  #
  # @example Get the attributes before type cast.
  #   document.attributes_before_type_cast
  # @return [Hash] The uncast attributes.
  #
  # source://mongoid//lib/mongoid/attributes.rb#46
  def attributes_before_type_cast; end

  # Does the document have the provided attribute?
  #
  # @example Does the document have the attribute?
  #   model.has_attribute?(:name)
  # @param name [String | Symbol] The name of the attribute.
  # @return [true | false] If the key is present in the attributes.
  #
  # source://mongoid//lib/mongoid/attributes.rb#58
  def has_attribute?(name); end

  # Does the document have the provided attribute before it was assigned
  # and type cast?
  #
  # @example Does the document have the attribute before it was assigned?
  #   model.has_attribute_before_type_cast?(:name)
  # @param name [String | Symbol] The name of the attribute.
  # @return [true | false] If the key is present in the
  #   attributes_before_type_cast.
  #
  # source://mongoid//lib/mongoid/attributes.rb#72
  def has_attribute_before_type_cast?(name); end

  # Process the raw attribute values just read from the documents attributes.
  #
  # @api private
  # @param field [Field | nil] The field to use for demongoization or nil.
  # @param name [String] The name of the attribute to get.
  # @param raw [Object] The raw attribute value.
  # @return [Object] The value of the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#105
  def process_raw_attribute(name, raw, field); end

  # Returns the value of attribute attributes.
  #
  # source://mongoid//lib/mongoid/attributes.rb#23
  def raw_attributes; end

  # Read a value from the document attributes. If the value does not exist
  # it will return nil.
  #
  # @example Read an attribute (alternate syntax.)
  #   person[:title]
  # @example Read an attribute.
  #   person.read_attribute(:title)
  # @param name [String | Symbol] The name of the attribute to get.
  # @return [Object] The value of the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#88
  def read_attribute(name); end

  # Read a value from the attributes before type cast. If the value has not
  # yet been assigned then this will return the attribute's existing value
  # using read_raw_attribute.
  #
  # @example Read an attribute before type cast.
  #   person.read_attribute_before_type_cast(:price)
  # @param name [String | Symbol] The name of the attribute to get.
  # @return [Object] The value of the attribute before type cast, if
  #   available. Otherwise, the value of the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#123
  def read_attribute_before_type_cast(name); end

  # Remove a value from the +Document+ attributes. If the value does not exist
  # it will fail gracefully.
  #
  # @example Remove the attribute.
  #   person.remove_attribute(:title)
  # @param name [String | Symbol] The name of the attribute to remove.
  # @raise [Errors::ReadonlyAttribute] If the field cannot be removed due
  #   to being flagged as reaodnly.
  #
  # source://mongoid//lib/mongoid/attributes.rb#142
  def remove_attribute(name); end

  # Return type-casted attributes.
  #
  # @example Type-casted attributes.
  #   document.typed_attributes
  # @return [Object] The hash with keys and values of the type-casted attributes.
  #
  # source://mongoid//lib/mongoid/attributes.rb#260
  def typed_attributes; end

  # Write a single attribute to the document attribute hash. This will
  # also fire the before and after update callbacks, and perform any
  # necessary typecasting.
  #
  # @example Write the attribute (alternate syntax.)
  #   person[:title] = "Mr."
  # @example Write the attribute.
  #   person.write_attribute(:title, "Mr.")
  # @param name [String | Symbol] The name of the attribute to update.
  # @param value [Object] The value to set for the attribute.
  #
  # source://mongoid//lib/mongoid/attributes.rb#165
  def write_attribute(name, value); end

  # Writes the supplied attributes hash to the document. This will only
  # overwrite existing attributes if they are present in the new +Hash+, all
  # others will be preserved.
  #
  # @example Write the attributes (alternate syntax.)
  #   person.attributes = { :title => "Mr." }
  # @example Write the attributes.
  #   person.write_attributes(:title => "Mr.")
  # @param attrs [Hash] The new attributes to set.
  #
  # source://mongoid//lib/mongoid/attributes.rb#236
  def write_attributes(attrs = T.unsafe(nil)); end

  private

  # Determine if the attribute will not change, by comparing the current
  # value with the new value. The values are normalized to account for
  # types that do not implement `#==` in a way that is compatible with
  # each other, such as `BSON::Decimal128` and `BigDecimal`.
  #
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/attributes.rb#382
  def attribute_will_not_change?(field_name, typed_value); end

  # Does the string contain dot syntax for accessing hashes?
  #
  # @api private
  # @example Is the string in dot syntax.
  #   model.hash_dot_syntax?
  # @return [true | false] If the string contains a "."
  #
  # source://mongoid//lib/mongoid/attributes.rb#274
  def hash_dot_syntax?(string); end

  # source://mongoid//lib/mongoid/attributes.rb#364
  def lookup_attribute_presence(name, value); end

  # If `value` is a `BSON::Decimal128`, convert it to a `BigDecimal` for
  # comparison purposes. This is necessary because `BSON::Decimal128` does
  # not implement `#==` in a way that is compatible with `BigDecimal`.
  #
  # source://mongoid//lib/mongoid/attributes.rb#374
  def normalize_value(value); end

  # source://mongoid//lib/mongoid/attributes.rb#293
  def read_raw_attribute(name); end

  # Return the typecasted value for a field.
  #
  # @example Get the value typecasted.
  #   person.typed_value_for(:title, :sir)
  # @param key [String | Symbol] The field name.
  # @param value [Object] The uncast value.
  # @return [Object] The cast value.
  #
  # source://mongoid//lib/mongoid/attributes.rb#287
  def typed_value_for(key, value); end

  module GeneratedClassMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end
end

# source://mongoid//lib/mongoid/attributes.rb#311
module Mongoid::Attributes::ClassMethods
  # Alias the provided name to the original field. This will provide an
  # aliased getter, setter, existence check, and all dirty attribute
  # methods.
  #
  # @example Alias the attribute.
  #   class Product
  #   include Mongoid::Document
  #   field :price, :type => Float
  #   alias_attribute :cost, :price
  #   end
  # @param name [Symbol] The new name.
  # @param original [Symbol] The original name.
  #
  # source://mongoid//lib/mongoid/attributes.rb#326
  def alias_attribute(name, original); end

  # Removes a field alias.
  #
  # @param name [Symbol] The aliased field name to remove.
  #
  # source://mongoid//lib/mongoid/attributes.rb#344
  def unalias_attribute(name); end
end

# This module contains the behavior for dynamic attributes.
#
# source://mongoid//lib/mongoid/attributes/dynamic.rb#8
module Mongoid::Attributes::Dynamic
  extend ::ActiveSupport::Concern

  # Define a reader method for a dynamic attribute before type cast.
  #
  # @api private
  # @example Define a reader method for an attribute.
  #   model.define_dynamic_before_type_cast_reader(:field)
  # @param name [String] The name of the field.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#54
  def define_dynamic_before_type_cast_reader(name); end

  # Define a reader method for a dynamic attribute.
  #
  # @api private
  # @example Define a reader method.
  #   model.define_dynamic_reader(:field)
  # @param name [String] The name of the field.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#35
  def define_dynamic_reader(name); end

  # Define a writer method for a dynamic attribute.
  #
  # @api private
  # @example Define a writer method.
  #   model.define_dynamic_writer(:field)
  # @param name [String] The name of the field.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#71
  def define_dynamic_writer(name); end

  # Get an array of inspected dynamic fields for the document.
  #
  # @example Inspect the dynamic fields.
  #   document.inspect_dynamic_fields
  # @return [String] An array of pretty printed dynamic field values.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#104
  def inspect_dynamic_fields; end

  # Used for allowing accessor methods for dynamic attributes.
  #
  # @api private
  # @example Call through method_missing.
  #   document.method_missing(:test)
  # @param *args [Object...] The arguments to the method.
  # @param name [String | Symbol] The name of the method.
  # @return [Object] The result of the method call.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#122
  def method_missing(name, *args); end

  # If the attribute is dynamic, add a field for it with a type of object
  # and set the value.
  #
  # @example Process the attribute.
  #   document.process_attribute(name, value)
  # @param name [Symbol] The name of the field.
  # @param value [Object] The value of the field.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#89
  def process_attribute(name, value); end

  # Override respond_to? so it responds properly for dynamic attributes.
  #
  # @example Does this object respond to the method?
  #   person.respond_to?(:title)
  # @param include_private [true | false]
  # @param name [Array] The name of the method.
  # @return [true | false] True if it does, false if not.
  #
  # source://mongoid//lib/mongoid/attributes/dynamic.rb#20
  def respond_to?(name, include_private = T.unsafe(nil)); end
end

# Utility module for working with embedded attributes.
#
# source://mongoid//lib/mongoid/attributes/embedded.rb#6
module Mongoid::Attributes::Embedded
  extend ::Mongoid::Attributes::Embedded

  # Fetch an embedded value or subset of attributes via dot notation.
  #
  # @example Fetch an embedded value via dot notation.
  #   Embedded.traverse({ 'name' => { 'en' => 'test' } }, 'name.en')
  #   #=> 'test'
  # @param attributes [Hash] The document attributes.
  # @param path [String] The dot notation string.
  # @return [Object | nil] The attributes at the given path,
  #   or nil if the path doesn't exist.
  #
  # source://mongoid//lib/mongoid/attributes/embedded.rb#20
  def traverse(attributes, path); end
end

# Defines behavior for the Rails nested attributes feature.
#
# source://mongoid//lib/mongoid/attributes/nested.rb#8
module Mongoid::Attributes::Nested
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods

  module GeneratedClassMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
  end
end

# source://mongoid//lib/mongoid/attributes/nested.rb#16
module Mongoid::Attributes::Nested::ClassMethods
  # Used when needing to update related models from a parent association. Can
  # be used on embedded or referenced associations.
  #
  # @example Defining nested attributes.
  #
  #   class Person
  #   include Mongoid::Document
  #
  #   embeds_many :addresses
  #   embeds_one :game
  #   references_many :posts
  #
  #   accepts_nested_attributes_for :addresses, :game, :posts
  #   end
  # @option *args
  # @option *args
  # @option *args
  # @option *args
  # @option *args
  # @param *args [Symbol..., Hash] A list of association names, followed
  #   by an optional hash of options.
  #
  # source://mongoid//lib/mongoid/attributes/nested.rb#48
  def accepts_nested_attributes_for(*args); end

  private

  # Add the autosave information for the nested association.
  #
  # @api private
  # @example Add the autosave if appropriate.
  #   Person.autosave_nested_attributes(metadata)
  # @param association [Mongoid::Association::Relatable] The existing association metadata.
  #
  # source://mongoid//lib/mongoid/attributes/nested.rb#82
  def autosave_nested_attributes(association); end
end

# source://mongoid//lib/mongoid/attributes/nested.rb#18
Mongoid::Attributes::Nested::ClassMethods::REJECT_ALL_BLANK_PROC = T.let(T.unsafe(nil), Proc)

# This module contains the behavior for processing attributes.
#
# source://mongoid//lib/mongoid/attributes/processing.rb#6
module Mongoid::Attributes::Processing
  # Process the provided attributes casting them to their proper values if a
  # field exists for them on the document. This will be limited to only the
  # attributes provided in the supplied +Hash+ so that no extra nil values get
  # put into the document's attributes.
  #
  # @example Process the attributes.
  #   person.process_attributes(:title => "sir", :age => 40)
  # @param attrs [Hash] The attributes to set.
  # @yield [_self]
  # @yieldparam _self [Mongoid::Attributes::Processing] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#16
  def process_attributes(attrs = T.unsafe(nil)); end

  private

  # If the key provided is the name of an association or a nested attribute, we
  # need to wait until all other attributes are set before processing
  # these.
  #
  # @example Is the attribute pending?
  #   document.pending_attribute?(:name, "Durran")
  # @param key [Symbol] The name of the attribute.
  # @param value [Object] The value of the attribute.
  # @return [true | false] True if pending, false if not.
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#43
  def pending_attribute?(key, value); end

  # Get all the pending nested attributes that need to be set.
  #
  # @example Get the pending nested attributes.
  #   document.pending_nested
  # @return [Hash] The pending nested attributes in key/value pairs.
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#103
  def pending_nested; end

  # Get all the pending associations that need to be set.
  #
  # @example Get the pending associations.
  #   document.pending_relations
  # @return [Hash] The pending associations in key/value pairs.
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#93
  def pending_relations; end

  # If the attribute is dynamic, add a field for it with a type of object
  # and then either way set the value.
  #
  # @example Process the attribute.
  #   document.process_attribute(name, value)
  # @param name [Symbol] The name of the field.
  # @param value [Object] The value of the field.
  # @raise [Errors::UnknownAttribute]
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#115
  def process_attribute(name, value); end

  # Process all the pending nested attributes that needed to wait until
  # ids were set to fire off.
  #
  # @example Process the nested attributes.
  #   document.process_nested
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#130
  def process_nested; end

  # Process all the pending items, then clear them out.
  #
  # @example Process the pending items.
  #   document.process_pending
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#140
  def process_pending; end

  # Process all the pending associations that needed to wait until ids were set
  # to fire off.
  #
  # @example Process the associations.
  #   document.process_relations
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#151
  def process_relations; end

  # Set value of the pending nested attribute.
  #
  # @param aliased [Symbol] The aliased name of the nested attribute.
  # @param name [Symbol] The name of the nested attribute.
  # @param value [Object] The value of the nested attribute.
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#79
  def set_pending_nested(name, aliased, value); end

  # Set value of the pending relation.
  #
  # @param aliased [Symbol] The aliased name of the relation.
  # @param name [Symbol] The name of the relation.
  # @param value [Object] The value of the relation.
  #
  # source://mongoid//lib/mongoid/attributes/processing.rb#66
  def set_pending_relation(name, aliased, value); end
end

# This module defines projection helpers.
#
# Projection rules are rather non-trivial. See
# https://www.mongodb.com/docs/manual/reference/method/db.collection.find/#find-projection
# for server documentation.
# 4.4 server (and presumably all older ones) requires that a projection
# for content fields is either exclusionary or inclusionary, i.e. one
# cannot mix exclusions and inclusions in the same query.
# However, _id can be excluded in a projection that includes content
# fields.
# Integer projection values other than 0 and 1 aren't officially
# documented as of this writing; see DOCSP-15266.
# 4.4 server also allows nested hash projection specification
# in addition to dot notation, which I assume Mongoid doesn't handle yet.
#
# @api private
#
# source://mongoid//lib/mongoid/attributes/projector.rb#23
class Mongoid::Attributes::Projector
  # @api private
  # @return [Projector] a new instance of Projector
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#24
  def initialize(projection); end

  # Determine if the specified attribute, or a dot notation path, is allowed
  # by the configured projection, if any.
  #
  # If there is no configured projection, returns true.
  #
  # @api private
  # @param name [String] The name of the attribute or a dot notation path.
  # @return [true | false] Whether the attribute is allowed by projection.
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#48
  def attribute_or_path_allowed?(name); end

  # @api private
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#36
  def content_projection; end

  # @api private
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#35
  def id_projection_value; end

  private

  # Determines whether the projection for content fields is inclusionary.
  #
  # An empty projection is inclusionary.
  #
  # @api private
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#96
  def content_inclusionary?; end

  # @api private
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/attributes/projector.rb#104
  def value_inclusionary?(value); end
end

# This module defines behavior for readonly attributes.
#
# source://mongoid//lib/mongoid/attributes/readonly.rb#8
module Mongoid::Attributes::Readonly
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods

  # Are we able to write the attribute with the provided name?
  #
  # @example Can we write the attribute?
  #   model.attribute_writable?(:title)
  # @param name [String | Symbol] The name of the field.
  # @return [true | false] If the document is new, or if the field is not
  #   readonly.
  #
  # source://mongoid//lib/mongoid/attributes/readonly.rb#25
  def attribute_writable?(name); end

  private

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/attributes/readonly.rb#40
  def _loaded?(name); end

  # source://mongoid//lib/mongoid/attributes/readonly.rb#31
  def as_writable_attribute!(name, value = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/attributes/readonly.rb#44
  def projected_field?(name); end

  module GeneratedClassMethods
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end

  module GeneratedInstanceMethods
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
  end
end

# source://mongoid//lib/mongoid/attributes/readonly.rb#49
module Mongoid::Attributes::Readonly::ClassMethods
  # Defines an attribute as readonly. This will ensure that the value for
  # the attribute is only set when the document is new or we are
  # creating. In other cases, the field write will be ignored with the
  # exception of #remove_attribute and #update_attribute, where an error
  # will get raised.
  #
  # inherited by a child class, the child class will inherit the
  # parent's readonly attributes at the time of its creation.
  # Updating the parent does not propagate down to child classes after wards.
  #
  # @example Flag fields as readonly.
  #   class Band
  #   include Mongoid::Document
  #   field :name, type: String
  #   field :genre, type: String
  #   attr_readonly :name, :genre
  #   end
  # @note When a parent class contains readonly attributes and is then
  # @param *names [Symbol...] The names of the fields.
  #
  # source://mongoid//lib/mongoid/attributes/readonly.rb#70
  def attr_readonly(*names); end
end

# Adds type-casting behavior to Mongoid::Boolean class.
#
# source://mongoid//lib/mongoid/extensions/boolean.rb#7
class Mongoid::Boolean
  extend ::Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods

  class << self
    # Turn the object from the ruby type we deal with to a Mongo friendly
    # type.
    #
    # @example Mongoize the object.
    #   Boolean.mongoize("123.11")
    # @return [true | false | nil] The object mongoized or nil.
    #
    # source://mongoid//lib/mongoid/extensions/boolean.rb#26
    def demongoize(object); end

    # Turn the object from the ruby type we deal with to a Mongo friendly
    # type.
    #
    # @example Mongoize the object.
    #   Boolean.mongoize("123.11")
    # @return [true | false | nil] The object mongoized or nil.
    #
    # source://mongoid//lib/mongoid/extensions/boolean.rb#18
    def mongoize(object); end
  end
end

# Encapsulates behavior around caching.
#
# source://mongoid//lib/mongoid/cacheable.rb#7
module Mongoid::Cacheable
  extend ::ActiveSupport::Concern

  # Print out the cache key. This will append different values on the
  # plural model name.
  #
  # If new_record?     - will append /new
  # If not             - will append /id-updated_at.to_formatted_s(cache_timestamp_format)
  # Without updated_at - will append /id
  #
  # This is usually called inside a cache() block
  #
  # @example Returns the cache key
  #   document.cache_key
  # @return [String] the string with or without updated_at
  #
  # source://mongoid//lib/mongoid/cacheable.rb#28
  def cache_key; end
end

# Defines behavior for dirty tracking.
#
# source://mongoid//lib/mongoid/changeable.rb#5
module Mongoid::Changeable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods

  # Returns the original value of an attribute before the last save.
  #
  # This method is useful in after callbacks to get the original value of
  #   an attribute before the save that triggered the callbacks to run.
  #
  # @param attr [Symbol | String] The name of the attribute.
  # @return [Object] Value of the attribute before the last save.
  #
  # source://mongoid//lib/mongoid/changeable.rb#150
  def attribute_before_last_save(attr); end

  # Get the changed attributes for the document.
  #
  # @example Get the changed attributes.
  #   model.changed
  # @return [Array<String>] The changed attributes.
  #
  # source://mongoid//lib/mongoid/changeable.rb#14
  def changed; end

  # Has the document changed?
  #
  # @example Has the document changed?
  #   model.changed?
  # @return [true | false] If the document is changed.
  #
  # source://mongoid//lib/mongoid/changeable.rb#32
  def changed?; end

  # Get the attribute changes.
  #
  # @example Get the attribute changes.
  #   model.changed_attributes
  # @return [Hash<String, Object>] The attribute changes.
  #
  # source://mongoid//lib/mongoid/changeable.rb#51
  def changed_attributes; end

  # Get all the changes for the document.
  #
  # @example Get all the changes.
  #   model.changes
  # @return [Hash<String, Array<Object, Object> ] The changes.] Hash<String, Array<Object, Object> ] The changes.
  #
  # source://mongoid//lib/mongoid/changeable.rb#61
  def changes; end

  # Have any children (embedded documents) of this document changed?
  #
  # @note This intentionally only considers children and not descendants.
  # @return [true | false] If any children have changed.
  #
  # source://mongoid//lib/mongoid/changeable.rb#41
  def children_changed?; end

  # Indicates that the children of this document may have changed, and
  # ought to be checked when the document is validated.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/changeable.rb#22
  def children_may_have_changed!; end

  # Call this method after save, so the changes can be properly switched.
  #
  # This will unset the memoized children array, set new record flag to
  # false, set the document as validated, and move the dirty changes.
  #
  # @example Move the changes to previous.
  #   person.move_changes
  #
  # source://mongoid//lib/mongoid/changeable.rb#75
  def move_changes; end

  # Things that need to execute after a document has been persisted.
  #
  # @example Handle post persistence.
  #   document.post_persist
  #
  # source://mongoid//lib/mongoid/changeable.rb#89
  def post_persist; end

  # Get the previous changes on the document.
  #
  # @example Get the previous changes.
  #   model.previous_changes
  # @return [Hash<String, Array<Object, Object> ] The previous changes.] Hash<String, Array<Object, Object> ] The previous changes.
  #
  # source://mongoid//lib/mongoid/changeable.rb#101
  def previous_changes; end

  # Remove a change from the dirty attributes hash. Used by the single field
  # atomic updaters.
  #
  # @example Remove a flagged change.
  #   model.remove_change(:field)
  # @param name [Symbol | String] The name of the field.
  #
  # source://mongoid//lib/mongoid/changeable.rb#112
  def remove_change(name); end

  # Returns the change to an attribute during the last save.
  #
  # @param attr [Symbol | String] The name of the attribute.
  # @return [Array<Object> | nil] If the attribute was changed, returns
  #   an array containing the original value and the saved value, otherwise nil.
  #
  # source://mongoid//lib/mongoid/changeable.rb#161
  def saved_change_to_attribute(attr); end

  # Returns whether this attribute changed during the last save.
  #
  # This method is useful in after callbacks, to see the change
  #   in an attribute during the save that triggered the callbacks to run.
  #
  # @param attr [String] The name of the attribute.
  # @param from [Object] The object the attribute was changed from (optional).
  # @param to [Object] The object the attribute was changed to (optional).
  # @return [true | false] Whether the attribute has changed during the last save.
  #
  # source://mongoid//lib/mongoid/changeable.rb#176
  def saved_change_to_attribute?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end

  # Gets all the new values for each of the changed fields, to be passed to
  # a MongoDB $set modifier.
  #
  # @example Get the setters for the atomic updates.
  #   person = Person.new(:title => "Sir")
  #   person.title = "Madam"
  #   person.setters # returns { "title" => "Madam" }
  # @return [Hash] A +Hash+ of atomic setters.
  #
  # source://mongoid//lib/mongoid/changeable.rb#125
  def setters; end

  # Returns whether this attribute change the next time we save.
  #
  # This method is useful in validations and before callbacks to determine
  #   if the next call to save will change a particular attribute.
  #
  # @option **kwargs
  # @option **kwargs
  # @param **kwargs The optional keyword arguments.
  # @param attr [String] The name of the attribute.
  # @return [true | false] Whether the attribute change the next time we save.
  #
  # source://mongoid//lib/mongoid/changeable.rb#199
  def will_save_change_to_attribute?(attr, **kwargs); end

  private

  # Get the old and new value for the provided attribute.
  #
  # @example Get the attribute change.
  #   model.attribute_change("name")
  # @param attr [String] The name of the attribute.
  # @return [Array<Object>] The old and new values.
  #
  # source://mongoid//lib/mongoid/changeable.rb#228
  def attribute_change(attr); end

  # Determine if a specific attribute has changed.
  #
  # @example Has the attribute changed?
  #   model.attribute_changed?("name")
  # @param attr [String] The name of the attribute.
  # @param from [Object] The object the attribute was changed from (optional).
  # @param to [Object] The object the attribute was changed to (optional).
  # @return [true | false] Whether the attribute has changed.
  #
  # source://mongoid//lib/mongoid/changeable.rb#266
  def attribute_changed?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end

  # Get whether or not the field has a different value from the default.
  #
  # @example Is the field different from the default?
  #   model.attribute_changed_from_default?
  # @param attr [String] The name of the attribute.
  # @return [true | false] If the attribute differs.
  #
  # source://mongoid//lib/mongoid/changeable.rb#284
  def attribute_changed_from_default?(attr); end

  # Get the previous attribute value that was changed
  # before the document was saved.
  #
  # It the document has not been saved yet, or was just loaded from database,
  # this method returns nil for all attributes.
  #
  # @param attr [String] The attribute name.
  # @return [Object | nil] Attribute value before the document was saved,
  #   or nil if the document has not been saved yet.
  #
  # source://mongoid//lib/mongoid/changeable.rb#311
  def attribute_previously_was(attr); end

  # Get the previous value for the attribute.
  #
  # @example Get the previous value.
  #   model.attribute_was("name")
  # @param attr [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#296
  def attribute_was(attr); end

  # Flag an attribute as going to change.
  #
  # @example Flag the attribute.
  #   model.attribute_will_change!("name")
  # @param attr [String] The name of the attribute.
  # @return [Object] The old value.
  #
  # source://mongoid//lib/mongoid/changeable.rb#328
  def attribute_will_change!(attr); end

  # source://mongoid//lib/mongoid/changeable.rb#216
  def attributes_before_last_save; end

  # source://mongoid//lib/mongoid/changeable.rb#212
  def changes_before_last_save; end

  # Get attributes of the document before the document was saved.
  #
  # @return [Hash] Previous attributes
  #
  # source://mongoid//lib/mongoid/changeable.rb#208
  def previous_attributes; end

  # Set the attribute back to its old value.
  #
  # @example Reset the attribute.
  #   model.reset_attribute!("name")
  # @param attr [String] The name of the attribute.
  # @return [Object] The old value.
  #
  # source://mongoid//lib/mongoid/changeable.rb#342
  def reset_attribute!(attr); end

  # source://mongoid//lib/mongoid/changeable.rb#347
  def reset_attribute_to_default!(attr); end

  # source://mongoid//lib/mongoid/changeable.rb#356
  def reset_attributes_before_type_cast; end
end

# a singleton object to represent an optional `to` or `from` value
# that was not explicitly provided to #attribute_changed?
#
# source://mongoid//lib/mongoid/changeable.rb#254
Mongoid::Changeable::ATTRIBUTE_UNCHANGED = T.let(T.unsafe(nil), Mongoid::Changeable::Anything)

# A class for representing the default value that an attribute was changed
# from or to.
#
# @api private
#
# source://mongoid//lib/mongoid/changeable.rb#237
class Mongoid::Changeable::Anything
  # `Anything` objects are always equal to everything. This simplifies
  # the logic for asking whether an attribute has changed or not. If the
  # `from` or `to` value is a `Anything` (because it was not
  # explicitly given), any comparison with it will suggest the value has
  # not changed.
  #
  # @api private
  # @param _other [Object] The object being compared with this object.
  # @return [true] Always returns true.
  #
  # source://mongoid//lib/mongoid/changeable.rb#247
  def ==(_other); end
end

# Class-level methods for changeable objects.
#
# source://mongoid//lib/mongoid/changeable.rb#361
module Mongoid::Changeable::ClassMethods
  private

  # Creates the dirty change accessor.
  #
  # @example Create the accessor.
  #   Model.create_dirty_change_accessor("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#392
  def create_dirty_change_accessor(name, meth); end

  # Creates the dirty change check.
  #
  # @example Create the check.
  #   Model.create_dirty_change_check("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#407
  def create_dirty_change_check(name, meth); end

  # Creates the dirty change flag.
  #
  # @example Create the flag.
  #   Model.create_dirty_change_flag("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#467
  def create_dirty_change_flag(name, meth); end

  # Creates the dirty default change check.
  #
  # @example Create the check.
  #   Model.create_dirty_default_change_check("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#425
  def create_dirty_default_change_check(name, meth); end

  # Generate all the dirty methods needed for the attribute.
  #
  # @example Generate the dirty methods.
  #   Model.create_dirty_methods("name", "name")
  # @param meth [String] The name of the accessor.
  # @param name [String] The name of the field.
  # @return [Module] The fields module.
  #
  # source://mongoid//lib/mongoid/changeable.rb#373
  def create_dirty_methods(name, meth); end

  # Creates the dirty change accessor.
  #
  # @example Create the dirty change accessor.
  #   Model.create_dirty_previous_change("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#527
  def create_dirty_previous_change(name, meth); end

  # Creates the dirty change previous value accessors.
  #
  # @example Create the accessor.
  #   Model.create_dirty_previous_value_accessor("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#440
  def create_dirty_previous_value_accessor(name, meth); end

  # Creates the dirty change check.
  #
  # @example Create the dirty change check.
  #   Model.create_dirty_previously_changed?("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/changeable.rb#512
  def create_dirty_previously_changed?(name, meth); end

  # Creates the dirty change reset.
  #
  # @example Create the reset.
  #   Model.create_dirty_reset("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#482
  def create_dirty_reset(name, meth); end

  # Creates the dirty change reset to default.
  #
  # @example Create the reset.
  #   Model.create_dirty_reset_to_default("name", "alias")
  # @param meth [String] The name of the accessor.
  # @param name [String] The attribute name.
  #
  # source://mongoid//lib/mongoid/changeable.rb#497
  def create_dirty_reset_to_default(name, meth); end
end

# Mixin module included into Mongoid::Document which adds
# database client connection functionality. Also contains
# singleton class methods related to managing database clients.
#
# source://mongoid//lib/mongoid/clients/factory.rb#5
module Mongoid::Clients
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods

  class << self
    # Clear all clients from the current thread.
    #
    # @example Clear all clients.
    #   Mongoid::Clients.clear
    # @return [Array] The empty clients.
    #
    # source://mongoid//lib/mongoid/clients.rb#29
    def clear; end

    # Returns the stored clients indexed by name.
    #
    # @return [Hash<Symbol, Mongo::Client>] The index of clients.
    #
    # source://mongoid//lib/mongoid/clients.rb#102
    def clients; end

    # Get the default client.
    #
    # @example Get the default client.
    #   Mongoid::Clients.default
    # @return [Mongo::Client] The default client.
    #
    # source://mongoid//lib/mongoid/clients.rb#39
    def default; end

    # Disconnect all active clients.
    #
    # @example Disconnect all active clients.
    #   Mongoid::Clients.disconnect
    # @return [true] True.
    #
    # source://mongoid//lib/mongoid/clients.rb#49
    def disconnect; end

    # Reconnect all active clients.
    #
    # @example Reconnect all active clients.
    #   Mongoid::Clients.reconnect
    # @return [true] True.
    #
    # source://mongoid//lib/mongoid/clients.rb#60
    def reconnect; end

    # Store a client with the provided name.
    #
    # @example Set a client.
    #   Mongoid::Clients.set(:analytics, my_client)
    # @param client [Mongo::Client] The client to set.
    # @param name [String | Symbol] The name of the client to set.
    # @return [Mongo::Client] The set client.
    #
    # source://mongoid//lib/mongoid/clients.rb#95
    def set(name, client); end

    # Get a stored client with the provided name. If no client exists
    # with the given name, a new one will be created, stored, and
    # returned.
    #
    # @example Get a client with the name.
    #   Mongoid::Clients.with_name(:replica)
    # @param name [String | Symbol] The name of the client.
    # @return [Mongo::Client] The named client.
    #
    # source://mongoid//lib/mongoid/clients.rb#75
    def with_name(name); end
  end

  module GeneratedClassMethods
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
  end

  module GeneratedInstanceMethods; end
end

# Factory used to create database clients.
#
# source://mongoid//lib/mongoid/clients/factory.rb#8
module Mongoid::Clients::Factory
  extend ::Mongoid::Clients::Factory
  extend ::Mongoid::Loggable

  # Create a new client given the named configuration. If no name is
  # provided, return a new client with the default configuration. If a
  # name is provided for which no configuration exists, an error will be
  # raised.
  #
  # @example Create the client.
  #   Factory.create(:analytics)
  # @param name [String | Symbol] The named client configuration.
  # @raise [Errors::NoClientConfig] If no config could be found.
  # @return [Mongo::Client] The new client.
  #
  # source://mongoid//lib/mongoid/clients/factory.rb#25
  def create(name = T.unsafe(nil)); end

  # Get the default client.
  #
  # @example Get the default client.
  #   Factory.default
  # @raise [Errors::NoClientConfig] If no default configuration is
  #   found.
  # @return [Mongo::Client] The default client.
  #
  # source://mongoid//lib/mongoid/clients/factory.rb#41
  def default; end

  private

  # Build auto encryption options for the client based on the options
  # provided in the Mongoid client configuration and the encryption
  # schema map for the database.
  #
  # @api private
  # @param database [String] Database name to use for encryption schema map.
  # @param opts [Hash] Options from the Mongoid client configuration.
  # @return [Hash | nil] Auto encryption options for the client.
  #
  # source://mongoid//lib/mongoid/clients/factory.rb#90
  def build_auto_encryption_options(opts, database); end

  # Create the client for the provided config.
  #
  # @api private
  # @example Create the client.
  #   Factory.create_client(config)
  # @param configuration [Hash] The client config.
  # @raise [Errors::NoClientsConfig]
  # @return [Mongo::Client] The client.
  #
  # source://mongoid//lib/mongoid/clients/factory.rb#57
  def create_client(configuration); end

  # source://mongoid//lib/mongoid/clients/factory.rb#115
  def driver_version; end

  # Prepare options for Mongo::Client based on Mongoid client configuration.
  #
  # @api private
  # @param opts [Hash] Parameters from options section of Mongoid client configuration.
  # @return [Hash] Options that should be passed to Mongo::Client constructor.
  #
  # source://mongoid//lib/mongoid/clients/factory.rb#125
  def options(opts); end
end

# source://mongoid//lib/mongoid/clients/factory.rb#110
Mongoid::Clients::Factory::MONGOID_WRAPPING_LIBRARY = T.let(T.unsafe(nil), Hash)

# Mixin module included into Mongoid::Document which gives
# the ability to manage the database context for persistence
# and query operations. For example, this includes saving
# documents to different collections, and reading documents
# from secondary instances.
#
# source://mongoid//lib/mongoid/clients/options.rb#12
module Mongoid::Clients::Options
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods

  # Get the collection for the document's current persistence context.
  #
  # @example Get the collection for the current persistence context.
  #   document.collection
  # @param parent [Object] The parent object whose collection name is used
  #   instead of the current persistence context's collection name.
  # @return [Mongo::Collection] The collection for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#47
  def collection(parent = T.unsafe(nil)); end

  # Get the collection name for the document's current persistence context.
  #
  # @example Get the collection name for the current persistence context.
  #   document.collection_name
  # @return [String] The collection name for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#58
  def collection_name; end

  # Get the database client for the document's current persistence context.
  #
  # @example Get the client for the current persistence context.
  #   document.mongo_client
  # @return [Mongo::Client] The client for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#69
  def mongo_client; end

  # Get the document's current persistence context.
  #
  # @example Get the current persistence context.
  #   document.persistence_context
  # @note For embedded documents, the persistence context of the
  #   root parent document is returned.
  # @return [Mongoid::PersistenceContext] The current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#83
  def persistence_context; end

  # Returns whether a persistence context is set for the document
  # or the document's class.
  #
  # @example Get the current persistence context.
  #   document.persistence_context?
  # @note For embedded documents, the persistence context of the
  #   root parent document is used.
  # @return [true | false] Whether a persistence context is set.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#103
  def persistence_context?; end

  # Change the persistence context for this object during the block.
  #
  # @example Save the current document to a different collection.
  #   model.with(collection: "bands") do |m|
  #   m.save
  #   end
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @param options_or_context [Hash | Mongoid::PersistenceContext] The storage options or a persistence context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#28
  def with(options_or_context, &block); end

  private

  # source://mongoid//lib/mongoid/clients/options.rb#132
  def clear_persistence_context(original_cluster = T.unsafe(nil), context = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/clients/options.rb#115
  def default_storage_options; end

  # source://mongoid//lib/mongoid/clients/options.rb#128
  def set_persistence_context(options_or_context); end
end

# source://mongoid//lib/mongoid/clients/options.rb#136
module Mongoid::Clients::Options::ClassMethods
  # Get the database client name for the current persistence context
  # of the document class.
  #
  # @example Get the client name for the current persistence context.
  #   Model.client_name
  # @return [String] The database client name for the current
  #   persistence context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#146
  def client_name; end

  # Get the collection for the current persistence context of the
  # document class.
  #
  # @example Get the collection for the current persistence context.
  #   Model.collection
  # @return [Mongo::Collection] The collection for the current
  #   persistence context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#182
  def collection; end

  # Get the collection name for the current persistence context of the
  # document class.
  #
  # @example Get the collection name for the current persistence context.
  #   Model.collection_name
  # @return [String] The collection name for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#158
  def collection_name; end

  # Get the database name for the current persistence context of the
  # document class.
  #
  # @example Get the database name for the current persistence context.
  #   Model.database_name
  # @return [String] The database name for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#170
  def database_name; end

  # Get the client for the current persistence context of the
  # document class.
  #
  # @example Get the client for the current persistence context.
  #   Model.mongo_client
  # @return [Mongo::Client] The client for the current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#194
  def mongo_client; end

  # Get the current persistence context of the document class.
  # If a persistence context is not set, a new one will be
  # initialized and returned.
  #
  # @example Get the current persistence context.
  #   Model.persistence_context
  # @return [Mongoid::PersistenceContent] The current persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#228
  def persistence_context; end

  # Change the persistence context for this class during the block.
  #
  # @example Save the current document to a different collection.
  #   Model.with(collection: "bands") do |m|
  #   m.create
  #   end
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The storage options.
  #
  # source://mongoid//lib/mongoid/clients/options.rb#210
  def with(options, &block); end
end

# Encapsulates behavior for using sessions and transactions.
#
# source://mongoid//lib/mongoid/clients/sessions.rb#8
module Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods

  private

  # If at least one session is active, this ensures that the
  # current model's client is compatible with one of them.
  #
  # "Compatible" is defined to mean: the same client was used
  # to open one of the active sessions.
  #
  # Currently emits a warning.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#263
  def ensure_client_compatibility!; end

  class << self
    # Add class method mixin functionality.
    #
    # @todo Replace with ActiveSupport::Concern
    #
    # source://mongoid//lib/mongoid/clients/sessions.rb#13
    def included(base); end
  end
end

# source://mongoid//lib/mongoid/clients/sessions.rb#17
module Mongoid::Clients::Sessions::ClassMethods
  # Sets up a callback is called after a commit of a transaction.
  # The callback is called only if the document is created, updated, or destroyed
  # in the transaction.
  #
  # See +ActiveSupport::Callbacks::ClassMethods::set_callback+ for more
  # information about method parameters and possible options.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#119
  def after_commit(*args, &block); end

  # Shortcut for +after_commit :hook, on: :create+.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#131
  def after_create_commit(*args, &block); end

  # Shortcut for +after_commit :hook, on: :destroy+.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#143
  def after_destroy_commit(*args, &block); end

  # This callback is called after a create, update, or destroy are rolled back.
  #
  # Please check the documentation of +after_commit+ for options.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#151
  def after_rollback(*args, &block); end

  # Shortcut for +after_commit :hook, on: [ :create, :update ]+
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#125
  def after_save_commit(*args, &block); end

  # Shortcut for +after_commit :hook, on: :update+.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#137
  def after_update_commit(*args, &block); end

  # Executes a block within the context of a transaction.
  #
  # If the block does not raise an error, the transaction is committed.
  # If an error is raised, the transaction is aborted. The error is passed on
  # except for the `Mongoid::Errors::Rollback`. This error is not passed on,
  # so you can raise is if you want to deliberately rollback the transaction.
  #
  # @param options [Hash] The transaction options. Please see the driver
  #   documentation for the available session options.
  # @param session_options [Hash] The session options. A MongoDB
  #   transaction must be started inside a session, therefore a session will
  #   be started. Please see the driver documentation for the available session options.
  # @raise [Mongoid::Errors::InvalidTransactionNesting] If the transaction is
  #   opened on a client that already has an open transaction.
  # @raise [Mongoid::Errors::TransactionsNotSupported] If MongoDB deployment
  #   the client is connected to does not support transactions.
  # @raise [Mongoid::Errors::TransactionError] If there is an error raised
  #   by MongoDB deployment or MongoDB driver.
  # @yield Provided block will be executed inside a transaction.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#90
  def transaction(options = T.unsafe(nil), session_options: T.unsafe(nil)); end

  # Execute a block within the context of a session.
  #
  # @example Execute some operations in the context of a session.
  #   Band.with_session(causal_consistency: true) do
  #   band = Band.create
  #   band.records << Record.new
  #   band.save
  #   band.reload.records
  #   end
  # @param options [Hash] The session options. Please see the driver
  #   documentation for the available session options.
  # @raise [Errors::InvalidSessionUse] If an operation is attempted on a model using another
  #   client from which the session was started or if sessions are nested.
  # @return [Object] The result of calling the block.
  # @yieldparam The [Mongo::Session] session being used for the block.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#42
  def with_session(options = T.unsafe(nil)); end

  private

  # @return [Mongo::Session] Session for the current client.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#175
  def _session; end

  # Asserts that the given actions are valid for after_commit
  # and after_rollback callbacks.
  #
  # @param actions [Array<Symbol>] Actions to be checked.
  # @raise [ArgumentError] If any of the actions is not valid.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#234
  def assert_valid_transaction_action(actions); end

  # This method should be used to detect whether a persistence operation
  # is executed inside transaction or not.
  #
  # Currently this method is used to detect when +after_commit+ callbacks
  # should be triggered. If we introduce implicit transactions and
  # therefore do not need to handle two different ways of triggering callbacks,
  # we may want to remove this method.
  #
  # @return [true | false] Whether there is a session for the current
  #   client, and there is a transaction in progress for this session.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#189
  def in_transaction?; end

  # Runs after_rollback callbacks on modified documents.
  #
  # @param session [Mongo::Session] Session on which
  #   a transaction is started.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#207
  def run_abort_callbacks(session); end

  # Runs after_commit callbacks on modified documents.
  #
  # @param session [Mongo::Session] Session on which
  #   a transaction is started.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#197
  def run_commit_callbacks(session); end

  # Transforms custom options for after_commit and after_rollback callbacks
  # into options for +set_callback+.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#215
  def set_options_for_callbacks!(args, enforced_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#240
  def transaction_include_any_action?(actions); end

  # Driver version 2.20 introduced a new exception for reporting that
  # transactions are not supported. Prior to that, the condition was
  # discovered by the rescue clause falling through to a different
  # exception.
  #
  # This method ensures that Mongoid continues to work with older driver
  # versions, by only returning the new exception.
  #
  # Once support is removed for all versions prior to 2.20.0, we can
  # replace this method.
  #
  # source://mongoid//lib/mongoid/clients/sessions.rb#168
  def transactions_not_supported_exceptions; end
end

# Actions that can be used to trigger transactional callbacks.
#
# @api private
#
# source://mongoid//lib/mongoid/clients/sessions.rb#21
Mongoid::Clients::Sessions::ClassMethods::CALLBACK_ACTIONS = T.let(T.unsafe(nil), Array)

# Mixin module included into Mongoid::Document which adds
# the ability to set the collection in which to store the
# document by default.
#
# source://mongoid//lib/mongoid/clients/storage_options.rb#10
module Mongoid::Clients::StorageOptions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods

  # Saves the storage options from the current persistence context.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#41
  def remember_storage_options!; end

  # Remembers the storage options that were active when the current object
  # was instantiated/created.
  #
  # @api private
  # @return [Hash | nil] the storage options that have been cached for
  #   this object instance (or nil if no storage options have been
  #   cached).
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#25
  def remembered_storage_options; end

  # Remembers the storage options that were active when the current object
  # was instantiated/created.
  #
  # @api private
  # @return [Hash | nil] the storage options that have been cached for
  #   this object instance (or nil if no storage options have been
  #   cached).
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#25
  def remembered_storage_options=(_arg0); end

  # The storage options that apply to this record, consisting of both
  # the class-level declared storage options (e.g. store_in) merged with
  # any remembered storage options.
  #
  # @api private
  # @return [Hash] the storage options for the record
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#34
  def storage_options; end

  module GeneratedClassMethods
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
  end

  module GeneratedInstanceMethods; end
end

# source://mongoid//lib/mongoid/clients/storage_options.rb#48
module Mongoid::Clients::StorageOptions::ClassMethods
  # Reset the store_in options
  #
  # @example Reset the store_in options
  #   Model.reset_storage_options!
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#92
  def reset_storage_options!; end

  # Get the default storage options.
  #
  # @example Get the default storage options.
  #   Model.storage_options_defaults
  # @return [Hash] Default storage options.
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#103
  def storage_options_defaults; end

  # Give this model specific custom default storage options.
  #
  # @example Store this model by default in "artists"
  #   class Band
  #   include Mongoid::Document
  #   store_in collection: "artists"
  #   end
  # @example Store this model by default in a different client.
  #   class Band
  #   include Mongoid::Document
  #   store_in client: "analytics"
  #   end
  # @example Store this model by default in the sharded db.
  #   class Band
  #   include Mongoid::Document
  #   store_in database: "echo_shard"
  #   end
  # @example Store this model with a combination of options.
  #   class Band
  #   include Mongoid::Document
  #   store_in collection: "artists", database: "music"
  #   end
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The storage options.
  # @return [Class] The model class.
  #
  # source://mongoid//lib/mongoid/clients/storage_options.rb#83
  def store_in(options); end
end

# source://mongoid//lib/mongoid/clients/validators/storage.rb#6
module Mongoid::Clients::Validators; end

# Validates the options passed to :store_in.
#
# source://mongoid//lib/mongoid/clients/validators/storage.rb#9
module Mongoid::Clients::Validators::Storage
  extend ::Mongoid::Clients::Validators::Storage

  # Validate the options provided to :store_in.
  #
  # @example Validate the options.
  #   Storage.validate(:collection_name)
  # @param klass [Class] The model class.
  # @param options [Hash | String | Symbol] The provided options.
  #
  # source://mongoid//lib/mongoid/clients/validators/storage.rb#22
  def validate(klass, options); end

  private

  # Determine if all keys in the options hash are valid.
  #
  # @api private
  # @example Are all keys valid?
  #   validator.valid_keys?({ collection: "name" })
  # @param options [Hash] The options hash.
  # @return [true | false] If all keys are valid.
  #
  # source://mongoid//lib/mongoid/clients/validators/storage.rb#38
  def valid_keys?(options); end
end

# The valid options for storage.
#
# source://mongoid//lib/mongoid/clients/validators/storage.rb#13
Mongoid::Clients::Validators::Storage::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# Encapsulates behavior around defining collections.
#
# source://mongoid//lib/mongoid/collection_configurable.rb#7
module Mongoid::CollectionConfigurable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
end

# source://mongoid//lib/mongoid/collection_configurable.rb#10
module Mongoid::CollectionConfigurable::ClassMethods
  # Create the collection for the called upon Mongoid model.
  #
  # This method does not re-create existing collections.
  #
  # If the document includes `store_in` macro with `collection_options` key,
  #   these options are used when creating the collection.
  #
  # @param force [true | false] If true, the method will drop existing
  #   collections before creating new ones. If false, the method will create
  #   only new collection (that do not exist in the database).
  # @raise [Errors::CreateCollectionFailure] If collection creation failed.
  # @raise [Errors::DropCollectionFailure] If an attempt to drop collection failed.
  #
  # source://mongoid//lib/mongoid/collection_configurable.rb#24
  def create_collection(force: T.unsafe(nil)); end
end

# This module provides inclusions of all behavior in a Mongoid document.
#
# source://mongoid//lib/mongoid/composable.rb#29
module Mongoid::Composable
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::Mongoid::Evolvable
  include ::Mongoid::Inspectable
  include ::Mongoid::Reloadable
  include ::Mongoid::Stateful
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::Model
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Validatable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Interceptable
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods
  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods
  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods
  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods
  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods
  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::Mongoid::Equality::ClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods
  mixes_in_class_methods ::Mongoid::Findable
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  class << self
    # Get a list of methods that would be a bad idea to define as field names
    # or override when including Mongoid::Document.
    #
    # @example Bad thing!
    #   Mongoid::Components.prohibited_methods
    # @return [Array<Symbol>]
    #
    # source://mongoid//lib/mongoid/composable.rb#130
    def prohibited_methods; end
  end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter; end
    def param_delimiter=(value); end
    def param_delimiter?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter=(value); end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

# source://mongoid//lib/mongoid/composable.rb#70
Mongoid::Composable::MODULES = T.let(T.unsafe(nil), Array)

# These are methods names defined in included blocks that may conflict
# with user-defined association or field names.
# They won't be in the list of Module.instance_methods on which the
# #prohibited_methods code below is dependent so we must track them
# separately.
#
# @return [Array<Symbol>] A list of reserved method names.
#
# source://mongoid//lib/mongoid/composable.rb#108
Mongoid::Composable::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Array)

# This module defines all the configuration options for Mongoid, including
# the database connections.
#
# source://mongoid//lib/mongoid/config/defaults.rb#5
module Mongoid::Config
  include ::Mongoid::Config::DeprecatedOptions
  extend ::Forwardable
  extend ::Mongoid::Config::Options
  extend ::Mongoid::Config::Defaults
  extend ::Mongoid::Config::Encryption
  extend ::Mongoid::Config
  extend ::Mongoid::Config::DeprecatedOptions

  # source://mongoid//lib/mongoid/config.rb#90
  def allow_bson5_decimal128; end

  # source://mongoid//lib/mongoid/config.rb#90
  def allow_bson5_decimal128=(value); end

  # source://mongoid//lib/mongoid/config.rb#90
  def allow_bson5_decimal128?; end

  # source://mongoid//lib/mongoid/config.rb#181
  def allow_scopes_to_unset_default_scope; end

  # source://mongoid//lib/mongoid/config.rb#181
  def allow_scopes_to_unset_default_scope=(value); end

  # source://mongoid//lib/mongoid/config.rb#181
  def allow_scopes_to_unset_default_scope?; end

  # source://mongoid//lib/mongoid/config.rb#30
  def app_name; end

  # source://mongoid//lib/mongoid/config.rb#30
  def app_name=(value); end

  # source://mongoid//lib/mongoid/config.rb#30
  def app_name?; end

  # source://mongoid//lib/mongoid/config.rb#172
  def around_callbacks_for_embeds; end

  # source://mongoid//lib/mongoid/config.rb#172
  def around_callbacks_for_embeds=(value); end

  # source://mongoid//lib/mongoid/config.rb#172
  def around_callbacks_for_embeds?; end

  # source://mongoid//lib/mongoid/config.rb#106
  def async_query_executor; end

  # source://mongoid//lib/mongoid/config.rb#106
  def async_query_executor=(value); end

  # source://mongoid//lib/mongoid/config.rb#106
  def async_query_executor?; end

  # source://mongoid//lib/mongoid/config.rb#34
  def background_indexing; end

  # source://mongoid//lib/mongoid/config.rb#34
  def background_indexing=(value); end

  # source://mongoid//lib/mongoid/config.rb#34
  def background_indexing?; end

  # source://mongoid//lib/mongoid/config.rb#39
  def belongs_to_required_by_default; end

  # source://mongoid//lib/mongoid/config.rb#39
  def belongs_to_required_by_default=(value); end

  # source://mongoid//lib/mongoid/config.rb#39
  def belongs_to_required_by_default?; end

  # Get the client configuration or an empty hash.
  #
  # @example Get the clients configuration.
  #   config.clients
  # @return [Hash] The clients configuration.
  #
  # source://mongoid//lib/mongoid/config.rb#368
  def clients; end

  # Returns the Config singleton, for use in the configure DSL.
  #
  # @return [self] The Config singleton.
  #
  # source://mongoid//lib/mongoid/config.rb#186
  def config; end

  # Has Mongoid been configured? This is checking that at least a valid
  # client config exists.
  #
  # @example Is Mongoid configured?
  #   config.configured?
  # @return [true | false] If Mongoid is configured.
  #
  # source://mongoid//lib/mongoid/config.rb#197
  def configured?; end

  # Connect to the provided database name on the default client.
  #
  # @example Set the database to connect to.
  #   config.connect_to("mongoid_test")
  # @note Use only in development or test environments for convenience.
  # @param name [String] The database name.
  #
  # source://mongoid//lib/mongoid/config.rb#209
  def connect_to(name, options = T.unsafe(nil)); end

  # Deregister a model in the application with Mongoid.
  #
  # @api private
  # @param klass [Class] The model to deregister.
  #
  # source://mongoid//lib/mongoid/config.rb#276
  def deregister_model(klass); end

  # Return field names that could cause destructive things to happen if
  # defined in a Mongoid::Document.
  #
  # @example Get the destructive fields.
  #   config.destructive_fields
  # @return [Array<String>] An array of bad field names.
  #
  # source://mongoid//lib/mongoid/config.rb#226
  def destructive_fields; end

  # source://mongoid//lib/mongoid/config.rb#42
  def discriminator_key; end

  # source://mongoid//lib/mongoid/config.rb#42
  def discriminator_key=(value); end

  # source://mongoid//lib/mongoid/config.rb#42
  def discriminator_key?; end

  # source://mongoid//lib/mongoid/config.rb#45
  def duplicate_fields_exception; end

  # source://mongoid//lib/mongoid/config.rb#45
  def duplicate_fields_exception=(value); end

  # source://mongoid//lib/mongoid/config.rb#45
  def duplicate_fields_exception?; end

  # source://mongoid//lib/mongoid/config.rb#111
  def global_executor_concurrency; end

  # source://mongoid//lib/mongoid/config.rb#111
  def global_executor_concurrency=(value); end

  # source://mongoid//lib/mongoid/config.rb#111
  def global_executor_concurrency?; end

  # source://mongoid//lib/mongoid/config.rb#152
  def immutable_ids; end

  # source://mongoid//lib/mongoid/config.rb#152
  def immutable_ids=(value); end

  # source://mongoid//lib/mongoid/config.rb#152
  def immutable_ids?; end

  # source://mongoid//lib/mongoid/config.rb#48
  def include_root_in_json; end

  # source://mongoid//lib/mongoid/config.rb#48
  def include_root_in_json=(value); end

  # source://mongoid//lib/mongoid/config.rb#48
  def include_root_in_json?; end

  # source://mongoid//lib/mongoid/config.rb#51
  def include_type_for_serialization; end

  # source://mongoid//lib/mongoid/config.rb#51
  def include_type_for_serialization=(value); end

  # source://mongoid//lib/mongoid/config.rb#51
  def include_type_for_serialization?; end

  # source://mongoid//lib/mongoid/config.rb#55
  def join_contexts; end

  # source://mongoid//lib/mongoid/config.rb#55
  def join_contexts=(value); end

  # source://mongoid//lib/mongoid/config.rb#55
  def join_contexts?; end

  # source://mongoid//lib/mongoid/config.rb#145
  def legacy_persistence_context_behavior; end

  # source://mongoid//lib/mongoid/config.rb#145
  def legacy_persistence_context_behavior=(value); end

  # source://mongoid//lib/mongoid/config.rb#145
  def legacy_persistence_context_behavior?; end

  # source://mongoid//lib/mongoid/config.rb#121
  def legacy_readonly; end

  # source://mongoid//lib/mongoid/config.rb#121
  def legacy_readonly=(value); end

  # source://mongoid//lib/mongoid/config.rb#121
  def legacy_readonly?; end

  # Load the settings from a compliant mongoid.yml file. This can be used for
  # easy setup with frameworks other than Rails.
  #
  # @example Configure Mongoid.
  #   Mongoid.load!("/path/to/mongoid.yml")
  # @param environment [String | Symbol] The environment to load.
  # @param path [String] The path to the file.
  #
  # source://mongoid//lib/mongoid/config.rb#238
  def load!(path, environment = T.unsafe(nil)); end

  # From a hash of settings, load all the configuration.
  #
  # @example Load the configuration.
  #   config.load_configuration(settings)
  # @param settings [Hash] The configuration settings.
  #
  # source://mongoid//lib/mongoid/config.rb#288
  def load_configuration(settings); end

  # source://mongoid//lib/mongoid/config.rb#65
  def log_level=(value); end

  # source://mongoid//lib/mongoid/config.rb#65
  def log_level?; end

  # source://mongoid//lib/mongoid/config.rb#22
  def logger(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/config.rb#22
  def logger=(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/config.rb#81
  def map_big_decimal_to_decimal128; end

  # source://mongoid//lib/mongoid/config.rb#81
  def map_big_decimal_to_decimal128=(value); end

  # source://mongoid//lib/mongoid/config.rb#81
  def map_big_decimal_to_decimal128?; end

  # Get all the models in the application - this is everything that includes
  # Mongoid::Document.
  #
  # @example Get all the models.
  #   config.models
  # @return [Array<Class>] All the models in the application.
  #
  # source://mongoid//lib/mongoid/config.rb#255
  def models; end

  # Set the configuration options. Will validate each one individually.
  #
  # @example Set the options.
  #   config.options = { raise_not_found_error: true }
  # @param options [Hash] The configuration options.
  #
  # source://mongoid//lib/mongoid/config.rb#352
  def options=(options); end

  # Override the client to use globally.
  #
  # @example Override the client globally.
  #   config.override_client(:optional)
  # @param name [String | Symbol] The name of the client.
  # @return [String | Symbol] The global override.
  #
  # source://mongoid//lib/mongoid/config.rb#316
  def override_client(name); end

  # Override the database to use globally.
  #
  # @example Override the database globally.
  #   config.override_database(:optional)
  # @param name [String | Symbol] The name of the database.
  # @return [String | Symbol] The global override.
  #
  # source://mongoid//lib/mongoid/config.rb#304
  def override_database(name); end

  # source://mongoid//lib/mongoid/config.rb#68
  def preload_models; end

  # source://mongoid//lib/mongoid/config.rb#68
  def preload_models=(value); end

  # source://mongoid//lib/mongoid/config.rb#68
  def preload_models?; end

  # source://mongoid//lib/mongoid/config.rb#162
  def prevent_multiple_calls_of_embedded_callbacks; end

  # source://mongoid//lib/mongoid/config.rb#162
  def prevent_multiple_calls_of_embedded_callbacks=(value); end

  # source://mongoid//lib/mongoid/config.rb#162
  def prevent_multiple_calls_of_embedded_callbacks?; end

  # Purge all data in all collections, including indexes.
  #
  # @example Purge all data.
  #   Mongoid::Config.purge!
  # @note This is the fastest way to drop all data.
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/config.rb#328
  def purge!; end

  # source://mongoid//lib/mongoid/config.rb#71
  def raise_not_found_error; end

  # source://mongoid//lib/mongoid/config.rb#71
  def raise_not_found_error=(value); end

  # source://mongoid//lib/mongoid/config.rb#71
  def raise_not_found_error?; end

  # Register a model in the application with Mongoid.
  #
  # @example Register a model.
  #   config.register_model(Band)
  # @param klass [Class] The model to register.
  #
  # source://mongoid//lib/mongoid/config.rb#265
  def register_model(klass); end

  # Is the application running under passenger?
  #
  # @deprecated
  # @example Is the application using passenger?
  #   config.running_with_passenger?
  # @return [true | false] If the app is deployed on Passenger.
  #
  # source://mongoid//lib/mongoid/config.rb#390
  def running_with_passenger?(*args, **_arg1, &block); end

  # source://mongoid//lib/mongoid/config.rb#75
  def scope_overwrite_exception; end

  # source://mongoid//lib/mongoid/config.rb#75
  def scope_overwrite_exception=(value); end

  # source://mongoid//lib/mongoid/config.rb#75
  def scope_overwrite_exception?; end

  # Get the time zone to use.
  #
  # @example Get the time zone.
  #   Config.time_zone
  # @return [String] The time zone.
  #
  # source://mongoid//lib/mongoid/config.rb#378
  def time_zone; end

  # Truncate all data in all collections, but not the indexes.
  #
  # @example Truncate all collection data.
  #   Mongoid::Config.truncate!
  # @note This will be slower than purge!
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/config.rb#340
  def truncate!; end

  # source://mongoid//lib/mongoid/config.rb#78
  def use_utc; end

  # source://mongoid//lib/mongoid/config.rb#78
  def use_utc=(value); end

  # source://mongoid//lib/mongoid/config.rb#78
  def use_utc?; end

  private

  # @raise [Errors::NoClientsConfig]
  #
  # source://mongoid//lib/mongoid/config.rb#403
  def clients=(clients); end

  # Get database client that respects global overrides
  # Config.override_database and Config.override_client.
  #
  # @return [Mongo::Client] Client according to global overrides.
  #
  # source://mongoid//lib/mongoid/config.rb#414
  def global_client; end

  # source://mongoid//lib/mongoid/config.rb#398
  def set_log_levels; end
end

# Encapsulates logic for loading defaults.
#
# source://mongoid//lib/mongoid/config/defaults.rb#8
module Mongoid::Config::Defaults
  # Load the defaults for the feature flags in the given Mongoid version.
  # Note that this method will load the *new* functionality introduced in
  # the given Mongoid version.
  #
  # raises [ ArgumentError ] if an invalid version is given.
  #
  # @param version [String | Float] The version number as X.y.
  #
  # source://mongoid//lib/mongoid/config/defaults.rb#17
  def load_defaults(version); end
end

# source://mongoid//lib/mongoid/config.rb#427
module Mongoid::Config::DeprecatedOptions; end

# source://mongoid//lib/mongoid/config.rb#428
Mongoid::Config::DeprecatedOptions::OPTIONS = T.let(T.unsafe(nil), Array)

# This module contains the logic for configuring Client Side
# Field Level automatic encryption.
#
# @api private
#
# source://mongoid//lib/mongoid/config/encryption.rb#13
module Mongoid::Config::Encryption
  extend ::Mongoid::Config::Encryption

  # Generate the encryption schema map for the provided models.
  #
  # @api private
  # @param default_database [String] The default database name.
  # @param models [Array<Mongoid::Document>] The models to generate the schema map for.
  #   Defaults to all models in the application.
  # @return [Hash] The encryption schema map.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#23
  def encryption_schema_map(default_database, models = T.unsafe(nil)); end

  private

  # Get the encryption algorithm to use for the provided field.
  #
  # @api private
  # @param field [Mongoid::Field] The field to get the algorithm for.
  # @return [String] The algorithm.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#179
  def algorithm_for(field); end

  # Get the BSON type identifier for the provided field according to the
  # https://www.mongodb.com/docs/manual/reference/bson-types/#std-label-bson-types
  #
  # @api private
  # @param field [Mongoid::Field] The field to get the BSON type identifier for.
  # @return [String] The BSON type identifier.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#170
  def bson_type_for(field); end

  # Get the keyId encryption schema field for the base64 encrypted
  # key id.
  #
  # @api private
  # @param key_id_base64 [String | nil] The base64 encoded key id.
  # @param key_name_field [String | nil] The name of the key name field.
  # @return [Array<BSON::Binary> | String | nil] The keyId encryption schema field,
  #   JSON pointer to the field that contains keyAltName,
  #   or nil if both key_id_base64 and key_name_field are nil.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#199
  def key_id_for(key_id_base64, key_name_field); end

  # Generate the encryptMetadata object for the provided model.
  #
  # @api private
  # @param model [Mongoid::Document] The model to generate the metadata for.
  # @return [Hash] The encryptMetadata object.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#74
  def metadata_for(model); end

  # Generate encryption properties for the provided model.
  #
  # This method generates the properties for the fields and relations that
  # are marked as encrypted.
  #
  # @api private
  # @param model [Mongoid::Document] The model to generate the properties for.
  # @param visited [Set<Mongoid::Document>] The set of models that have already been visited.
  # @return [Hash] The encryption properties.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#106
  def properties_for(model, visited); end

  # Generate encryption properties for the fields of the provided model.
  #
  # @api private
  # @param model [Mongoid::Document] The model to generate the properties for.
  # @return [Hash] The encryption properties.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#120
  def properties_for_fields(model); end

  # Generate encryption properties for the relations of the provided model.
  #
  # This method generates the properties for the embedded relations that
  # are configured to be encrypted.
  #
  # @api private
  # @param model [Mongoid::Document] The model to generate the properties for.
  # @param visited [Set<Mongoid::Document>] The set of models that have already been visited.
  # @return [Hash] The encryption properties.
  #
  # source://mongoid//lib/mongoid/config/encryption.rb#147
  def properties_for_relations(model, visited); end
end

# The algorithm to use for the deterministic encryption.
#
# @api private
#
# source://mongoid//lib/mongoid/config/encryption.rb#41
Mongoid::Config::Encryption::DETERMINISTIC_ALGORITHM = T.let(T.unsafe(nil), String)

# The algorithm to use for the non-deterministic encryption.
#
# @api private
#
# source://mongoid//lib/mongoid/config/encryption.rb#44
Mongoid::Config::Encryption::RANDOM_ALGORITHM = T.let(T.unsafe(nil), String)

# The mapping of Mongoid field types to BSON type identifiers.
#
# @api private
#
# source://mongoid//lib/mongoid/config/encryption.rb#47
Mongoid::Config::Encryption::TYPE_MAPPINGS = T.let(T.unsafe(nil), Hash)

# Encapsulates logic for getting environment information.
#
# source://mongoid//lib/mongoid/config/environment.rb#8
module Mongoid::Config::Environment
  extend ::Mongoid::Config::Environment

  # Get the name of the environment that Mongoid is running under.
  #
  # Uses the following sources in order:
  # - If +::Rails+ is defined, +Rails.env+.
  # - If +::Sinatra+ is defined, +Sinatra::Base.environment+.
  # - +RACK_ENV+
  # - +MONGOID_ENV*
  #
  # @api public
  # @example Get the env name.
  #   Environment.env_name
  # @raise [Errors::NoEnvironment] If environment name cannot be
  #   determined because none of the sources was set.
  # @return [String] The name of the current environment.
  #
  # source://mongoid//lib/mongoid/config/environment.rb#27
  def env_name; end

  # Load the yaml from the provided path and return the settings for the
  # specified environment, or for the current Mongoid environment.
  #
  # @api private
  # @example Load the yaml.
  #   Environment.load_yaml("/work/mongoid.yml")
  # @param environment [String | Symbol] Optional environment name to
  #   override the current Mongoid environment.
  # @param path [String] The location of the file.
  # @return [Hash] The settings.
  #
  # source://mongoid//lib/mongoid/config/environment.rb#50
  def load_yaml(path, environment = T.unsafe(nil)); end
end

# This module provides a way to inspect not only the defined configuration
# settings and their defaults (which are available via
# `Mongoid::Config.settings`), but also the documentation about them. It
# does this by scraping the `mongoid/config.rb` file with a regular
# expression to match comments with options.
#
# @api private
#
# source://mongoid//lib/mongoid/config/introspection.rb#14
module Mongoid::Config::Introspection
  extend ::Mongoid::Config::Introspection

  # Extracts the available configuration options from the Mongoid::Config
  # source file, and returns them as an array of hashes.
  #
  # @api private
  # @param include_deprecated [true | false] Whether deprecated options
  #   should be included in the list. (Default: false)
  # @return [Array<Introspection::Option>] ] the array of option objects
  #   representing each defined option, in alphabetical order by name.
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#142
  def options(include_deprecated: T.unsafe(nil)); end
end

# The full path to the source file of the Mongoid::Config module.
#
# @api private
#
# source://mongoid//lib/mongoid/config/introspection.rb#131
Mongoid::Config::Introspection::CONFIG_RB_PATH = T.let(T.unsafe(nil), String)

# A regular expression that looks for option declarations of the format:
#
#   # one or more lines of comments,
#   # followed immediately by an option
#   # declaration with a default value:
#   option :option_name, default: "something"
#
# The regex produces three captures:
#
#   1: the (potentially multiline) comment
#   2: the option's name
#   3: the option's default value
#
# @api private
#
# source://mongoid//lib/mongoid/config/introspection.rb#120
Mongoid::Config::Introspection::OPTION_PATTERN = T.let(T.unsafe(nil), Regexp)

# A helper class to represent an individual option, its name, its
# default value, and the comment that documents it.
#
# @api private
#
# source://mongoid//lib/mongoid/config/introspection.rb#19
class Mongoid::Config::Introspection::Option
  # Create a new Option instance with the given name, default value,
  # and comment.
  #
  # @api private
  # @param comment [String] The multi-line comment describing the
  #   option.
  # @param default [String] The option's default value, as a String
  #   representing the actual Ruby value.
  # @param name [String] The option's name.
  # @return [Option] a new instance of Option
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#58
  def initialize(name, default, comment); end

  # Compare self with the given option.
  #
  # @api private
  # @return [true | false] If name, default, and comment are all the
  #   same, return true. Otherwise, false.
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#89
  def ==(option); end

  # The comment that describes this option, as scraped from
  # mongoid/config.rb.
  #
  # @api private
  # @return [String] The (possibly multi-line) comment. Each line is
  #   prefixed with the Ruby comment character ("#").
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#36
  def comment; end

  # The default value of this option.
  #
  # @api private
  # @return [Object] The default value of the option, typically a
  #   String, Symbol, nil, true, or false.
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#29
  def default; end

  # Reports whether or not the text "(Deprecated)" is present in the
  # option's comment.
  #
  # @api private
  # @return [true | false] whether the option is deprecated or not.
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#81
  def deprecated?; end

  # Indent the comment by the requested amount, optionally indenting the
  # first line, as well.
  #
  # param [ Integer ] indent The number of spaces to indent each line
  #   (Default: 2)
  # param [ true | false ] indent_first_line Whether or not to indent
  #   the first line of the comment (Default: false)
  #
  # @api private
  # @return [String] the reformatted comment
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#71
  def indented_comment(indent: T.unsafe(nil), indent_first_line: T.unsafe(nil)); end

  # The name of this option.
  #
  # @api private
  # @return [String] The name of the option
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#23
  def name; end

  private

  # Removes any existing whitespace from the beginning of each line in
  # the text.
  #
  # @api private
  # @param text [String] The text to unindent.
  # @return [String] the unindented text.
  #
  # source://mongoid//lib/mongoid/config/introspection.rb#103
  def unindent(text); end

  class << self
    # Instantiate an option from an array of Regex captures.
    #
    # @api private
    # @param captures [Array<String>] The array with the Regex captures
    #   to use to instantiate the option. The element at index 1 must be
    #   the comment, at index 2 must be the name, and at index 3 must be
    #   the default value.
    # @return [Option] The newly instantiated Option object.
    #
    # source://mongoid//lib/mongoid/config/introspection.rb#46
    def from_captures(captures); end
  end
end

# source://mongoid//lib/mongoid/config.rb#24
Mongoid::Config::LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Encapsulates logic for setting options.
#
# source://mongoid//lib/mongoid/config/options.rb#8
module Mongoid::Config::Options
  # Get the defaults or initialize a new empty hash.
  #
  # @example Get the defaults.
  #   options.defaults
  # @return [Hash] The default options.
  #
  # source://mongoid//lib/mongoid/config/options.rb#16
  def defaults; end

  # Get the log level.
  #
  # @example Get the log level.
  #   config.log_level
  # @return [Integer] The log level.
  #
  # source://mongoid//lib/mongoid/config/options.rb#83
  def log_level; end

  # Define a configuration option with a default.
  #
  # @example Define the option.
  #   Options.option(:logger, :default => Logger.new(STDERR, :warn))
  # @option options
  # @option options
  # @param name [Symbol] The name of the configuration option.
  # @param options [Hash] Extras for the option.
  #
  # source://mongoid//lib/mongoid/config/options.rb#31
  def option(name, options = T.unsafe(nil)); end

  # Reset the configuration options to the defaults.
  #
  # @example Reset the configuration options.
  #   config.reset
  # @return [Hash] The defaults.
  #
  # source://mongoid//lib/mongoid/config/options.rb#59
  def reset; end

  # Get the settings or initialize a new empty hash.
  #
  # @example Get the settings.
  #   options.settings
  # @return [Hash] The setting options.
  #
  # source://mongoid//lib/mongoid/config/options.rb#73
  def settings; end
end

# source://mongoid//lib/mongoid/config/validators/async_query_executor.rb#6
module Mongoid::Config::Validators; end

# Validates the async query executor options in the Mongoid
# configuration. Used during application bootstrapping.
#
# @api private
#
# source://mongoid//lib/mongoid/config/validators/async_query_executor.rb#12
module Mongoid::Config::Validators::AsyncQueryExecutor
  extend ::Mongoid::Config::Validators::AsyncQueryExecutor

  # Validate the Mongoid configuration options related to
  # the async query executor.
  #
  # @api private
  # @param options [Hash] The configuration options.
  #
  # source://mongoid//lib/mongoid/config/validators/async_query_executor.rb#24
  def validate(options); end
end

# Validator for client specific configuration.
#
# source://mongoid//lib/mongoid/config/validators/client.rb#9
module Mongoid::Config::Validators::Client
  extend ::Mongoid::Config::Validators::Client

  # Validate the client configuration.
  #
  # @example Validate the client config.
  #   Client.validate({ default: { hosts: [ "localhost:27017" ] }})
  # @param clients [Hash] The clients config.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#21
  def validate(clients); end

  private

  # Return true if the configuration has both standard options and a uri
  # defined.
  #
  # @api private
  # @example Validate the options.
  #   validator.no_database_or_uri?(config)
  # @param config [Hash] The configuration options.
  # @return [true | false] If both standard and uri are defined.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#121
  def both_uri_and_standard?(config); end

  # Return true if the configuration has no database or uri option
  # defined.
  #
  # @api private
  # @example Validate the options.
  #   validator.no_database_or_uri?(config)
  # @param config [Hash] The configuration options.
  # @return [true | false] If no database or uri is defined.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#91
  def no_database_or_uri?(config); end

  # Return true if the configuration has no hosts or uri option
  # defined.
  #
  # @api private
  # @example Validate the options.
  #   validator.no_hosts_or_uri?(config)
  # @param config [Hash] The configuration options.
  # @return [true | false] If no hosts or uri is defined.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#106
  def no_hosts_or_uri?(config); end

  # Validate that the client config has database.
  #
  # @api private
  # @example Validate the client has database.
  #   validator.validate_client_database(:default, {})
  # @param config [Hash] The configuration.
  # @param name [String | Symbol] The config key.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#43
  def validate_client_database(name, config); end

  # Validate that the client config has hosts.
  #
  # @api private
  # @example Validate the client has hosts.
  #   validator.validate_client_hosts(:default, {})
  # @param config [Hash] The configuration.
  # @param name [String | Symbol] The config key.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#58
  def validate_client_hosts(name, config); end

  # Validate that not both a uri and standard options are provided for a
  # single client.
  #
  # @api private
  # @example Validate the uri and options.
  #   validator.validate_client_uri(:default, {})
  # @param config [Hash] The configuration.
  # @param name [String | Symbol] The config key.
  #
  # source://mongoid//lib/mongoid/config/validators/client.rb#74
  def validate_client_uri(name, config); end
end

# Standard configuration options.
#
# source://mongoid//lib/mongoid/config/validators/client.rb#13
Mongoid::Config::Validators::Client::STANDARD = T.let(T.unsafe(nil), Array)

# Validator for configuration options.
#
# source://mongoid//lib/mongoid/config/validators/option.rb#9
module Mongoid::Config::Validators::Option
  extend ::Mongoid::Config::Validators::Option

  # Validate a configuration option.
  #
  # @example Validate a configuration option.
  # @param option [String] The name of the option.
  #
  # source://mongoid//lib/mongoid/config/validators/option.rb#17
  def validate(option); end
end

# Parent mixin module which adds aggregation (#sum, #avg, etc.) and
# atomic (#set, #unset, #push, etc.) behavior to Mongoid::Criteria.
#
# source://mongoid//lib/mongoid/contextual/queryable.rb#5
module Mongoid::Contextual
  extend ::Forwardable

  # source://mongoid//lib/mongoid/contextual.rb#22
  def add_each_to_set(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def add_to_set(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#18
  def aggregates(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#18
  def avg(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def bit(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#29
  def blank?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def clamp_lower_bound(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def clamp_upper_bound(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#29
  def collection(*_arg0, **_arg1, &_arg2); end

  # Get the context in which criteria queries should execute. This is either
  # in memory (for embedded documents) or mongo (for root level documents.)
  #
  # @example Get the context.
  #   criteria.context
  # @return [Memory | Mongo] The context.
  #
  # source://mongoid//lib/mongoid/contextual.rb#38
  def context; end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def count(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#29
  def criteria(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def database_field_name(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def delete(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def delete_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def destroy(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def destroy_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def distinct(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def documents_loader(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def each(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#29
  def empty?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def estimated_count(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def exists?(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def explain(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def fifth(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def fifth!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def find_first(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def find_one_and_delete(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def find_one_and_replace(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def find_one_and_update(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def first(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def first!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def fourth(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def fourth!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def inc(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#29
  def klass(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def last(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def length(*_arg0, **_arg1, &_arg2); end

  # Instructs the context to schedule an asynchronous loading of documents
  # specified by the criteria.
  #
  # Note that depending on the context and on the Mongoid configuration,
  # documents can be loaded synchronously on the caller's thread.
  #
  # @return [Criteria] Returns self.
  #
  # source://mongoid//lib/mongoid/contextual.rb#26
  def load_async; end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def map_reduce(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#18
  def max(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#18
  def min(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def mul(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def one(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def pick(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def pluck(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def pop(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def pull(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def pull_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def push(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def push_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def rename(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def second(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def second!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def second_to_last(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def second_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def set(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def set_max(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def set_min(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def size(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def sort(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#18
  def sum(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def take(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def take!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def tally(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def third(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def third!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def third_to_last(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def third_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#22
  def unset(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def update(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def update_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual.rb#26
  def view(*_arg0, **_arg1, &_arg2); end

  private

  # Create the context for the queries to execute. Will be memory for
  # embedded documents and mongo for root documents.
  #
  # @api private
  # @example Create the context.
  #   contextual.create_context
  # @return [Mongo | Memory] The context.
  #
  # source://mongoid//lib/mongoid/contextual.rb#65
  def create_context; end
end

# source://mongoid//lib/mongoid/contextual/aggregable.rb#6
module Mongoid::Contextual::Aggregable; end

# @api private
#
# source://mongoid//lib/mongoid/contextual/aggregable.rb#9
Mongoid::Contextual::Aggregable::EMPTY_RESULT = T.let(T.unsafe(nil), Hash)

# Contains behavior for aggregating values in memory.
#
# source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#8
module Mongoid::Contextual::Aggregable::Memory
  # Get all the aggregate values for the provided field.
  # Provided for interface consistency with Aggregable::Mongo.
  #
  # @param field [String | Symbol] The field name.
  # @return [Hash] A Hash containing the aggregate values.
  #   If no documents are present, then returned Hash will have
  #   count, sum of 0 and max, min, avg of nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#18
  def aggregates(field); end

  # Get the average value of the provided field.
  #
  # @example Get the average of a single field.
  #   aggregable.avg(:likes)
  # @param field [Symbol] The field to average.
  # @return [Numeric] The average.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#32
  def avg(field); end

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # @example Get the document with the max value.
  #   aggregable.max do |a, b|
  #   a.likes <=> b.likes
  #   end
  # @example Get the max of a single field.
  #   aggregable.max(:likes)
  # @param field [Symbol] The field to max.
  # @return [Numeric | Document] The max value or document with the max
  #   value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#56
  def max(field = T.unsafe(nil)); end

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # @example Get the document with the min value.
  #   aggregable.min do |a, b|
  #   a.likes <=> b.likes
  #   end
  # @example Get the min of a single field.
  #   aggregable.min(:likes)
  # @param field [Symbol] The field to min.
  # @return [Numeric | Document] The min value or document with the min
  #   value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#78
  def min(field = T.unsafe(nil)); end

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # @example Get the sum for the provided block.
  #   aggregable.sum(&:likes)
  # @example Get the sum of a single field.
  #   aggregable.sum(:likes)
  # @param field [Symbol | Numeric] The field to sum, or the intial
  #   value of the sum when a block is given.
  # @return [Numeric] The sum value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#97
  def sum(field = T.unsafe(nil)); end

  private

  # Aggregate by the provided field and method.
  #
  # @api private
  # @example Aggregate by the field and method.
  #   aggregable.aggregate_by(:likes, :min_by)
  # @param field [Symbol] The field to aggregate on.
  # @param method [Symbol] The method (min_by or max_by).
  # @return [Numeric | nil] The aggregate.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/memory.rb#116
  def aggregate_by(field, method); end
end

# Contains behavior for aggregating values in Mongo.
#
# source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#10
module Mongoid::Contextual::Aggregable::Mongo
  # Get all the aggregate values for the provided field.
  #
  # @example Get all the aggregate values.
  #   aggregable.aggregates(:likes)
  #   # => {
  #   #   "count" => 2.0,
  #   #   "max" => 1000.0,
  #   #   "min" => 500.0,
  #   #   "sum" => 1500.0,
  #   #   "avg" => 750.0
  #   # }
  # @param field [String | Symbol] The field name.
  # @return [Hash] A Hash containing the aggregate values.
  #   If no documents are found, then returned Hash will have
  #   count, sum of 0 and max, min, avg of nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#29
  def aggregates(field); end

  # Get the average value of the provided field.
  #
  # @example Get the average of a single field.
  #   aggregable.avg(:likes)
  # @param field [Symbol] The field to average.
  # @return [Float] The average.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#51
  def avg(field); end

  # Get the max value of the provided field. If provided a block, will
  # return the Document with the greatest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # @example Get the document with the max value.
  #   aggregable.max do |a, b|
  #   a.likes <=> b.likes
  #   end
  # @example Get the max of a single field.
  #   aggregable.max(:likes)
  # @param field [Symbol] The field to max.
  # @return [Float | Document] The max value or document with the max
  #   value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#71
  def max(field = T.unsafe(nil)); end

  # Get the min value of the provided field. If provided a block, will
  # return the Document with the smallest value for the field, in
  # accordance with Ruby's enumerable API.
  #
  # @example Get the document with the min value.
  #   aggregable.min do |a, b|
  #   a.likes <=> b.likes
  #   end
  # @example Get the min of a single field.
  #   aggregable.min(:likes)
  # @param field [Symbol] The field to min.
  # @return [Float | Document] The min value or document with the min
  #   value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#91
  def min(field = T.unsafe(nil)); end

  # Get the sum value of the provided field. If provided a block, will
  # return the sum in accordance with Ruby's enumerable API.
  #
  # @example Get the sum for the provided block.
  #   aggregable.sum(&:likes)
  # @example Get the sum of a single field.
  #   aggregable.sum(:likes)
  # @param field [Symbol | Numeric] The field to sum, or the initial
  #   value of the sum when a block is given.
  # @return [Float] The sum value.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#108
  def sum(field = T.unsafe(nil)); end

  private

  # Get the aggregation pipeline for provided field.
  #
  # @api private
  # @example Get the pipeline.
  #   aggregable.pipeline(:likes)
  # @param field [String | Symbol] The name of the field.
  # @return [Array] The array of pipeline operators.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/mongo.rb#126
  def pipeline(field); end
end

# Contains behavior for aggregating values in null context.
#
# source://mongoid//lib/mongoid/contextual/aggregable/none.rb#10
module Mongoid::Contextual::Aggregable::None
  # Get all the aggregate values for the provided field in null context.
  # Provided for interface consistency with Aggregable::Mongo.
  #
  # @param _field [String | Symbol] The field name.
  # @return [Hash] A Hash with count, sum of 0 and max, min, avg of nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/none.rb#18
  def aggregates(_field); end

  # Always returns nil.
  #
  # @example Get the avg of null context.
  # @param _field [Symbol] The field to avg.
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/none.rb#40
  def avg(_field); end

  # Always returns nil.
  # Always returns nil.
  #
  # @example Get the max of null context.
  # @example Get the min of null context.
  # @param _field [Symbol] The field to min.
  # @param _field [Symbol] The field to max.
  # @return [nil] Always nil.
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/none.rb#62
  def max(_field = T.unsafe(nil)); end

  # Always returns nil.
  #
  # @example Get the min of null context.
  # @param _field [Symbol] The field to min.
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/none.rb#51
  def min(_field = T.unsafe(nil)); end

  # Always returns zero.
  #
  # @example Get the sum of null context.
  # @param _field [Symbol] The field to sum.
  # @return [Integer] Always zero.
  #
  # source://mongoid//lib/mongoid/contextual/aggregable/none.rb#29
  def sum(_field = T.unsafe(nil)); end
end

# Mixin module included in Mongoid::Criteria which provides a
# direct method interface to MongoDB's Update Operators ($set,
# $pull, $inc, etc.) These operators can be applied to update
# all documents in the database within the criteria scope,
# without loading each document into Mongoid's memory.
#
# source://mongoid//lib/mongoid/contextual/atomic.rb#12
module Mongoid::Contextual::Atomic
  # Perform an atomic $addToSet/$each on the matching documents.
  #
  # @example Add the value to the set.
  #   context.add_each_to_set(members: ["Dave", "Bill"], genres: ["Electro", "Disco"])
  # @param adds [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#34
  def add_each_to_set(adds); end

  # Execute an atomic $addToSet on the matching documents.
  #
  # @example Add the value to the set.
  #   context.add_to_set(members: "Dave", genres: "Electro")
  # @param adds [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#22
  def add_to_set(adds); end

  # Perform an atomic $bit operation on the matching documents.
  #
  # @example Perform the bitwise op.
  #   context.bit(likes: { and: 14, or: 4 })
  # @param bits [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#46
  def bit(bits); end

  # Performs an atomic $max update operation on the given field or fields.
  # Each field will be set to the maximum of [current_value, given value].
  # This has the effect of making sure that each field is no
  # smaller than the given value; in other words, the given value is the
  # effective *minimum* for that field.
  #
  # @example Set "views" to be no less than 100.
  #   context.set_max(views: 100)
  # @note Because of the existence of
  #   Mongoid::Contextual::Aggregable::Mongo#max, this method cannot be
  #   named #max, and thus breaks that convention of other similar methods
  #   of being named for the MongoDB operation they perform.
  # @param fields [Hash] The fields with the minimum value that each
  #   may be set to.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#226
  def clamp_lower_bound(fields); end

  # Performs an atomic $min update operation on the given field or fields.
  # Each field will be set to the minimum of [current_value, given value].
  # This has the effect of making sure that each field is no
  # larger than the given value; in other words, the given value is the
  # effective *maximum* for that field.
  #
  # @example Set "views" to be no more than 100.
  #   context.set_min(views: 100)
  # @note Because of the existence of
  #   Mongoid::Contextual::Aggregable::Mongo#min, this method cannot be
  #   named #min, and thus breaks that convention of other similar methods
  #   of being named for the MongoDB operation they perform.
  # @param fields [Hash] The fields with the maximum value that each
  #   may be set to.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#203
  def clamp_upper_bound(fields); end

  # Perform an atomic $inc operation on the matching documents.
  #
  # @example Perform the atomic increment.
  #   context.inc(likes: 10)
  # @param incs [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#58
  def inc(incs); end

  # Perform an atomic $mul operation on the matching documents.
  #
  # @example Perform the atomic multiplication.
  #   context.mul(likes: 10)
  # @param factors [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#70
  def mul(factors); end

  # Perform an atomic $pop operation on the matching documents.
  #
  # @example Pop the first value on the matches.
  #   context.pop(members: -1)
  # @example Pop the last value on the matches.
  #   context.pop(members: 1)
  # @param pops [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#85
  def pop(pops); end

  # Perform an atomic $pull operation on the matching documents.
  #
  # @example Pull the value from the matches.
  #   context.pull(members: "Dave")
  # @note Expression pulling is not yet supported.
  # @param pulls [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#99
  def pull(pulls); end

  # Perform an atomic $pullAll operation on the matching documents.
  #
  # @example Pull all the matching values from the matches.
  #   context.pull_all(:members, [ "Alan", "Vince" ])
  # @param pulls [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#111
  def pull_all(pulls); end

  # Perform an atomic $push operation on the matching documents.
  #
  # @example Push the value to the matching docs.
  #   context.push(members: "Alan")
  # @param pushes [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#123
  def push(pushes); end

  # Perform an atomic $push/$each operation on the matching documents.
  #
  # @example Push the values to the matching docs.
  #   context.push_all(members: [ "Alan", "Fletch" ])
  # @param pushes [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#135
  def push_all(pushes); end

  # Perform an atomic $rename of fields on the matching documents.
  #
  # @example Rename the fields on the matching documents.
  #   context.rename(members: :artists)
  # @param renames [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#147
  def rename(renames); end

  # Perform an atomic $set of fields on the matching documents.
  #
  # @example Set the field value on the matches.
  #   context.set(name: "Depeche Mode")
  # @param sets [Hash] The operations.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#163
  def set(sets); end

  # Performs an atomic $max update operation on the given field or fields.
  # Each field will be set to the maximum of [current_value, given value].
  # This has the effect of making sure that each field is no
  # smaller than the given value; in other words, the given value is the
  # effective *minimum* for that field.
  #
  # @example Set "views" to be no less than 100.
  #   context.set_max(views: 100)
  # @note Because of the existence of
  #   Mongoid::Contextual::Aggregable::Mongo#max, this method cannot be
  #   named #max, and thus breaks that convention of other similar methods
  #   of being named for the MongoDB operation they perform.
  # @param fields [Hash] The fields with the minimum value that each
  #   may be set to.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#223
  def set_max(fields); end

  # Performs an atomic $min update operation on the given field or fields.
  # Each field will be set to the minimum of [current_value, given value].
  # This has the effect of making sure that each field is no
  # larger than the given value; in other words, the given value is the
  # effective *maximum* for that field.
  #
  # @example Set "views" to be no more than 100.
  #   context.set_min(views: 100)
  # @note Because of the existence of
  #   Mongoid::Contextual::Aggregable::Mongo#min, this method cannot be
  #   named #min, and thus breaks that convention of other similar methods
  #   of being named for the MongoDB operation they perform.
  # @param fields [Hash] The fields with the maximum value that each
  #   may be set to.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#200
  def set_min(fields); end

  # Perform an atomic $unset of a field on the matching documents.
  #
  # @example Unset the field on the matches.
  #   context.unset(:name)
  # @param *unsets [[ String | Symbol | Array<String | Symbol> | Hash ]...] The name(s) of the field(s) to unset. If a Hash is specified,
  #   its keys will be used irrespective of value, even if the value
  #   is nil or false.
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#178
  def unset(*unsets); end

  private

  # source://mongoid//lib/mongoid/contextual/atomic.rb#242
  def collect_each_operations(ops); end

  # Collects and aggregates operations by field.
  #
  # @param aggregator [Hash] The hash to use to aggregate the operations.
  # @param ops [Array | Hash] The operations to collect.
  # @return [Hash] The aggregated operations, by field.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#236
  def collect_operations(ops, aggregator = T.unsafe(nil)); end

  # Builds the selector an atomic $unset operation from arguments.
  #
  # @example Prepare selector from array.
  #   context.collect_unset_operations([:name, :age])
  #   #=> { "name" => true, "age" => true }
  # @example Prepare selector from hash.
  #   context.collect_unset_operations({ name: 1 }, { age: 1 })
  #   #=> { "name" => true, "age" => true }
  # @param ops [String | Symbol | Array<String | Symbol> | Hash] The name(s) of the field(s) to unset.
  # @return [Hash] The selector for the atomic $unset operation.
  #
  # source://mongoid//lib/mongoid/contextual/atomic.rb#262
  def collect_unset_operations(ops); end
end

# Mixin module included in objects which represent database commands.
#
# source://mongoid//lib/mongoid/contextual/command.rb#8
module Mongoid::Contextual::Command
  # Get the database client.
  #
  # @example Get the client.
  #   command.client
  # @return [Mongo::Client] The Mongo client.
  #
  # source://mongoid//lib/mongoid/contextual/command.rb#30
  def client; end

  # Returns the value of attribute collection.
  #
  # source://mongoid//lib/mongoid/contextual/command.rb#12
  def collection; end

  # The database command that is being built to send to the db.
  #
  # @example Get the command.
  #   command.command
  # @return [Hash] The db command.
  #
  # source://mongoid//lib/mongoid/contextual/command.rb#20
  def command; end

  # Returns the value of attribute criteria.
  #
  # source://mongoid//lib/mongoid/contextual/command.rb#12
  def criteria; end
end

# Represents a mapReduce database command instruction.
#
# source://mongoid//lib/mongoid/contextual/map_reduce.rb#8
class Mongoid::Contextual::MapReduce
  include ::Enumerable
  include ::Mongoid::Contextual::Command
  extend ::Forwardable

  # Initialize the new map/reduce directive.
  #
  # @example Initialize the new map/reduce.
  #   MapReduce.new(criteria, map, reduce)
  # @param criteria [Criteria] The Mongoid criteria.
  # @param map [String] The map js function.
  # @param reduce [String] The reduce js function.
  # @return [MapReduce] a new instance of MapReduce
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#77
  def initialize(collection, criteria, map, reduce); end

  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#14
  def ==(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#13
  def [](*_arg0, **_arg1, &_arg2); end

  # Returns the selector of the command spec.
  #
  # @return [Hash] The selector.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#221
  def command; end

  # Get all the counts returned by the map/reduce.
  #
  # @example Get the counts.
  #   map_reduce.counts
  # @return [Hash] The counts.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#22
  def counts; end

  # Iterates over each of the documents in the map/reduce, excluding the
  # extra information that was passed back from the database.
  #
  # @example Iterate over the results.
  #   map_reduce.each do |doc|
  #   p doc
  #   end
  # @return [Enumerator] The enumerator.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#35
  def each; end

  # Get the number of documents emitted by the map/reduce.
  #
  # @example Get the emitted document count.
  #   map_reduce.emitted
  # @return [Integer] The number of emitted documents.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#52
  def emitted; end

  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#14
  def empty?(*_arg0, **_arg1, &_arg2); end

  # Get the raw output from the map/reduce operation.
  # Execute the map/reduce, returning the raw output.
  # Useful when you don't care about map/reduce's output.
  #
  # @example Get the raw output.
  #   map_reduce.raw
  # @example Run the map reduce
  #   map_reduce.execute
  # @return [Hash] The raw output.
  # @return [Hash] The raw output
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#165
  def execute; end

  # Provide a finalize js function for the map/reduce.
  #
  # @example Provide a finalize function.
  #   map_reduce.finalize(func)
  # @param function [String] The finalize function.
  # @return [MapReduce] The map reduce.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#64
  def finalize(function); end

  # Get the number of documents that were input into the map/reduce.
  #
  # @example Get the count of input documents.
  #   map_reduce.input
  # @return [Integer] The number of input documents.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#89
  def input; end

  # Get a pretty string representation of the map/reduce, including the
  # criteria, map, reduce, finalize, and out option.
  #
  # @example Inspect the map_reduce.
  #   map_reduce.inspect
  # @return [String] The inspection string.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#207
  def inspect; end

  # Sets the map/reduce to use jsMode.
  #
  # @example Set the map/reduce to jsMode.
  #   map_reduce.js_mode
  # @return [MapReduce] The map/reduce.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#99
  def js_mode; end

  # Specifies where the map/reduce output is to be stored.
  # Please see MongoDB documentation for supported map reduce options.
  #
  # @example Return results from map reduce.
  #   map_reduce.out(inline: 1)
  # @example Store output in a collection, merging existing documents.
  #   map_reduce.out(merge: "collection_name")
  # @example Store output in a collection, reducing existing documents.
  #   map_reduce.out(reduce: "collection_name")
  # @example Store output in a collection, replacing existing documents.
  #   map_reduce.out(replace: "collection_name")
  # @example Store output in memory.
  #   map_reduce.out(inline: 1)
  # @param location [Hash] The place to store the results.
  # @return [MapReduce] The map/reduce object.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#125
  def out(location); end

  # Get the number of documents output by the map/reduce.
  #
  # @example Get the output document count.
  #   map_reduce.output
  # @return [Integer] The number of output documents.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#140
  def output; end

  # Get the raw output from the map/reduce operation.
  #
  # @example Get the raw output.
  #   map_reduce.raw
  # @return [Hash] The raw output.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#150
  def raw; end

  # Get the number of documents reduced by the map/reduce.
  #
  # @example Get the reduced document count.
  #   map_reduce.reduced
  # @return [Integer] The number of reduced documents.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#173
  def reduced; end

  # Get the raw output from the map/reduce operation.
  #
  # @example Get the raw output.
  #   map_reduce.raw
  # @return [Hash] The raw output.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#156
  def results; end

  # Adds a javascript object to the global scope of the map/reduce.
  #
  # @example Add an object to the global scope.
  #   map_reduce.scope(name: value)
  # @param object [Hash] A hash of key/values for the global scope.
  # @return [MapReduce]
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#185
  def scope(object); end

  # Get the execution time of the map/reduce.
  #
  # @example Get the execution time.
  #   map_reduce.time
  # @return [Float] The time in milliseconds.
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#196
  def time; end

  private

  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#231
  def _session; end

  # @raise [Errors::NoMapReduceOutput]
  #
  # source://mongoid//lib/mongoid/contextual/map_reduce.rb#227
  def validate_out!; end
end

# Context object used for performing bulk query and persistence
# operations on documents which have been loaded into application
# memory. The method interface of this class is consistent with
# Mongoid::Contextual::Mongo.
#
# source://mongoid//lib/mongoid/contextual/memory.rb#14
class Mongoid::Contextual::Memory
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::Memory
  include ::Mongoid::Association::EagerLoadable
  include ::Mongoid::Contextual::Queryable
  include ::Mongoid::Positional

  # Create the new in memory context.
  #
  # @example Create the new context.
  #   Memory.new(criteria)
  # @param criteria [Criteria] The criteria.
  # @return [Memory] a new instance of Memory
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#173
  def initialize(criteria); end

  # Check if the context is equal to the other object.
  #
  # @example Check equality.
  #   context == []
  # @param other [Array] The other array.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#35
  def ==(other); end

  # Delete all documents in the database that match the selector.
  #
  # @example Delete all the documents.
  #   context.delete
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#46
  def delete; end

  # Delete all documents in the database that match the selector.
  #
  # @example Delete all the documents.
  #   context.delete
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#60
  def delete_all; end

  # Destroy all documents in the database that match the selector.
  #
  # @example Destroy all the documents.
  #   context.destroy
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#68
  def destroy; end

  # Destroy all documents in the database that match the selector.
  #
  # @example Destroy all the documents.
  #   context.destroy
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#76
  def destroy_all; end

  # Get the distinct values in the db for the provided field.
  #
  # @example Get the distinct values.
  #   context.distinct(:name)
  # @param field [String | Symbol] The name of the field.
  # @return [Array<Object>] The distinct values for the field.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#86
  def distinct(field); end

  # Returns the value of attribute documents.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#25
  def documents; end

  # Iterate over the context. If provided a block, yield to a Mongoid
  # document for each, otherwise return an enum.
  #
  # @example Iterate over the context.
  #   context.each do |doc|
  #   puts doc.name
  #   end
  # @return [Enumerator] The enumerator.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#99
  def each; end

  # Do any documents exist for the context.
  #
  # @example Do any documents exist for given _id.
  #   context.exists?(BSON::ObjectId(...))
  # @example Do any documents exist for given conditions.
  #   context.exists?(name: "...")
  # @example Do any documents exist for the context.
  #   context.exists?
  # @param id_or_conditions [Hash | Object | false] an _id to
  #   search for, a hash of conditions, nil or false.
  # @return [true | false] If the count is more than zero.
  #   Always false if passed nil or false.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#126
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # Get the fifth document in the database for the criteria's selector.
  #
  # @example Get the fifth document.
  #   context.fifth
  # @return [Document] The fifth document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#454
  def fifth; end

  # Get the fifth document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the fifth document.
  #   context.fifth!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The fifth document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#468
  def fifth!; end

  # Get the first document in the database for the criteria's selector.
  #
  # @example Get the first document.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#151
  def find_first(limit = T.unsafe(nil)); end

  # Get the first document in the database for the criteria's selector.
  #
  # @example Get the first document.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#143
  def first(limit = T.unsafe(nil)); end

  # Get the first document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the first document.
  #   context.first!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The first document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#163
  def first!; end

  # Get the fourth document in the database for the criteria's selector.
  #
  # @example Get the fourth document.
  #   context.fourth
  # @return [Document] The fourth document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#430
  def fourth; end

  # Get the fourth document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the fourth document.
  #   context.fourth!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The fourth document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#444
  def fourth!; end

  # Increment a value on all documents.
  #
  # @example Perform the increment.
  #   context.inc(likes: 10)
  # @param incs [Hash] The operations.
  # @return [Enumerator] The enumerator.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#192
  def inc(incs); end

  # Get the last document in the database for the criteria's selector.
  #
  # @example Get the last document.
  #   context.last
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#206
  def last(limit = T.unsafe(nil)); end

  # Get the last document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the last document.
  #   context.last!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#224
  def last!; end

  # Get the length of matching documents in the context.
  #
  # @example Get the length of matching documents.
  #   context.length
  # @return [Integer] The matching length.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#234
  def length; end

  # Limits the number of documents that are returned.
  #
  # @example Limit the documents.
  #   context.limit(20)
  # @param value [Integer] The number of documents to return.
  # @return [Memory] The context.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#247
  def limit(value); end

  # Get the first document in the database for the criteria's selector.
  #
  # @example Get the first document.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#150
  def one(limit = T.unsafe(nil)); end

  # Returns the value of attribute path.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#25
  def path; end

  # Pick the field values in memory.
  #
  # @example Get the values in memory.
  #   context.pick(:name)
  # @param *fields [[ String | Symbol ]...] Field(s) to pick.
  # @return [Object | Array<Object>] The picked values.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#274
  def pick(*fields); end

  # Pluck the field values in memory.
  #
  # @example Get the values in memory.
  #   context.pluck(:name)
  # @param *fields [[ String | Symbol ]...] Field(s) to pluck.
  # @return [Array<Object> | Array<Array<Object>>] The plucked values.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#260
  def pluck(*fields); end

  # Returns the value of attribute root.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#25
  def root; end

  # Get the second document in the database for the criteria's selector.
  #
  # @example Get the second document.
  #   context.second
  # @return [Document] The second document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#382
  def second; end

  # Get the second document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the second document.
  #   context.second!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The second document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#396
  def second!; end

  # Get the second to last document in the database for the criteria's selector.
  #
  # @example Get the second to last document.
  #   context.second_to_last
  # @return [Document] The second to last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#478
  def second_to_last; end

  # Get the second to last document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the second to last document.
  #   context.second_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The second to last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#492
  def second_to_last!; end

  # Returns the value of attribute selector.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#25
  def selector; end

  # Get the length of matching documents in the context.
  #
  # @example Get the length of matching documents.
  #   context.length
  # @return [Integer] The matching length.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#237
  def size; end

  # Skips the provided number of documents.
  #
  # @example Skip the documents.
  #   context.skip(20)
  # @param value [Integer] The number of documents to skip.
  # @return [Memory] The context.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#334
  def skip(value); end

  # Sorts the documents by the provided spec.
  #
  # @example Sort the documents.
  #   context.sort(name: -1, title: 1)
  # @param values [Hash] The sorting values as field/direction(1/-1)
  #   pairs.
  # @return [Memory] The context.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#348
  def sort(values); end

  # Take the given number of documents from the database.
  #
  # @example Take a document.
  #   context.take
  # @param limit [Integer | nil] The number of documents to take or nil.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#304
  def take(limit = T.unsafe(nil)); end

  # Take the given number of documents from the database or raise an error
  # if none are found.
  #
  # @example Take a document.
  #   context.take
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#322
  def take!; end

  # Tally the field values in memory.
  #
  # @example Get the counts of values in memory.
  #   context.tally(:name)
  # @param field [String | Symbol] Field to tally.
  # @return [Hash] The hash of counts.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#288
  def tally(field); end

  # Get the third document in the database for the criteria's selector.
  #
  # @example Get the third document.
  #   context.third
  # @return [Document] The third document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#406
  def third; end

  # Get the third document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the third document.
  #   context.third!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The third document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#420
  def third!; end

  # Get the third to last document in the database for the criteria's selector.
  #
  # @example Get the third to last document.
  #   context.third_to_last
  # @return [Document] The third to last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#502
  def third_to_last; end

  # Get the third to last document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the third to last document.
  #   context.third_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The third to last document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#516
  def third_to_last!; end

  # Update the first matching document atomically.
  #
  # @example Update the matching document.
  #   context.update(name: "Smiths")
  # @param attributes [Hash] The new attributes for the document.
  # @return [nil | false] False if no attributes were provided.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#360
  def update(attributes = T.unsafe(nil)); end

  # Update all the matching documents atomically.
  #
  # @example Update all the matching documents.
  #   context.update_all(name: "Smiths")
  # @param attributes [Hash] The new attributes for each document.
  # @return [nil | false] False if no attributes were provided.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#372
  def update_all(attributes = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/contextual/memory.rb#682
  def _session; end

  # Apply criteria options.
  #
  # @api private
  # @example Apply criteria options.
  #   context.apply_options
  # @raise [Errors::InMemoryCollationNotSupported]
  # @return [Memory] self.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#615
  def apply_options; end

  # Map the sort symbols to the correct MongoDB values.
  #
  # @example Apply the sorting params.
  #   context.apply_sorting
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#624
  def apply_sorting; end

  # Compare two values, handling the cases when
  # either value is nil.
  #
  # @api private
  # @example Compare the two objects.
  #   context.compare(a, b)
  # @param a [Object] The first object.
  # @param b [Object] The second object.
  # @return [Integer] The comparison value.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#642
  def compare(a, b); end

  # Get the operand value to be used in comparison.
  # Adds capability to sort boolean values.
  #
  # @example Get the comparison operand.
  #   compare_operand(true) #=> 1
  # @param value [Object] The value to be used in comparison.
  # @return [Integer | Object] The comparison operand.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#695
  def compare_operand(value); end

  # Get the documents the context should iterate. This follows 3 rules:
  #
  # @api private
  # @example Get the documents for iteration.
  #   context.documents_for_iteration
  # @return [Array<Document>] The docs to iterate.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#530
  def documents_for_iteration; end

  # Sort the documents in place.
  #
  # @example Sort the documents.
  #   context.in_place_sort(name: 1)
  # @param values [Hash] The field/direction sorting pairs.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#656
  def in_place_sort(values); end

  # Get the limiting value.
  #
  # @api private
  # @example Get the limiting value.
  # @return [Integer] The limit.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#566
  def limiting; end

  # Set the limiting value.
  #
  # @api private
  # @example Set the limiting value.
  # @param value [Integer] The limit.
  # @return [Integer] The limit.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#579
  def limiting=(value); end

  # Pluck the field values from the given document.
  #
  # @param *fields [[ String | Symbol ]...] Field(s) to pluck.
  # @param doc [Document] The document to pluck from.
  # @return [Object | Array<Object>] The plucked values.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#766
  def pluck_from_doc(doc, *fields); end

  # Prepare the document for batch removal.
  #
  # @api private
  # @example Prepare for removal.
  #   context.prepare_remove(doc)
  # @param doc [Document] The document.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#672
  def prepare_remove(doc); end

  # @raise [Errors::DocumentNotFound]
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#776
  def raise_document_not_found_error; end

  # Retrieve the value for the current document at the given field path.
  #
  # For example, if I have the following models:
  #
  #   User has_many Accounts
  #   address is a hash on Account
  #
  #   u = User.new(accounts: [ Account.new(address: { street: "W 50th" }) ])
  #   retrieve_value_at_path(u, "user.accounts.address.street")
  #   # => [ "W 50th" ]
  #
  # Note that the result is in an array since accounts is an array. If it
  # was nested in two arrays the result would be in a 2D array.
  #
  # @param document [Object] The object to traverse the field path.
  # @param field_path [String] The dotted string that represents the path
  #   to the value.
  # @return [Object | nil] The value at the given field path or nil if it
  #   doesn't exist.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#723
  def retrieve_value_at_path(document, field_path); end

  # Get the skipping value.
  #
  # @api private
  # @example Get the skipping value.
  # @return [Integer] The skip.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#590
  def skipping; end

  # Set the skipping value.
  #
  # @api private
  # @example Set the skipping value.
  # @param value [Integer] The skip.
  # @return [Integer] The skip.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#603
  def skipping=(value); end

  # Update the provided documents with the attributes.
  #
  # @api private
  # @example Update the documents.
  #   context.update_documents({}, doc)
  # @param attributes [Hash] The attributes.
  # @param docs [Array<Document>] The docs to update.
  #
  # source://mongoid//lib/mongoid/contextual/memory.rb#547
  def update_documents(attributes, docs); end
end

# Context object used for performing bulk query and persistence
# operations on documents which are persisted in the database and
# have not been loaded into application memory.
#
# source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#6
class Mongoid::Contextual::Mongo
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::Mongo
  include ::Mongoid::Contextual::Atomic
  include ::Mongoid::Association::EagerLoadable
  include ::Mongoid::Contextual::Queryable
  include ::Mongoid::Pluckable
  extend ::Forwardable

  # Create the new Mongo context. This delegates operations to the
  # underlying driver.
  #
  # @example Create the new context.
  #   Mongo.new(criteria)
  # @param criteria [Criteria] The criteria.
  # @return [Mongo] a new instance of Mongo
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#272
  def initialize(criteria); end

  # Get the number of documents matching the query.
  #
  # @example Get the count for where the provided block is true.
  #   context.count do |doc|
  #   doc.likes > 1
  #   end
  # @example Get the count of documents with the provided options.
  #   context.count(limit: 1)
  # @example Get the number of matching documents.
  #   context.count
  # @param options [Hash] The options, such as skip and limit to be factored
  #   into the count.
  # @return [Integer] The number of matches.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#75
  def count(options = T.unsafe(nil), &block); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#280
  def database_field_name(*_arg0, **_arg1, &_arg2); end

  # Delete all documents in the database that match the selector.
  #
  # @example Delete all the documents.
  #   context.delete
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#116
  def delete; end

  # Delete all documents in the database that match the selector.
  #
  # @example Delete all the documents.
  #   context.delete
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#119
  def delete_all; end

  # Destroy all documents in the database that match the selector.
  #
  # @example Destroy all the documents.
  #   context.destroy
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#127
  def destroy; end

  # Destroy all documents in the database that match the selector.
  #
  # @example Destroy all the documents.
  #   context.destroy
  # @return [nil] Nil.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#134
  def destroy_all; end

  # Get the distinct values in the db for the provided field.
  #
  # @example Get the distinct values.
  #   context.distinct(:name)
  # @param field [String | Symbol] The name of the field.
  # @return [Array<Object>] The distinct values for the field.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#144
  def distinct(field); end

  # Returns the value of attribute documents_loader.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#56
  def documents_loader; end

  # Iterate over the context. If provided a block, yield to a Mongoid
  # document for each, otherwise return an enum.
  #
  # @example Iterate over the context.
  #   context.each do |doc|
  #   puts doc.name
  #   end
  # @return [Enumerator] The enumerator.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#162
  def each(&block); end

  # Get the estimated number of documents matching the query.
  #
  # Unlike count, estimated_count does not take a block because it is not
  # traditionally defined (with a block) on Enumarable like count is.
  #
  # @example Get the estimated number of matching documents.
  #   context.estimated_count
  # @param options [Hash] The options, such as maxTimeMS to be factored
  #   into the count.
  # @return [Integer] The number of matches.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#99
  def estimated_count(options = T.unsafe(nil)); end

  # Do any documents exist for the context.
  #
  # @example Do any documents exist for given _id.
  #   context.exists?(BSON::ObjectId(...))
  # @example Do any documents exist for given conditions.
  #   context.exists?(name: "...")
  # @example Do any documents exist for the context.
  #   context.exists?
  # @note We don't use count here since Mongo does not use counted
  #   b-tree indexes.
  # @param id_or_conditions [Hash | Object | false] an _id to
  #   search for, a hash of conditions, nil or false.
  # @return [true | false] If the count is more than zero.
  #   Always false if passed nil or false.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#192
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#54
  def explain(*_arg0, **_arg1, &_arg2); end

  # Get the fifth document in the database for the criteria's selector.
  #
  # @example Get the fifth document.
  #   context.fifth
  # @return [Document | nil] The fifth document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#690
  def fifth; end

  # Get the fifth document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the fifth document.
  #   context.fifth!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The fifth document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#704
  def fifth!; end

  # Return the first result without applying sort
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#258
  def find_first; end

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify. This deletes the found document.
  #
  # @example Execute the command.
  #   context.find_one_and_delete
  # @return [Document] The result of the command.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#249
  def find_one_and_delete; end

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify.
  #
  # @example Execute the command.
  #   context.find_one_and_update({ likes: 1 })
  # @option options
  # @option options
  # @param options [Hash] The command options.
  # @param replacement [Hash] The replacement.
  # @return [Document] The result of the command.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#236
  def find_one_and_replace(replacement, options = T.unsafe(nil)); end

  # Execute the find and modify command, used for MongoDB's
  # $findAndModify.
  #
  # @example Execute the command.
  #   context.find_one_and_update({ "$inc" => { likes: 1 }})
  # @option options
  # @option options
  # @param options [Hash] The command options.
  # @param update [Hash] The updates.
  # @return [Document] The result of the command.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#216
  def find_one_and_update(update, options = T.unsafe(nil)); end

  # Get the first document in the database for the criteria's selector.
  #
  # @example Get the first document.
  #   context.first
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first or #last
  #   and have no sort defined on the criteria, use #take instead.
  #   Be aware that #take won't guarantee order.
  # @param limit [Integer] The number of documents to return.
  # @return [Document | nil] The first document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#541
  def first(limit = T.unsafe(nil)); end

  # Get the first document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the first document.
  #   context.first!
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first! or #last!
  #   and have no sort defined on the criteria, use #take! instead.
  #   Be aware that #take! won't guarantee order.
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The first document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#566
  def first!; end

  # Get the fourth document in the database for the criteria's selector.
  #
  # @example Get the fourth document.
  #   context.fourth
  # @return [Document | nil] The fourth document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#666
  def fourth; end

  # Get the fourth document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the fourth document.
  #   context.fourth!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The fourth document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#680
  def fourth!; end

  # Get the last document in the database for the criteria's selector.
  #
  # @example Get the last document.
  #   context.last
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first or #last
  #   and have no sort defined on the criteria, use #take instead.
  #   Be aware that #take won't guarantee order.
  # @param limit [Integer] The number of documents to return.
  # @return [Document | nil] The last document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#584
  def last(limit = T.unsafe(nil)); end

  # Get the last document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the last document.
  #   context.last!
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first! or #last!
  #   and have no sort defined on the criteria, use #take! instead.
  #   Be aware that #take! won't guarantee order.
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The last document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#608
  def last!; end

  # Returns the number of documents in the database matching
  # the query selector.
  #
  # @example Get the length.
  #   context.length
  # @return [Integer] The number of documents.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#289
  def length; end

  # Limits the number of documents that are returned from the database.
  #
  # @example Limit the documents.
  #   context.limit(20)
  # @param value [Integer] The number of documents to return.
  # @return [Mongo] The context.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#302
  def limit(value); end

  # Schedule a task to load documents for the context.
  #
  # Depending on the Mongoid configuration, the scheduled task can be executed
  # immediately on the caller's thread, or can be scheduled for an
  # asynchronous execution.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#767
  def load_async; end

  # Initiate a map/reduce operation from the context.
  #
  # @example Initiate a map/reduce.
  #   context.map_reduce(map, reduce)
  # @param map [String] The map js function.
  # @param reduce [String] The reduce js function.
  # @return [MapReduce] The map/reduce lazy wrapper.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#315
  def map_reduce(map, reduce); end

  # Get the first document in the database for the criteria's selector.
  #
  # @example Get the first document.
  #   context.first
  # @note Automatically adding a sort on _id when no other sort is
  #   defined on the criteria has the potential to cause bad performance issues.
  #   If you experience unexpected poor performance when using #first or #last
  #   and have no sort defined on the criteria, use #take instead.
  #   Be aware that #take won't guarantee order.
  # @param limit [Integer] The number of documents to return.
  # @return [Document | nil] The first document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#548
  def one(limit = T.unsafe(nil)); end

  # Pick the single field values from the database.
  #
  # @example Pick a field.
  #   context.pick(:_id)
  # @param *fields [[ String | Symbol ]...] Field(s) to pick.
  # @return [Object | Array<Object>] The picked values.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#352
  def pick(*fields); end

  # Pluck the field value(s) from the database. Returns one
  # result for each document found in the database for
  # the context. The results are normalized according to their
  # Mongoid field types. Note that the results may include
  # duplicates and nil values.
  #
  # @example Pluck a field.
  #   context.pluck(:_id)
  # @param *fields [[ String | Symbol ]...] Field(s) to pluck,
  #   which may include nested fields using dot-notation.
  # @return [Array<Object> | Array<Array<Object>>] The plucked values.
  #   If the *fields arg contains a single value, each result
  #   in the array will be a single value. Otherwise, each
  #   result in the array will be an array of values.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#335
  def pluck(*fields); end

  # Get the second document in the database for the criteria's selector.
  #
  # @example Get the second document.
  #   context.second
  # @return [Document | nil] The second document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#618
  def second; end

  # Get the second document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the second document.
  #   context.second!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The second document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#632
  def second!; end

  # Get the second to last document in the database for the criteria's
  # selector.
  #
  # is found.
  #
  # @example Get the second to last document.
  #   context.second_to_last
  # @return [Document | nil] The second to last document or nil if none
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#716
  def second_to_last; end

  # Get the second to last document in the database for the criteria's
  # selector or raise an error if none is found.
  #
  # @example Get the second to last document.
  #   context.second_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The second to last document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#730
  def second_to_last!; end

  # Returns the number of documents in the database matching
  # the query selector.
  #
  # @example Get the length.
  #   context.length
  # @return [Integer] The number of documents.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#292
  def size; end

  # Skips the provided number of documents.
  #
  # @example Skip the documents.
  #   context.skip(20)
  # @param value [Integer] The number of documents to skip.
  # @return [Mongo] The context.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#471
  def skip(value); end

  # Sorts the documents by the provided spec.
  #
  # @example Sort the documents.
  #   context.sort(name: -1, title: 1)
  # @param values [Hash] The sorting values as field/direction(1/-1)
  #   pairs.
  # @return [Mongo] The context.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#484
  def sort(values = T.unsafe(nil), &block); end

  # Take the given number of documents from the database.
  #
  # @example Take 10 documents
  #   context.take(10)
  # @param limit [Integer | nil] The number of documents to return or nil.
  # @return [Document | Array<Document>] The list of documents, or one
  #   document if no value was given.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#365
  def take(limit = T.unsafe(nil)); end

  # Take one document from the database and raise an error if there are none.
  #
  # @example Take a document
  #   context.take!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents to take.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#384
  def take!; end

  # Get a hash of counts for the values of a single field. For example,
  # if the following documents were in the database:
  #
  #   { _id: 1, age: 21 }
  #   { _id: 2, age: 21 }
  #   { _id: 3, age: 22 }
  #
  #   Model.tally("age")
  #
  # would yield the following result:
  #
  #   { 21 => 2, 22 => 1 }
  #
  # When tallying a field inside an array or embeds_many association:
  #
  #   { _id: 1, array: [ { x: 1 }, { x: 2 } ] }
  #   { _id: 2, array: [ { x: 1 }, { x: 2 } ] }
  #   { _id: 3, array: [ { x: 1 }, { x: 3 } ] }
  #
  #   Model.tally("array.x")
  #
  # The keys of the resulting hash are arrays:
  #
  #   { [ 1, 2 ] => 2, [ 1, 3 ] => 1 }
  #
  # Note that if tallying an element in an array of hashes, and the key
  # doesn't exist in some of the hashes, tally will not include those
  # nil keys in the resulting hash:
  #
  #   { _id: 1, array: [ { x: 1 }, { x: 2 }, { y: 3 } ] }
  #
  #   Model.tally("array.x")
  #   # => { [ 1, 2 ] => 1 }
  #
  # @param field [String | Symbol] The field name.
  # @return [Hash] The hash of counts.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#431
  def tally(field); end

  # Get the third document in the database for the criteria's selector.
  #
  # @example Get the third document.
  #   context.third
  # @return [Document | nil] The third document or nil if none is found.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#642
  def third; end

  # Get the third document in the database for the criteria's selector or
  # raise an error if none is found.
  #
  # @example Get the third document.
  #   context.third!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The third document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#656
  def third!; end

  # Get the third to last document in the database for the criteria's
  # selector.
  #
  # is found.
  #
  # @example Get the third to last document.
  #   context.third_to_last
  # @return [Document | nil] The third to last document or nil if none
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#742
  def third_to_last; end

  # Get the third to last document in the database for the criteria's
  # selector or raise an error if none is found.
  #
  # @example Get the third to last document.
  #   context.third_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] raises when there are no
  #   documents available.
  # @return [Document] The third to last document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#756
  def third_to_last!; end

  # Update the first matching document atomically.
  #
  # @example Update the first matching document.
  #   context.update({ "$set" => { name: "Smiths" }})
  # @option opts
  # @param attributes [Hash] The new attributes for the document.
  # @param opts [Hash] The update operation options.
  # @return [nil | false] False if no attributes were provided.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#507
  def update(attributes = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Update all the matching documents atomically.
  #
  # @example Update all the matching documents.
  #   context.update_all({ "$set" => { name: "Smiths" }})
  # @option opts
  # @param attributes [Hash] The new attributes for each document.
  # @param opts [Hash] The update operation options.
  # @return [nil | false] False if no attributes were provided.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#523
  def update_all(attributes = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Run an explain on the criteria.
  #
  # @example Explain the criteria.
  #   Band.where(name: "Depeche Mode").explain
  # @param options [Hash] customizable options (See Mongo::Collection::View::Explainable)
  # @return [Hash] The explain result.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#44
  def view; end

  private

  # source://mongoid//lib/mongoid/contextual/mongo.rb#879
  def _session; end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#883
  def acknowledged_write?; end

  # Apply the field limitations.
  #
  # @api private
  # @example Apply the field limitations.
  #   context.apply_fields
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#796
  def apply_fields; end

  # Apply an option.
  #
  # @api private
  # @example Apply the skip option.
  #   context.apply_option(:skip)
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#824
  def apply_option(name); end

  # Apply the options.
  #
  # @api private
  # @example Apply all options.
  #   context.apply_options
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#808
  def apply_options; end

  # Demongoize the value for the given field. If the field is nil or the
  # field is a translations field, the value is demongoized using its class.
  #
  # @api private
  # @param field [Field] The field to use to demongoize.
  # @param is_translation [true | false] The field we are retrieving is an
  #   _translations field.
  # @param value [Object] The value to demongoize.
  # @return [Object] The demongoized value.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#912
  def demongoize_with_field(field, value, is_translation); end

  # Get the documents the context should iterate.
  #
  # If the documents have been already preloaded by `Document::Loader`
  # instance, they will be used.
  #
  # @api private
  # @return [Array<Document> | Mongo::Collection::View] The docs to iterate.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#846
  def documents_for_iteration; end

  # Map the inverse sort symbols to the correct MongoDB values.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#833
  def inverse_sorting; end

  # Process the raw documents retrieved for #first/#last.
  #
  # @return [Array<Document> | Document] The list of documents or a
  #   single document.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#934
  def process_raw_docs(raw_docs, limit); end

  # @raise [Errors::DocumentNotFound]
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#963
  def raise_document_not_found_error; end

  # Recursively demongoize the given value. This method recursively traverses
  # the class tree to find the correct field to use to demongoize the value.
  #
  # @param field_name [String] The name of the field to demongoize.
  # @param is_translation [true | false] The field we are retrieving is an
  #   _translations field.
  # @param value [Object] The value to demongoize.
  # @return [Object] The demongoized value.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#896
  def recursive_demongoize(field_name, value, is_translation); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#967
  def retrieve_nth(n); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#980
  def retrieve_nth_to_last(n); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#984
  def retrieve_nth_to_last_with_limit(n, limit); end

  # source://mongoid//lib/mongoid/contextual/mongo.rb#971
  def retrieve_nth_with_limit(n, limit); end

  # Update the documents for the provided method.
  #
  # @api private
  # @example Update the documents.
  #   context.update_documents(attrs)
  # @param attributes [Hash] The updates.
  # @param method [Symbol] The method to use.
  # @return [true | false] If the update succeeded.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#784
  def update_documents(attributes, method = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Queries whether the current context is valid for use with
  # the #count_documents? predicate. A context is valid if it
  # does not include a `$where` operator.
  #
  # TODO: Remove this method when we remove the deprecated for_js API.
  # https://jira.mongodb.org/browse/MONGOID-5681
  #
  # @return [true | false] whether or not the current context
  #   excludes a `$where` operator.
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#951
  def valid_for_count_documents?(hash = T.unsafe(nil)); end

  # Yield to the document.
  #
  # @api private
  # @example Yield the document.
  #   context.yield_document(doc) do |doc|
  #   ...
  #   end
  # @param document [Document] The document to yield to.
  # @yield [doc]
  #
  # source://mongoid//lib/mongoid/contextual/mongo.rb#873
  def yield_document(document, &block); end
end

# Loads documents for the provided criteria.
#
# @api private
#
# source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#10
class Mongoid::Contextual::Mongo::DocumentsLoader
  include ::Mongoid::Association::EagerLoadable
  extend ::Forwardable

  # Instantiates the document loader instance and immediately schedules
  # its execution using the provided executor.
  #
  # @api private
  # @param criteria [Mongoid::Criteria] Criteria that specifies which
  #   documents should be loaded.
  # @param executor [Concurrent::AbstractExecutorService] Executor that
  #   is capable of running `Concurrent::Promises::Future` instances.
  # @param klass [Class] Mongoid model class to instantiate documents.
  #   All records obtained from the database will be converted to an
  #   instance of this class, if possible.
  # @param view [Mongo::Collection::View] The collection view to get
  #   records from the database.
  # @return [DocumentsLoader] a new instance of DocumentsLoader
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#89
  def initialize(view, klass, criteria, executor: T.unsafe(nil)); end

  # @api private
  # @return [Mongoid::Criteria] Criteria that specifies which documents should
  #   be loaded. Exposed here because `eager_loadable?` method from
  #   `Association::EagerLoadable` expects this to be available.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#75
  def criteria; end

  # @api private
  # @return [Mongoid::Criteria] Criteria that specifies which documents should
  #   be loaded. Exposed here because `eager_loadable?` method from
  #   `Association::EagerLoadable` expects this to be available.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#75
  def criteria=(_arg0); end

  # Loads records specified by `@criteria` from the database, and convert
  # them to Mongoid documents of `@klass` type.
  #
  # This method is called by the task (possibly asynchronous) scheduled
  # when creating an instance of the loader. However, this method can be
  # called directly, if it is desired to execute loading on the caller
  # thread immediately.
  #
  # Calling this method does not change the state of the loader.
  #
  # @api private
  # @return [Array<Mongoid::Document>] Array of document loaded from
  #   the database.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#152
  def execute; end

  # Returns false or true whether the loader is in pending state.
  #
  # Pending state means that the loader execution has been scheduled,
  # but has not been started yet.
  #
  # @api private
  # @return [true | false] true if the loader is in pending state,
  #   otherwise false.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#107
  def pending?; end

  # Returns false or true whether the loader is in started state.
  #
  # Started state means that the loader execution has been started.
  # Note that the loader stays in this state even after the execution
  # completed (successfully or failed).
  #
  # @api private
  # @return [true | false] true if the loader is in started state,
  #   otherwise false.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#121
  def started?; end

  # Mark the loader as unscheduled.
  #
  # If the loader is marked unscheduled, it will not be executed. The only
  # option to load the documents is to call `execute` method directly.
  #
  # Please note that if execution of a task has been already started,
  # unscheduling does not have any effect.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#134
  def unschedule; end

  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#14
  def value(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#14
  def value!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#14
  def wait(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#14
  def wait!(*_arg0, **_arg1, &_arg2); end

  private

  # Mark the loader as started if possible.
  #
  # @api private
  # @return [true | false] Whether the state was changed to :started.
  #
  # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#165
  def start; end

  class << self
    # Returns suitable executor according to Mongoid config options.
    #
    # @api private
    # @param name [String | Symbol] The query executor name, can be either
    #   :immediate or :global_thread_pool. Defaulted to `async_query_executor`
    #   config option.
    # @raise [Errors::InvalidQueryExecutor] If an unknown name is provided.
    # @return [Concurrent::ImmediateExecutor | Concurrent::ThreadPoolExecutor] The executor
    #   to be used to execute document loading tasks.
    #
    # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#61
    def executor(name = T.unsafe(nil)); end

    # Returns asynchronous executor to be used when async_query_executor config option
    # is set to :global_thread_pool. This executor runs operations on background threads
    # using a thread pool.
    #
    # @api private
    # @return [Concurrent::ThreadPoolExecutor] The executor
    #   to be used to execute document loading tasks.
    #
    # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#32
    def global_thread_pool_async_query_executor; end

    # Returns synchronous executor to be used when async_query_executor config option
    # is set to :immediate. This executor runs all operations on the current
    # thread, blocking as necessary.
    #
    # @api private
    # @return [Concurrent::ImmediateExecutor] The executor
    #   to be used to execute document loading tasks.
    #
    # source://mongoid//lib/mongoid/contextual/mongo/documents_loader.rb#22
    def immediate_executor; end
  end
end

# Options constant.
#
# source://mongoid//lib/mongoid/contextual/mongo.rb#29
Mongoid::Contextual::Mongo::OPTIONS = T.let(T.unsafe(nil), Array)

# Context object used for performing bulk query and persistence
# operations on a null set. The method interface of this class
# is consistent with Mongoid::Contextual::Mongo.
#
# source://mongoid//lib/mongoid/contextual/none.rb#12
class Mongoid::Contextual::None
  include ::Enumerable
  include ::Mongoid::Contextual::Aggregable::None
  include ::Mongoid::Contextual::Queryable

  # Create the new null context.
  #
  # @example Create the new context.
  #   Null.new(criteria)
  # @param criteria [Criteria] The criteria.
  # @return [None] a new instance of None
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#120
  def initialize(criteria); end

  # Check if the context is equal to the other object.
  #
  # @example Check equality.
  #   context == []
  # @param other [Array] The other array.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#27
  def ==(other); end

  # Returns the value of attribute criteria.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#17
  def criteria; end

  # Get the distinct field values in null context.
  #
  # @example Get the distinct values in null context.
  #   context.distinct(:name)
  # @param _field [String | Symbol] The name of the field.
  # @return [Array] An empty Array.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#39
  def distinct(_field); end

  # Iterate over the null context. There are no documents to iterate over
  # in this case.
  #
  # @example Iterate over the null context.
  #   context.each do |doc|
  #   puts doc.name
  #   end
  # @return [Enumerator] The enumerator.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#52
  def each; end

  # Do any documents exist for the context.
  #
  # @example Do any documents exist for given _id.
  #   context.exists?(BSON::ObjectId(...))
  # @example Do any documents exist for given conditions.
  #   context.exists?(name: "...")
  # @example Do any documents exist in the null context.
  #   context.exists?
  # @param id_or_conditions [Hash | Object | false] an _id to
  #   search for, a hash of conditions, nil or false.
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#76
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # Always returns nil.
  #
  # @example Get the fifth document in null context.
  #   context.fifth
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#256
  def fifth; end

  # Always raises an error.
  #
  # @example Get the fifth document in null context.
  #   context.fifth!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#266
  def fifth!; end

  # Always returns nil.
  #
  # @example Get the first document in null context.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [[] | nil] Empty array or nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#321
  def find_first(limit = T.unsafe(nil)); end

  # Always returns nil.
  #
  # @example Get the first document in null context.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [[] | nil] Empty array or nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#132
  def first(limit = T.unsafe(nil)); end

  # Always raises an error.
  #
  # @example Get the first document in null context.
  #   context.first!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#142
  def first!; end

  # Always returns nil.
  #
  # @example Get the fourth document in null context.
  #   context.fourth
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#236
  def fourth; end

  # Always raises an error.
  #
  # @example Get the fourth document in null context.
  #   context.fourth!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#246
  def fourth!; end

  # Returns the value of attribute klass.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#17
  def klass; end

  # Always returns nil.
  #
  # @example Get the last document in null context.
  #   context.last
  # @param limit [Integer] The number of documents to return.
  # @return [[] | nil] Empty array or nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#154
  def last(limit = T.unsafe(nil)); end

  # Always raises an error.
  #
  # @example Get the last document in null context.
  #   context.last!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#164
  def last!; end

  # Always returns zero.
  #
  # @example Get the length of null context.
  #   context.length
  # @return [Integer] Always zero.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#316
  def length; end

  # Always returns nil.
  #
  # @example Get the first document in null context.
  #   context.first
  # @param limit [Integer] The number of documents to return.
  # @return [[] | nil] Empty array or nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#322
  def one(limit = T.unsafe(nil)); end

  # Pick the field values in null context.
  #
  # @example Get the value for null context.
  #   context.pick(:name)
  # @param *_fields [[ String | Symbol ]...] Field(s) to pick.
  # @return [nil] Always return nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#98
  def pick(*_fields); end

  # Pluck the field values in null context.
  #
  # @example Get the values for null context.
  #   context.pluck(:name)
  # @param *_fields [[ String | Symbol ]...] Field(s) to pluck.
  # @return [Array] An empty Array.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#86
  def pluck(*_fields); end

  # Always returns nil.
  #
  # @example Get the second document in null context.
  #   context.second
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#196
  def second; end

  # Always raises an error.
  #
  # @example Get the second document in null context.
  #   context.second!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#206
  def second!; end

  # Always returns nil.
  #
  # @example Get the second to last document in null context.
  #   context.second_to_last
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#276
  def second_to_last; end

  # Always raises an error.
  #
  # @example Get the second to last document in null context.
  #   context.second_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#286
  def second_to_last!; end

  # Always returns zero.
  #
  # @example Get the length of null context.
  #   context.length
  # @return [Integer] Always zero.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#319
  def size; end

  # Returns nil or empty array.
  #
  # @example Take a document in null context.
  #   context.take
  # @param limit [Integer | nil] The number of documents to take or nil.
  # @return [[] | nil] Empty array or nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#176
  def take(limit = T.unsafe(nil)); end

  # Always raises an error.
  #
  # @example Take a document in null context.
  #   context.take!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#186
  def take!; end

  # Tally the field values in null context.
  #
  # @example Get the values for null context.
  #   context.tally(:name)
  # @param _field [String | Symbol] Field to tally.
  # @return [Hash] An empty Hash.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#110
  def tally(_field); end

  # Always returns nil.
  #
  # @example Get the third document in null context.
  #   context.third
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#216
  def third; end

  # Always raises an error.
  #
  # @example Get the third document in null context.
  #   context.third!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#226
  def third!; end

  # Always returns nil.
  #
  # @example Get the third to last document in null context.
  #   context.third_to_last
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#296
  def third_to_last; end

  # Always raises an error.
  #
  # @example Get the third to last document in null context.
  #   context.third_to_last!
  # @raise [Mongoid::Errors::DocumentNotFound] always raises.
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#306
  def third_to_last!; end

  private

  # @raise [Errors::DocumentNotFound]
  #
  # source://mongoid//lib/mongoid/contextual/none.rb#326
  def raise_document_not_found_error; end
end

# Mixin module which adds methods to Mongoid::Criteria that
# indicate the criteria query result will be an empty set.
#
# source://mongoid//lib/mongoid/contextual/queryable.rb#9
module Mongoid::Contextual::Queryable
  # Is the enumerable of matching documents empty?
  #
  # @example Is the context empty?
  #   context.blank?
  # @return [true | false] If the context is empty.
  #
  # source://mongoid//lib/mongoid/contextual/queryable.rb#22
  def blank?; end

  # Returns the value of attribute collection.
  #
  # source://mongoid//lib/mongoid/contextual/queryable.rb#14
  def collection; end

  # Returns the value of attribute criteria.
  #
  # source://mongoid//lib/mongoid/contextual/queryable.rb#14
  def criteria; end

  # Is the enumerable of matching documents empty?
  #
  # @example Is the context empty?
  #   context.blank?
  # @return [true | false] If the context is empty.
  #
  # source://mongoid//lib/mongoid/contextual/queryable.rb#25
  def empty?; end

  # Returns the value of attribute klass.
  #
  # source://mongoid//lib/mongoid/contextual/queryable.rb#14
  def klass; end
end

# This module contains the behavior of Mongoid's clone/dup of documents.
#
# source://mongoid//lib/mongoid/copyable.rb#7
module Mongoid::Copyable
  extend ::ActiveSupport::Concern

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents. If there is an _id field in
  # the embedded document, it will be maintained, unlike the root's _id.
  #
  # If cloning an embedded child, the embedded parent is not cloned and the
  # embedded_in association is not set.
  #
  # @example Clone the document.
  #   document.clone
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/copyable.rb#24
  def clone; end

  # Clone or dup the current +Document+. This will return all attributes with
  # the exception of the document's id, and will reset all the
  # instance variables.
  #
  # This clone also includes embedded documents. If there is an _id field in
  # the embedded document, it will be maintained, unlike the root's _id.
  #
  # If cloning an embedded child, the embedded parent is not cloned and the
  # embedded_in association is not set.
  #
  # @example Clone the document.
  #   document.clone
  # @return [Document] The new document.
  #
  # source://mongoid//lib/mongoid/copyable.rb#32
  def dup; end

  private

  # Clone the document attributes
  #
  # @api private
  # @example clone document
  #   model.clone_document
  #
  # source://mongoid//lib/mongoid/copyable.rb#77
  def clone_document; end

  # When cloning, if the document has localized fields we need to ensure they
  # are properly processed in the clone.
  #
  # @api private
  # @example Process localized attributes.
  #   model.process_localized_attributes(attributes)
  # @param attrs [Hash] The attributes.
  #
  # source://mongoid//lib/mongoid/copyable.rb#92
  def process_localized_attributes(klass, attrs); end

  class << self
    # Create clone of a document of the given klass with the given attributes
    # hash. This is used recursively so that embedded associations are cloned
    # safely.
    #
    # @param attrs [Hash] The hash of the attributes.
    # @param klass [Class] The class of the document to create.
    # @return [Document] The new document.
    #
    # source://mongoid//lib/mongoid/copyable.rb#44
    def clone_with_hash(klass, attrs); end
  end
end

# The +Criteria+ class is the core object needed in Mongoid to retrieve
# objects from the database. It is a DSL that essentially sets up the
# selector and options arguments that get passed on to a Mongo::Collection
# in the Ruby driver. Each method on the +Criteria+ returns self to they
# can be chained in order to create a readable criterion to be executed
# against the database.
#
# source://mongoid//lib/mongoid/criteria/findable.rb#5
class Mongoid::Criteria
  include ::Enumerable
  include ::Mongoid::Contextual
  include ::Mongoid::Criteria::Queryable::Storable
  include ::Mongoid::Criteria::Queryable::Expandable
  include ::Mongoid::Criteria::Queryable::Mergeable
  include ::Mongoid::Criteria::Queryable::Aggregable
  include ::Mongoid::Criteria::Queryable::Selectable
  include ::Mongoid::Criteria::Queryable::Optional
  include ::Mongoid::Criteria::Queryable
  include ::Mongoid::Criteria::Findable
  include ::Mongoid::Criteria::Inspectable
  include ::Mongoid::Criteria::Includable
  include ::Mongoid::Criteria::Marshalable
  include ::Mongoid::Criteria::Modifiable
  include ::Mongoid::Criteria::Scopable
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  include ::Mongoid::Criteria::Options
  extend ::Mongoid::Clients::Options::ClassMethods

  # Initialize the new criteria.
  #
  # @example Init the new criteria.
  #   Criteria.new(Band)
  # @param klass [Class] The model class.
  # @return [Criteria] a new instance of Criteria
  #
  # source://mongoid//lib/mongoid/criteria.rb#266
  def initialize(klass); end

  # Returns true if the supplied +Enumerable+ or +Criteria+ is equal to the results
  # of this +Criteria+ or the criteria itself.
  #
  # @note This will force a database load when called if an enumerable is passed.
  # @param other [Object] The other +Enumerable+ or +Criteria+ to compare to.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/criteria.rb#111
  def ==(other); end

  # @api private
  #
  # source://mongoid//lib/mongoid/criteria.rb#26
  def _enumerable_find(*_arg0); end

  # @api private
  #
  # source://mongoid//lib/mongoid/criteria.rb#33
  def _findable_find(*args); end

  # Needed to properly get a criteria back as json
  #
  # @example Get the criteria as json.
  #   Person.where(:title => "Sir").as_json
  # @param options [Hash] Options to pass through to the serializer.
  # @return [String] The JSON string.
  #
  # source://mongoid//lib/mongoid/criteria.rb#173
  def as_json(options = T.unsafe(nil)); end

  # Returns the value of attribute association.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def association; end

  # Sets the attribute association
  #
  # @param value the value to set the attribute association to.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def association=(_arg0); end

  # Get the documents from the embedded criteria.
  #
  # @example Get the documents.
  #   criteria.documents
  # @return [Array<Document>] The documents.
  #
  # source://mongoid//lib/mongoid/criteria.rb#183
  def documents; end

  # Set the embedded documents on the criteria.
  #
  # @example Set the documents.
  # @param docs [Array<Document>] The embedded documents.
  # @return [Array<Document>] The embedded documents.
  #
  # source://mongoid//lib/mongoid/criteria.rb#194
  def documents=(docs); end

  # Returns the value of attribute embedded.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def embedded; end

  # Sets the attribute embedded
  #
  # @param value the value to set the attribute embedded to.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def embedded=(_arg0); end

  # Is the criteria for embedded documents?
  #
  # @example Is the criteria for embedded documents?
  #   criteria.embedded?
  # @return [true | false] If the criteria is embedded.
  #
  # source://mongoid//lib/mongoid/criteria.rb#204
  def embedded?; end

  # Is the criteria an empty but chainable criteria?
  #
  # @example Is the criteria a none criteria?
  #   criteria.empty_and_chainable?
  # @return [true | false] If the criteria is a none.
  #
  # source://mongoid//lib/mongoid/criteria.rb#335
  def empty_and_chainable?; end

  # Extract a single id from the provided criteria. Could be in an $and
  # query or a straight _id query.
  #
  # @example Extract the id.
  #   criteria.extract_id
  # @return [Object] The id.
  #
  # source://mongoid//lib/mongoid/criteria.rb#215
  def extract_id; end

  # Adds a criterion to the +Criteria+ that specifies additional options
  # to be passed to the Ruby driver, in the exact format for the driver.
  #
  # criteria.extras(:limit => 20, :skip => 40)
  #
  # @example Add extra params to the criteria.
  # @param extras [Hash] The extra driver options.
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#228
  def extras(extras); end

  # Get the list of included fields.
  #
  # @example Get the field list.
  #   criteria.field_list
  # @return [Array<String>] The fields.
  #
  # source://mongoid//lib/mongoid/criteria.rb#240
  def field_list; end

  # Finds one or many documents given the provided _id values, or filters
  # the documents in the current scope in the application process space
  # after loading them if needed.
  #
  # If this method is not given a block, it delegates to +Findable#find+
  # and finds one or many documents for the provided _id values.
  #
  # If this method is given a block, it delegates to +Enumerable#find+ and
  # returns the first document of those found by the current Crieria object
  # for which the block returns a truthy value.
  #
  # Note that the "default proc" argument of Enumerable is not specially
  # treated by Mongoid - the decision between delegating to +Findable+ vs
  # +Enumerable+ is made solely based on whether +find+ is passed a block.
  #
  # @example Finds a document by its _id, invokes Findable#find.
  #   critera.find("1234")
  # @example Finds the first matching document using a block using the default Proc, invokes Enumerable#find.
  #   criteria.find(-> { "Default Band" }) { |item| item.name == "Milwaukee Mode" }
  # @example Finds the first matching document using a block, invokes Enumerable#find.
  #   criteria.find { |item| item.name == "Depeche Mode" }
  # @example Tries to find a document whose _id is the stringification of the provided Proc, typically failing.
  #   enumerator = criteria.find(-> { "Default Band" })
  # @note Each argument can be an individual id, an array of ids or
  #   a nested array. Each array will be flattened.
  # @param &block Optional block to pass.
  # @param *args [[ Object | Array<Object> ]...] The id(s).
  # @raise Errors::DocumentNotFound If the parameters were _id values and
  #   not all documents are found and the +raise_not_found_error+
  #   Mongoid configuration option is truthy.
  # @return [Document | Array<Document> | nil] A document or matching documents.
  # @see https://ruby-doc.org/core/Enumerable.html#method-i-find
  # @yield [Object] Yields each enumerable element to the block.
  #
  # source://mongoid//lib/mongoid/criteria.rb#157
  def find(*args, &block); end

  # Find documents by the provided javascript and scope. Uses a $where but is
  # different from +Criteria#where+ in that it will pass a code object to the
  # query instead of a pure string. Safe against Javascript injection
  # attacks.
  #
  # @deprecated
  # @example Find by javascript.
  #   Band.for_js("this.name = param", param: "Tool")
  # @param javascript [String] The javascript to execute in the $where.
  # @param scope [Hash] The scope for the code.
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#500
  def for_js(*args, **_arg1, &block); end

  # When freezing a criteria we need to initialize the context first
  # otherwise the setting of the context on attempted iteration will raise a
  # runtime error.
  #
  # @example Freeze the criteria.
  #   criteria.freeze
  # @return [Criteria] The frozen criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#256
  def freeze; end

  # Returns the value of attribute klass.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def klass; end

  # Sets the attribute klass
  #
  # @param value the value to set the attribute klass to.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def klass=(_arg0); end

  # Merges another object with this +Criteria+ and returns a new criteria.
  # The other object may be a +Criteria+ or a +Hash+. This is used to
  # combine multiple scopes together, where a chained scope situation
  # may be desired.
  #
  # @example Merge the criteria with a hash. The hash must contain a klass
  #   key that specifies the model class for the criteria and the key/value
  #   pairs correspond to method names/args.
  #
  #   criteria.merge({
  #   klass: Band,
  #   where: { name: "Depeche Mode" },
  #   order_by: { name: 1 }
  #   })
  # @example Merge the criteria with another criteria.
  #   criteria.merge(other_criteria)
  # @param other [Criteria | Hash] The other criterion to merge with.
  # @return [Criteria] A cloned self.
  #
  # source://mongoid//lib/mongoid/criteria.rb#294
  def merge(other); end

  # Merge the other criteria into this one.
  #
  # @example Merge another criteria into this criteria.
  #   criteria.merge(Person.where(name: "bob"))
  # @param other [Criteria | Hash] The criteria to merge in.
  # @return [Criteria] The merged criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#308
  def merge!(other); end

  # Returns a criteria that will always contain zero results and never hits
  # the database.
  #
  # @example Return a none criteria.
  #   criteria.none
  # @return [Criteria] The none criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#325
  def none; end

  # Overriden to include _type in the fields.
  #
  # @example Limit the fields returned from the database.
  #   Band.only(:name)
  # @param *args [[ Symbol | Array<Symbol> ]...] The field name(s).
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#347
  def only(*args); end

  # Returns the value of attribute parent_document.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def parent_document; end

  # Sets the attribute parent_document
  #
  # @param value the value to set the attribute parent_document to.
  #
  # source://mongoid//lib/mongoid/criteria.rb#101
  def parent_document=(_arg0); end

  # Set the read preference for the criteria.
  #
  # @example Set the read preference.
  #   criteria.read(mode: :primary_preferred)
  # @param value [Hash] The mode preference.
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#367
  def read(value = T.unsafe(nil)); end

  # Returns true if criteria responds to the given method.
  #
  # @example Does the criteria respond to the method?
  #   crtiteria.respond_to?(:each)
  # @param include_private [true | false] Whether to include privates.
  # @param name [Symbol] The name of the class method on the +Document+.
  # @return [true | false] If the criteria responds to the method.
  #
  # source://mongoid//lib/mongoid/criteria.rb#395
  def respond_to?(name, include_private = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/criteria.rb#399
  def to_ary(*_arg0); end

  # Convenience for objects that want to be merged into a criteria.
  #
  # @deprecated
  # @example Convert to a criteria.
  #   criteria.to_criteria
  # @return [Criteria] self.
  #
  # source://mongoid//lib/mongoid/criteria.rb#408
  def to_criteria(*args, **_arg1, &block); end

  # Convert the criteria to a proc.
  #
  # @example Convert the criteria to a proc.
  #   criteria.to_proc
  # @return [Proc] The wrapped criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#419
  def to_proc; end

  # Adds a criterion to the +Criteria+ that specifies a type or an Array of
  # types that must be matched.
  #
  # @example Match only specific models.
  #   criteria.type('Browser')
  #   criteria.type(['Firefox', 'Browser'])
  # @param types [Array<String>] The types to match against.
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#433
  def type(types); end

  # This is the general entry point for most MongoDB queries. This either
  # creates a standard field: value selection, and expanded selection with
  # the use of hash methods, or a $where selection if a string is provided.
  #
  # @example Add a javascript selection.
  #   criteria.where("this.name == 'syd'")
  # @example Add a standard selection.
  #   criteria.where(name: "syd")
  # @param *args [[ Hash | String ]...] The standard selection
  #   or javascript string.
  # @raise [UnsupportedJavascript] If provided a string and the criteria
  #   is embedded.
  # @return [Criteria] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria.rb#454
  def where(*args); end

  # Overriden to exclude _id from the fields.
  #
  # @example Exclude fields returned from the database.
  #   Band.without(:name)
  # @param *args [Symbol...] The field name(s).
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#381
  def without(*args); end

  # Get a version of this criteria without the options.
  #
  # @example Get the criteria without options.
  #   criteria.without_options
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria.rb#480
  def without_options; end

  private

  # Are documents in the query missing, and are we configured to raise an
  # error?
  #
  # @api private
  # @example Check for missing documents.
  #   criteria.check_for_missing_documents!([], [ 1 ])
  # @param ids [Array<Object>] The ids.
  # @param result [Array<Document>] The result.
  # @raise [Errors::DocumentNotFound] If none are found and raising an
  #   error.
  #
  # source://mongoid//lib/mongoid/criteria.rb#526
  def check_for_missing_documents!(result, ids); end

  # Clone or dup the current +Criteria+. This will return a new criteria with
  # the selector, options, klass, embedded options, etc intact.
  #
  # @api private
  # @example Clone a criteria.
  #   criteria.clone
  # @example Dup a criteria.
  #   criteria.dup
  # @param other [Criteria] The criteria getting cloned.
  # @return [nil] nil.
  #
  # source://mongoid//lib/mongoid/criteria.rb#546
  def initialize_copy(other); end

  # For models where inheritance is at play we need to add the type
  # selection.
  #
  # @example Add the type selection.
  #   criteria.merge_type_selection
  # @return [true | false] If type selection was added.
  #
  # source://mongoid//lib/mongoid/criteria.rb#583
  def merge_type_selection; end

  # Used for chaining +Criteria+ scopes together in the for of class methods
  # on the +Document+ the criteria is for.
  #
  # @example Handle method missing.
  #   criteria.method_missing(:name)
  # @param *args [Object...] The arguments.
  # @param name [Symbol] The method name.
  # @return [Object] The result of the method call.
  #
  # source://mongoid//lib/mongoid/criteria.rb#564
  def method_missing(name, *args, **_arg2, &block); end

  # Get a new selector with type selection in it.
  #
  # @api private
  # @example Get a selector with type selection.
  #   criteria.selector_with_type_selection
  # @return [Hash] The selector.
  #
  # source://mongoid//lib/mongoid/criteria.rb#626
  def selector_with_type_selection; end

  # Is the criteria type selectable?
  #
  # @api private
  # @example If the criteria type selectable?
  #   criteria.type_selectable?
  # @return [true | false] If type selection should be added.
  #
  # source://mongoid//lib/mongoid/criteria.rb#595
  def type_selectable?; end

  # Get the selector for type selection.
  #
  # @api private
  # @example Get a type selection hash.
  #   criteria.type_selection
  # @return [Hash] The type selection.
  #
  # source://mongoid//lib/mongoid/criteria.rb#609
  def type_selection; end

  class << self
    # Convert the given hash to a criteria. Will iterate over each keys in the
    # hash which must correspond to an allowed method on a criteria object. The hash
    # can include a "klass" key that specifies the model class for the criteria.
    #
    # @deprecated This method is deprecated and will
    #   be removed in a future release.
    # @example Convert the hash to a criteria.
    #   Criteria.from_hash({ klass: Band, where: { name: "Depeche Mode" })
    # @param hash [Hash] The hash to convert.
    # @raise [ArgumentError] If a method is not allowed in from_hash.
    # @return [Criteria] The criteria.
    #
    # source://mongoid//lib/mongoid/criteria.rb#83
    def from_hash(*args, **_arg1, &block); end
  end
end

# Allowed methods for from_hash to prevent arbitrary method execution.
# Only query-building methods are allowed, not execution or modification methods.
#
# source://mongoid//lib/mongoid/criteria.rb#46
Mongoid::Criteria::ALLOWED_FROM_HASH_METHODS = T.let(T.unsafe(nil), Array)

# Static array used to check with method missing - we only need to ever
# instantiate once.
#
# source://mongoid//lib/mongoid/criteria.rb#99
Mongoid::Criteria::CHECK = T.let(T.unsafe(nil), Array)

# Mixin module included in Mongoid::Criteria which adds the ability
# to find document by id.
#
# source://mongoid//lib/mongoid/criteria/findable.rb#9
module Mongoid::Criteria::Findable
  # Execute the criteria or raise an error if no documents found.
  #
  # @example Execute or raise
  #   criteria.execute_or_raise(id)
  # @param ids [Object] The arguments passed.
  # @param multi [true | false] Whether there arguments were a list,
  #   and therefore the return value should be an array.
  # @raise [Errors::DocumentNotFound] If nothing returned.
  # @return [Document | Array<Document>] The document(s).
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#23
  def execute_or_raise(ids, multi); end

  # Find the matching document(s) in the criteria for the provided id(s).
  #
  # @example Find by an id.
  #   criteria.find(BSON::ObjectId.new)
  # @example Find by multiple ids.
  #   criteria.find([ BSON::ObjectId.new, BSON::ObjectId.new ])
  # @note Each argument can be an individual id, an array of ids or
  #   a nested array. Each array will be flattened.
  # @param *args [[ Object | Array<Object> ]...] The id(s) to find.
  # @return [Document | Array<Document>] The matching document(s).
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#43
  def find(*args); end

  # Adds a criterion to the +Criteria+ that specifies an id that must be matched.
  #
  # @example Add a single id criteria.
  #   criteria.for_ids([ 1 ])
  # @example Add multiple id criteria.
  #   criteria.for_ids([ 1, 2 ])
  # @param ids [Array] The array of ids.
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#60
  def for_ids(ids); end

  # Get the documents from the identity map, and if not found hit the
  # database.
  #
  # @example Get the documents from the map or criteria.
  #   criteria.multiple_from_map_or_db(ids)
  # @param ids [Array<Object>] The searched ids.
  # @return [Array<Document>] The found documents.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#78
  def multiple_from_db(ids); end

  private

  # Get documents from the database only.
  #
  # @api private
  # @example Get documents from the database.
  #   criteria.from_database(ids)
  # @param ids [Array<Object>] The ids to fetch with.
  # @return [Array<Document>] The matching documents.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#108
  def from_database(ids); end

  # source://mongoid//lib/mongoid/criteria/findable.rb#112
  def from_database_selector(ids); end

  # Get the finder used to generate the id query.
  #
  # @api private
  # @example Get the id finder.
  #   criteria.id_finder
  # @return [Symbol] The name of the finder method.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#94
  def id_finder; end

  # Convert all the ids to their proper types.
  #
  # @api private
  # @example Convert the ids.
  #   criteria.mongoize_ids(ids)
  # @param ids [Array<Object>] The ids to convert.
  # @return [Array<Object>] The converted ids.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#130
  def mongoize_ids(ids); end

  # Indicates whether the given arguments array is a list of values.
  # Used by the +find+ method to determine whether to return an array
  # or single value.
  #
  # @example Are these arguments a list of values?
  #   multi_args?([ 1, 2, 3 ]) #=> true
  # @param args [Array] The arguments.
  # @return [true | false] Whether the arguments are a list.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#168
  def multi_args?(args); end

  # Convert args to the +#find+ method into a flat array of ids.
  #
  # @example Get the ids.
  #   prepare_ids_for_find([ 1, [ 2, 3 ] ])
  # @param args [Array<Object>] The arguments.
  # @return [Array] The array of ids.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#145
  def prepare_ids_for_find(args); end

  # Convenience method of raising an invalid find error.
  #
  # @example Raise the error.
  #   criteria.raise_invalid
  # @raise [Errors::InvalidFind] The error.
  #
  # source://mongoid//lib/mongoid/criteria/findable.rb#178
  def raise_invalid; end
end

# Module providing functionality for parsing (nested) inclusion definitions.
#
# source://mongoid//lib/mongoid/criteria/includable.rb#8
module Mongoid::Criteria::Includable
  # Eager loads all the provided associations. Will load all the documents
  # into the identity map whose ids match based on the extra query for the
  # ids.
  #
  # @example Eager load the provided associations.
  #   Person.includes(:posts, :game)
  # @note This will work for embedded associations that reference another
  #   collection via belongs_to as well.
  # @note Eager loading brings all the documents into memory, so there is a
  #   sweet spot on the performance gains. Internal benchmarks show that
  #   eager loading becomes slower around 100k documents, but this will
  #   naturally depend on the specific application.
  # @param *relations [[ Symbol | Hash ]...] The names of the association(s)
  #   to eager load.
  # @return [Criteria] The cloned criteria.
  #
  # source://mongoid//lib/mongoid/criteria/includable.rb#29
  def includes(*relations); end

  # Get a list of criteria that are to be executed for eager loading.
  #
  # @return [Array<Mongoid::Association::Relatable>] The inclusions.
  #
  # source://mongoid//lib/mongoid/criteria/includable.rb#37
  def inclusions; end

  # Set the inclusions for the criteria.
  #
  # @param value [Array<Mongoid::Association::Relatable>] The inclusions.
  # @return [Array<Mongoid::Association::Relatable>] The new inclusions.
  #
  # source://mongoid//lib/mongoid/criteria/includable.rb#46
  def inclusions=(value); end

  private

  # Add an inclusion definition to the list of inclusions for the criteria.
  #
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param parent [String] The name of the association above this one in
  #   the inclusion tree, if it is a nested inclusion.
  #
  # source://mongoid//lib/mongoid/criteria/includable.rb#57
  def add_inclusion(association, parent = T.unsafe(nil)); end

  # Iterate through the list of relations and create the inclusions list.
  #
  # @param *relations_list [[ Symbol | Hash | Array<Symbol | Hash> ]...] The names of the association(s) to eager load.
  # @param _parent_class [Class | String | Symbol] The class from which the
  #   association originates.
  # @param parent [String] The name of the association above this one in
  #   the inclusion tree, if it is a nested inclusion.
  #
  # source://mongoid//lib/mongoid/criteria/includable.rb#76
  def extract_includes_list(_parent_class, parent, *relations_list); end
end

# Mixin module included in Mongoid::Criteria which adds custom
# +#inspect+ method functionality.
#
# source://mongoid//lib/mongoid/criteria/inspectable.rb#9
module Mongoid::Criteria::Inspectable
  # Get a pretty string representation of the criteria, including the
  # selector, options, matching count and documents for inspection.
  #
  # @example Inspect the criteria.
  #   criteria.inspect
  # @return [String] The inspection string.
  #
  # source://mongoid//lib/mongoid/criteria/inspectable.rb#18
  def inspect; end
end

# Mixin module for Mongoid::Criteria which adds custom
# Marshal.dump functionality.
#
# source://mongoid//lib/mongoid/criteria/marshalable.rb#9
module Mongoid::Criteria::Marshalable
  # Provides the data needed to Marshal.dump a criteria.
  #
  # Note :mongo is written here for backwards compatibility with Mongoid 7
  # and earlier.
  #
  # @example Dump the criteria.
  #   Marshal.dump(criteria)
  # @return [Array<Object>] The dumped data.
  #
  # source://mongoid//lib/mongoid/criteria/marshalable.rb#20
  def marshal_dump; end

  # Resets the criteria object after a Marshal.load
  #
  # @example Load the criteria.
  #   Marshal.load(criteria)
  # @param data [Array] The raw data.
  #
  # source://mongoid//lib/mongoid/criteria/marshalable.rb#31
  def marshal_load(data); end

  private

  # source://mongoid//lib/mongoid/criteria/marshalable.rb#45
  def dump_hash(name); end

  # source://mongoid//lib/mongoid/criteria/marshalable.rb#52
  def load_hash(hash_class, raw); end
end

# Mixin module for Mongoid::Criteria which adds the ability
# to build or create new documents with attributes initialized
# to the conditions of the criteria.
#
# source://mongoid//lib/mongoid/criteria/modifiable.rb#10
module Mongoid::Criteria::Modifiable
  # Build a document given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # @example Build with selectors getting ignored.
  #   Person.where(:age.gt => 5).build
  # @example build the document.
  #   Person.where(:title => "Sir").build
  # @return [Document] A non-persisted document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#26
  def build(attrs = T.unsafe(nil), &block); end

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # @example Create the document.
  #   Person.where(:title => "Sir").create
  # @example Create with selectors getting ignored.
  #   Person.where(:age.gt => 5).create
  # @return [Document] A newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#41
  def create(attrs = T.unsafe(nil), &block); end

  # Create a document in the database given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  # If validation fails, an error will be raised.
  #
  # @example Create the document.
  #   Person.where(:title => "Sir").create
  # @example Create with selectors getting ignored.
  #   Person.where(:age.gt => 5).create
  # @raise [Errors::Validations] on a validation error.
  # @return [Document] A newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#58
  def create!(attrs = T.unsafe(nil), &block); end

  # @api private
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#14
  def create_attrs; end

  # Define attributes with which new documents will be created.
  #
  # Note that if `find_or_create_by` is called after this in a method chain, the attributes in
  # the query will override those from this method.
  #
  # @example Define attributes to be used when a new document is created.
  #   Person.create_with(job: 'Engineer').find_or_create_by(employer: 'MongoDB')
  # @return [Mongoid::Criteria] A criteria.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#71
  def create_with(attrs = T.unsafe(nil)); end

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied.
  #
  # @example Find or create the document.
  #   Person.find_or_create_by(:attribute => "value")
  # @param attrs [Hash] The attributes to check.
  # @return [Document] A matching or newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#87
  def find_or_create_by(attrs = T.unsafe(nil), &block); end

  # Find the first +Document+ given the conditions, or creates a new document
  # with the conditions that were supplied. If validation fails an
  # exception will be raised.
  #
  # @example Find or create the document.
  #   Person.find_or_create_by!(:attribute => "value")
  # @param attrs [Hash] The attributes to check.
  # @raise [Errors::Validations] on validation error.
  # @return [Document] A matching or newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#103
  def find_or_create_by!(attrs = T.unsafe(nil), &block); end

  # Find the first +Document+ given the conditions, or initializes a new document
  # with the conditions that were supplied.
  #
  # @example Find or initialize the document.
  #   Person.find_or_initialize_by(:attribute => "value")
  # @param attrs [Hash] The attributes to check.
  # @return [Document] A matching or newly initialized document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#116
  def find_or_initialize_by(attrs = T.unsafe(nil), &block); end

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes.
  #
  # @example First or create the document.
  #   Person.where(name: "Jon").first_or_create(attribute: "value")
  # @param attrs [Hash] The additional attributes to add.
  # @return [Document] A matching or newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#129
  def first_or_create(attrs = T.unsafe(nil), &block); end

  # Find the first +Document+, or creates a new document
  # with the conditions that were supplied plus attributes and will
  # raise an error if validation fails.
  #
  # @example First or create the document.
  #   Person.where(name: "Jon").first_or_create!(attribute: "value")
  # @param attrs [Hash] The additional attributes to add.
  # @return [Document] A matching or newly created document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#143
  def first_or_create!(attrs = T.unsafe(nil), &block); end

  # Find the first +Document+, or initializes a new document
  # with the conditions that were supplied plus attributes.
  #
  # @example First or initialize the document.
  #   Person.where(name: "Jon").first_or_initialize(attribute: "value")
  # @param attrs [Hash] The additional attributes to add.
  # @return [Document] A matching or newly initialized document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#156
  def first_or_initialize(attrs = T.unsafe(nil), &block); end

  # Build a document given the selector and return it.
  # Complex criteria, such as $in and $or operations will get ignored.
  #
  # @example Build with selectors getting ignored.
  #   Person.where(:age.gt => 5).build
  # @example build the document.
  #   Person.where(:title => "Sir").build
  # @return [Document] A non-persisted document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#29
  def new(attrs = T.unsafe(nil), &block); end

  private

  # Create a document given the provided method and attributes from the
  # existing selector.
  #
  # @api private
  # @example Create a new document.
  #   criteria.create_document(:new, {})
  # @param attrs [Hash] Additional attributes to use.
  # @param method [Symbol] Either :new or :create.
  # @return [Document] The new or saved document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#174
  def create_document(method, attrs = T.unsafe(nil), &block); end

  # Find the first object or create/initialize it.
  #
  # @api private
  # @example Find or perform an action.
  #   Person.find_or(:create, :name => "Dev")
  # @param attrs [Hash] The attributes to query or set.
  # @param method [Symbol] The method to invoke.
  # @return [Document] The first or new document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#204
  def find_or(method, attrs = T.unsafe(nil), &block); end

  # Find the first document or create/initialize it.
  #
  # @api private
  # @example First or perform an action.
  #   Person.first_or(:create, :name => "Dev")
  # @param attrs [Hash] The attributes to query or set.
  # @param method [Symbol] The method to invoke.
  # @return [Document] The first or new document.
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#219
  def first_or(method, attrs = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#231
  def invalid_embedded_doc?(value); end

  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/criteria/modifiable.rb#225
  def invalid_key?(hash, key); end
end

# Module containing functionality for getting options on a Criteria object.
#
# source://mongoid//lib/mongoid/criteria/options.rb#8
module Mongoid::Criteria::Options
  private

  # source://mongoid//lib/mongoid/criteria/options.rb#20
  def clear_persistence_context(original_cluster, original_context); end

  # source://mongoid//lib/mongoid/criteria/options.rb#12
  def persistence_context; end

  # source://mongoid//lib/mongoid/criteria/options.rb#16
  def set_persistence_context(options); end
end

# A queryable is any object that needs queryable's dsl injected into it to build
# MongoDB queries. For example, a Mongoid::Criteria is an Queryable.
#
# @example Include queryable functionality.
#   class Criteria
#   include Queryable
#   end
#
# source://mongoid//lib/mongoid/criteria/queryable/expandable.rb#6
module Mongoid::Criteria::Queryable
  include ::Mongoid::Criteria::Queryable::Storable
  include ::Mongoid::Criteria::Queryable::Expandable
  include ::Mongoid::Criteria::Queryable::Mergeable
  include ::Mongoid::Criteria::Queryable::Aggregable
  include ::Mongoid::Criteria::Queryable::Selectable
  include ::Mongoid::Criteria::Queryable::Optional

  # Initialize the new queryable. Will yield itself to the block if a block
  # is provided for objects that need additional behavior.
  #
  # @api private
  # @example Initialize the queryable.
  #   Queryable.new
  # @param aliased_associations [Hash] The optional aliased associations.
  # @param aliases [Hash] The optional field aliases.
  # @param associations [Hash] The optional associations.
  # @param driver [Symbol] The driver being used.
  # @param serializers [Hash] The optional field serializers.
  # @yield [_self]
  # @yieldparam _self [Mongoid::Criteria::Queryable] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/criteria/queryable.rb#69
  def initialize(aliases = T.unsafe(nil), serializers = T.unsafe(nil), associations = T.unsafe(nil), aliased_associations = T.unsafe(nil)); end

  # Is this queryable equal to another object? Is true if the selector and
  # options are equal.
  #
  # @example Are the objects equal?
  #   queryable == criteria
  # @param other [Object] The object to compare against.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/criteria/queryable.rb#51
  def ==(other); end

  # Returns the value of attribute aliases.
  #
  # source://mongoid//lib/mongoid/criteria/queryable.rb#37
  def aliases; end

  # Returns the value of attribute serializers.
  #
  # source://mongoid//lib/mongoid/criteria/queryable.rb#40
  def serializers; end

  private

  # Handle the creation of a copy via #clone or #dup.
  #
  # @example Handle copy initialization.
  #   queryable.initialize_copy(criteria)
  # @param other [Queryable] The original copy.
  #
  # source://mongoid//lib/mongoid/criteria/queryable.rb#84
  def initialize_copy(other); end
end

# Provides a DSL around crafting aggregation framework commands.
#
# source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#9
module Mongoid::Criteria::Queryable::Aggregable
  extend ::Mongoid::Criteria::Queryable::Macroable

  # Sets the attribute aggregating
  #
  # @param value the value to set the attribute aggregating to.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#16
  def aggregating=(_arg0); end

  # Has the aggregable enter an aggregation state. Ie, are only aggregation
  # operations allowed at this point on.
  #
  # @example Is the aggregable aggregating?
  #   aggregable.aggregating?
  # @return [true | false] If the aggregable is aggregating.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#25
  def aggregating?; end

  # Add a group ($group) operation to the aggregation pipeline.
  #
  # @example Add a group operation being verbose.
  #   aggregable.group(count: { "$sum" => 1 }, max: { "$max" => "likes" })
  # @example Add a group operation using symbol shortcuts.
  #   aggregable.group(:count.sum => 1, :max.max => "likes")
  # @param operation [Hash] The group operation.
  # @return [Aggregable] The aggregable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#40
  def group(operation); end

  # Returns the value of attribute pipeline.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#13
  def pipeline; end

  # Add a projection ($project) to the aggregation pipeline.
  #
  # @example Add a projection to the pipeline.
  #   aggregable.project(author: 1, name: 0)
  # @param operation [Hash] The projection to make.
  # @return [Aggregable] The aggregable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#62
  def project(operation = T.unsafe(nil)); end

  # Add an unwind ($unwind) to the aggregation pipeline.
  #
  # @example Add an unwind to the pipeline.
  #   aggregable.unwind(:field)
  # @param field [String | Symbol] The name of the field to unwind.
  # @return [Aggregable] The aggregable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#76
  def unwind(field); end

  private

  # Add the aggregation operation.
  #
  # @api private
  # @example Aggregate on the operation.
  #   aggregation(operation) do |pipeline|
  #   pipeline.push("$project" => operation)
  #   end
  # @param operation [Hash] The operation for the pipeline.
  # @return [Aggregable] The cloned aggregable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/aggregable.rb#96
  def aggregation(operation); end
end

# This module encapsulates methods that expand various high level
# query forms to the MongoDB hash condition selector syntax.
#
# @api private
# @example Example high level form.
#   Band.where(:foo.gt => 5)
#
# source://mongoid//lib/mongoid/criteria/queryable/expandable.rb#14
module Mongoid::Criteria::Queryable::Expandable
  private

  # Expand criterion values to arrays, to be used with operators that
  # take an array as argument such as $in.
  #
  # @api private
  # @example Convert all the values to arrays.
  #   selectable.with_array_values({ key: 1...4 })
  # @param criterion [Hash] The criterion.
  # @return [Hash] The $in friendly criterion with array values.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/expandable.rb#56
  def expand_condition_to_array_values(criterion); end

  # Expands the specified condition to MongoDB syntax.
  #
  # This method is meant to be called when processing the items of
  # a condition hash and the key and the value of each item are
  # already available separately.
  #
  # The following parameter forms are accepted:
  #
  # - field is a string or symbol; value is the field query expresision
  # - field is a Key instance; value is the field query expression
  # - field is a string corresponding to a MongoDB operator; value is
  #   the operator value expression.
  #
  # This method expands the field-value combination to the MongoDB
  # selector syntax and returns an array of
  # [expanded key, expanded value]. The expanded key is converted to
  # a string if it wasn't already a string.
  #
  # @api private
  # @param field [String | Symbol | Key] The field to expand.
  # @param value [Object] The field's value.
  # @return [Array<String, Object>] The expanded field and value.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/expandable.rb#40
  def expand_one_condition(field, value); end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#7
module Mongoid::Criteria::Queryable::Extensions; end

# Adds query type-casting behavior to Array class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#10
module Mongoid::Criteria::Queryable::Extensions::Array
  # Combine the two objects using the add strategy.
  #
  # @example Add the object to the array.
  #   [ 1, 2, 3 ].__add__(4)
  # @param object [Object] The object to add.
  # @return [Object] The result of the add.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#20
  def __add__(object); end

  # Return the object as an array.
  #
  # @example Get the array.
  #   [ 1, 2 ].__array__
  # @return [Array] self
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#30
  def __array__; end

  # Makes a deep copy of the array, deep copying every element inside the
  # array.
  #
  # @example Get a deep copy of the array.
  #   [ 1, 2, 3 ].__deep_copy__
  # @return [Array] The deep copy of the array.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#39
  def __deep_copy__; end

  # Evolve the array into an array of mongo friendly dates. (Times at
  # midnight).
  #
  # @example Evolve the array to dates.
  #   [ Date.new(2010, 1, 1) ].__evolve_date__
  # @return [Array<Time>] The array as times at midnight UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#50
  def __evolve_date__; end

  # Evolve the array to an array of times.
  #
  # @example Evolve the array to times.
  #   [ 1231231231 ].__evolve_time__
  # @return [Array<Time>] The array as times.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#72
  def __evolve_time__; end

  # Get the object as expanded.
  #
  # @example Get the object expanded.
  #   obj.__expand_complex__
  # @return [Array] The expanded array.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#60
  def __expand_complex__; end

  # Combine the two objects using an intersection strategy.
  #
  # @example Intersect with the object.
  #   [ 1, 2 ].__intersect__(3)
  # @param object [Object] The object to intersect with.
  # @return [Object] The result of the intersection.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#84
  def __intersect__(object); end

  # Gets the array as options in the proper format to pass as MongoDB sort
  # criteria.
  #
  # @example Get the array as sorting options.
  #   [ :field, 1 ].__sort_option__
  # @return [Hash] The array as sort criterion.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#95
  def __sort_option__; end

  # Get the array as a sort pair.
  #
  # @example Get the array as field/direction pair.
  #   [ field, 1 ].__sort_pair__
  # @return [Hash] The field/direction pair.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#108
  def __sort_pair__; end

  private

  # Converts the array to a multi-dimensional array.
  #
  # @api private
  # @example Convert to multi-dimensional.
  #   [ 1, 2, 3 ].multi
  # @return [Array] The multi-dimensional array.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#122
  def multi; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#126
module Mongoid::Criteria::Queryable::Extensions::Array::ClassMethods
  # Evolve the object when the serializer is defined as an array.
  #
  # @example Evolve the object.
  #   Array.evolve(1)
  # @param object [Object] The object to evolve.
  # @return [Object] The evolved object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/array.rb#136
  def evolve(object); end
end

# Adds query type-casting behavior to BigDecimal class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/big_decimal.rb#12
module Mongoid::Criteria::Queryable::Extensions::BigDecimal; end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/big_decimal.rb#13
module Mongoid::Criteria::Queryable::Extensions::BigDecimal::ClassMethods
  # Evolves the big decimal into a MongoDB friendly value.
  #
  # @example Evolve the big decimal
  #   BigDecimal.evolve(decimal)
  # @param object [BigDecimal] The object to convert.
  # @return [Object] The big decimal as a string, a Decimal128,
  #   or the inputted object if it is uncastable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/big_decimal.rb#24
  def evolve(object); end
end

# Adds query type-casting behavior to Mongoid::Boolean class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/boolean.rb#10
module Mongoid::Criteria::Queryable::Extensions::Boolean; end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/boolean.rb#11
module Mongoid::Criteria::Queryable::Extensions::Boolean::ClassMethods
  # Evolve the value into a boolean value stored in MongoDB. Will return
  # true for any of these values: true, t, yes, y, 1, 1.0.
  #
  # @example Evolve the value to a boolean.
  #   Boolean.evolve(true)
  # @param object [Object] The object to evolve.
  # @return [true | false] The boolean value.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/boolean.rb#22
  def evolve(object); end
end

# Adds query type-casting behavior to Date class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/date.rb#10
module Mongoid::Criteria::Queryable::Extensions::Date
  # Evolve the date into a mongo friendly time, UTC midnight.
  #
  # @example Evolve the date.
  #   date.__evolve_date__
  # @return [Time] The date as a UTC time at midnight.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/date.rb#18
  def __evolve_date__; end

  # Evolve the date into a time, which is always in the local timezone.
  #
  # @example Evolve the date.
  #   date.__evolve_time__
  # @return [Time | ActiveSupport::TimeWithZone] The date as a local time.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/date.rb#28
  def __evolve_time__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/date.rb#32
module Mongoid::Criteria::Queryable::Extensions::Date::ClassMethods
  # Evolve the object to an date.
  #
  # @example Evolve date ranges.
  #   Date.evolve(Date.new(1990, 1, 1)..Date.new(1990, 1, 4))
  # @example Evolve dates.
  #   Date.evolve(Date.new(1990, 1, 1))
  # @example Evolve string dates.
  #   Date.evolve("1990-1-1")
  # @param object [Object] The object to evolve.
  # @return [Time] The evolved date.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/date.rb#48
  def evolve(object); end
end

# Adds query type-casting behavior to DateTime class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/date_time.rb#10
module Mongoid::Criteria::Queryable::Extensions::DateTime
  # Evolve the date time into a mongo friendly UTC time.
  #
  # @example Evolve the date time.
  #   date_time.__evolve_time__
  # @return [Time] The converted time in UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/date_time.rb#18
  def __evolve_time__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/date_time.rb#24
module Mongoid::Criteria::Queryable::Extensions::DateTime::ClassMethods
  # Evolve the object to an date.
  #
  # @example Evolve date ranges.
  # @example Evolve dates.
  # @example Evolve string dates.
  # @param object [Object] The object to evolve.
  # @return [Time] The evolved date time.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/date_time.rb#37
  def evolve(object); end
end

# Adds query type-casting behavior to Hash class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#10
module Mongoid::Criteria::Queryable::Extensions::Hash
  # Add an object to a hash using the merge strategies.
  #
  # @example Add an object to a hash.
  #   { field: value }.__add__({ field: other_value })
  # @param object [Hash] The other hash to add.
  # @return [Hash] The hash with object added.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#20
  def __add__(object); end

  # Merge this hash into the provided array.
  #
  # @example Merge the hash into the array.
  #   { field: value }.__add_from_array__([ 1, 2 ])
  # @param array [Array] The array to add to.
  # @return [Hash] The merged hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#32
  def __add_from_array__(array); end

  # Make a deep copy of this hash.
  #
  # @example Make a deep copy of the hash.
  #   { field: value }.__deep_copy__
  # @return [Hash] The copied hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#102
  def __deep_copy__; end

  # Get the object as expanded.
  #
  # @example Get the object expanded.
  #   obj.__expand_complex__
  # @return [Hash] The expanded hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#130
  def __expand_complex__; end

  # Add an object to a hash using the merge strategies.
  #
  # @example Add an object to a hash.
  #   { field: value }.__intersect__({ field: other_value })
  # @param object [Hash] The other hash to intersect.
  # @return [Hash] The hash with object intersected.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#44
  def __intersect__(object); end

  # Merge this hash into the provided array.
  #
  # @example Merge the hash into the array.
  #   { field: value }.__intersect_from_array__([ 1, 2 ])
  # @param array [Array] The array to intersect to.
  # @return [Hash] The merged hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#56
  def __intersect_from_array__(array); end

  # Merge this hash into the provided object.
  #
  # @example Merge the hash into the object.
  #   { field: value }.__intersect_from_object__([ 1, 2 ])
  # @param object [Object] The object to intersect to.
  # @return [Hash] The merged hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#68
  def __intersect_from_object__(object); end

  # Get the hash as a sort option.
  #
  # @example Get the hash as a sort option.
  #   { field: 1 }.__sort_option__
  # @return [Hash] The hash as sort option.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#116
  def __sort_option__; end

  # Add an object to a hash using the merge strategies.
  #
  # @example Add an object to a hash.
  #   { field: value }.__union__({ field: other_value })
  # @param object [Hash] The other hash to union.
  # @return [Hash] The hash with object unioned.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#80
  def __union__(object); end

  # Merge this hash into the provided object.
  #
  # @example Merge the hash into the object.
  #   { field: value }.__union_from_object__([ 1, 2 ])
  # @param object [Object] The object to union to.
  # @return [Hash] The merged hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#92
  def __union_from_object__(object); end

  private

  # Apply the provided strategy for the hash with the given object.
  #
  # @api private
  # @example Apply the strategy.
  #   { field: value }.apply_strategy(:__add__, 1)
  # @param object [Object] The object to merge.
  # @param strategy [Symbol] The strategy to apply.
  # @return [Hash] The merged hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/hash.rb#151
  def apply_strategy(strategy, object); end
end

# Adds query type-casting behavior to NilClass.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#10
module Mongoid::Criteria::Queryable::Extensions::NilClass
  # Add this object to nil.
  #
  # @example Add the object to a nil value.
  #   nil.__add__([ 1, 2, 3 ])
  # @param object [Object] The object to add.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#20
  def __add__(object); end

  # Evolve the nil into a date or time.
  #
  # @example Evolve the nil.
  #   nil.__evolve_time__
  # @return [nil] nil.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#39
  def __evolve_date__; end

  # Evolve the nil into a date or time.
  #
  # @example Evolve the nil.
  #   nil.__evolve_time__
  # @return [nil] nil.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#38
  def __evolve_time__; end

  # Add this object to nil.
  #
  # @example Add the object to a nil value.
  #   nil.__expanded__([ 1, 2, 3 ])
  # @param object [Object] The object to expanded.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#30
  def __expanded__(object); end

  # Add this object to nil.
  #
  # @example Add the object to a nil value.
  #   nil.__intersect__([ 1, 2, 3 ])
  # @param object [Object] The object to intersect.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#49
  def __intersect__(object); end

  # Add this object to nil.
  #
  # @example Add the object to a nil value.
  #   nil.__override__([ 1, 2, 3 ])
  # @param object [Object] The object to override.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#59
  def __override__(object); end

  # Add this object to nil.
  #
  # @example Add the object to a nil value.
  #   nil.__union__([ 1, 2, 3 ])
  # @param object [Object] The object to union.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/nil_class.rb#69
  def __union__(object); end
end

# Adds query type-casting behavior to Numeric module and its children.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#10
module Mongoid::Criteria::Queryable::Extensions::Numeric
  # Evolve the numeric value into a mongo friendly date, aka UTC time at
  # midnight.
  #
  # @example Evolve to a date.
  #   125214512412.1123.__evolve_date__
  # @return [Time] The time representation at UTC midnight.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#19
  def __evolve_date__; end

  # Evolve the numeric value into a mongo friendly time.
  #
  # @example Evolve to a time.
  #   125214512412.1123.__evolve_time__
  # @return [Time] The time representation.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#30
  def __evolve_time__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#34
module Mongoid::Criteria::Queryable::Extensions::Numeric::ClassMethods
  # Get the object as a numeric.
  #
  # @api private
  # @example Get the object as numeric.
  #   Object.__numeric__("1.442")
  # @param object [Object] The object to convert.
  # @raise [ArgumentError]
  # @return [Object] The converted number.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#46
  def __numeric__(object); end

  # Evolve the object to an integer.
  #
  # @example Evolve to integers.
  #   Integer.evolve("1")
  # @param object [Object] The object to evolve.
  # @return [Integer] The evolved object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/numeric.rb#72
  def evolve(object); end
end

# Adds query type-casting behavior to Object class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#10
module Mongoid::Criteria::Queryable::Extensions::Object
  # Combine the two objects using the add strategy.
  #
  # @example Add the object to the array.
  #   [ 1, 2, 3 ].__add__(4)
  # @param object [Object] The object to add.
  # @return [Object] The result of the add.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#20
  def __add__(object); end

  # Merge this object into the provided array.
  #
  # @example Merge the object into the array.
  #   4.__add_from_array__([ 1, 2 ])
  # @param array [Array] The array to add to.
  # @return [Array] The merged object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#32
  def __add_from_array__(array); end

  # Get the object as an array.
  #
  # @example Get the object as an array.
  #   4.__array__
  # @return [Array] The wrapped object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#111
  def __array__; end

  # Deep copy the object. This is for API compatibility, but needs to be
  # overridden.
  #
  # @example Deep copy the object.
  #   1.__deep_copy__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#103
  def __deep_copy__; end

  # Get the object as expanded.
  #
  # @example Get the object expanded.
  #   obj.__expand_complex__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#121
  def __expand_complex__; end

  # Combine the two objects using the intersect strategy.
  #
  # @example Add the object to the array.
  #   [ 1, 2, 3 ].__intersect__(4)
  # @param object [Object] The object to intersect.
  # @return [Array] The result of the intersect.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#44
  def __intersect__(object); end

  # Merge this object into the provided array.
  #
  # @example Merge the object into the array.
  #   4.__intersect_from_array__([ 1, 2 ])
  # @param array [Array] The array to intersect to.
  # @return [Array] The merged object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#56
  def __intersect_from_array__(array); end

  # Merge this object into the provided array.
  #
  # @example Merge the object into the array.
  #   4.__intersect_from_object__([ 1, 2 ])
  # @param object [Object] The value to intersect to.
  # @return [Array] The merged object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#68
  def __intersect_from_object__(object); end

  # Combine the two objects using the union strategy.
  #
  # @example Add the object to the array.
  #   [ 1, 2, 3 ].__union__(4)
  # @param object [Object] The object to union.
  # @return [Array] The result of the union.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#80
  def __union__(object); end

  # Merge this object into the provided array.
  #
  # @example Merge the object into the array.
  #   4.__union_from_object__([ 1, 2 ])
  # @param object [Object] The value to union to.
  # @return [Array] The merged object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#92
  def __union_from_object__(object); end

  # Is the object a regex.
  #
  # @deprecated
  # @example Is the object a regex?
  #   obj.regexp?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#132
  def regexp?(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#137
module Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
  # Evolve the object.
  #
  # @example Evolve an object.
  #   Object.evolve("test")
  # @note This is here for API compatibility.
  # @return [Object] The provided object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#147
  def evolve(object); end

  private

  # Evolve the object.
  #
  # @api private
  # @example Evolve an object and yield.
  #   Object.evolve("test") do |obj|
  #   obj.to_s
  #   end
  # @return [Object] The evolved object.
  # @todo Durran refactor out case statement.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/object.rb#165
  def __evolve__(object); end
end

# Adds query type-casting behavior to Range class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#10
module Mongoid::Criteria::Queryable::Extensions::Range
  # Get the range as an array.
  #
  # @example Get the range as an array.
  #   1...3.__array__
  # @return [Array] The range as an array.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#18
  def __array__; end

  # Convert the range to a $gte/$lte mongo friendly query for dates.
  #
  # @example Evolve the range.
  #   (11231312..213123131).__evolve_date__
  # @return [Hash] The $gte/$lte range query with times at UTC midnight.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#28
  def __evolve_date__; end

  # Convert the range to a $gte/$lte mongo friendly query.
  #
  # @api private
  # @example Evolve the range.
  #   (11231312..213123131).__evolve_range__
  # @param serializer [Object] The optional serializer for the field.
  # @return [Hash] The $gte/$lte range query.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#52
  def __evolve_range__(serializer: T.unsafe(nil)); end

  # Convert the range to a $gte/$lte mongo friendly query for times.
  #
  # @example Evolve the range.
  #   (11231312..213123131).__evolve_date__
  # @return [Hash] The $gte/$lte range query with times in UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#38
  def __evolve_time__; end

  private

  # @api private
  # @note This method's return value will be mutated by the __evolve_*__
  #   methods, therefore it must always return new objects.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#72
  def __evolve_range_naive__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#79
module Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
  # Evolve the range. This will transform it into a $gte/$lte selection.
  # Endless and beginning-less ranges will use only $gte or $lte respectively.
  # End-excluded ranges (...) will use $lt selector instead of $lte.
  #
  # @example Evolve the range.
  #   Range.evolve(1..3)
  # @param object [Range] The range to evolve.
  # @return [Hash] The range as a gte/lte criteria.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/range.rb#91
  def evolve(object); end
end

# Adds query type-casting behavior to Regexp class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#10
module Mongoid::Criteria::Queryable::Extensions::Regexp
  # Is the object a regexp?
  #
  # @deprecated
  # @example Is the object a regex?
  #   /\A[123]/.regexp?
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#19
  def regexp?(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#22
module Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
  # Evolve the object into a regex.
  #
  # @example Evolve the object to a regex.
  #   Regexp.evolve("\A[123]")
  # @param object [Regexp | String] The object to evolve.
  # @return [Regexp] The evolved regex.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#32
  def evolve(object); end
end

# Adds query type-casting behavior to BSON::Regexp::Raw class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#40
module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_
  # Is the object a regexp?
  #
  # @deprecated
  # @example Is the object a regex?
  #   bson_raw_regexp.regexp?
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#49
  def regexp?(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#52
module Mongoid::Criteria::Queryable::Extensions::Regexp::Raw_::ClassMethods
  # Evolve the object into a raw bson regex.
  #
  # @example Evolve the object to a regex.
  #   BSON::Regexp::Raw.evolve("\\A[123]")
  # @param object [BSON::Regexp::Raw | String] The object to evolve.
  # @return [BSON::Regexp::Raw] The evolved raw regex.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/regexp.rb#62
  def evolve(object); end
end

# Adds query type-casting behavior to Set class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/set.rb#12
module Mongoid::Criteria::Queryable::Extensions::Set; end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/set.rb#13
module Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
  # Evolve the set, casting all its elements.
  #
  # @example Evolve the set.
  #   Set.evolve(set)
  # @param object [Set | Object] The object to evolve.
  # @return [Array] The evolved set.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/set.rb#23
  def evolve(object); end
end

# Adds query type-casting behavior to String class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#10
module Mongoid::Criteria::Queryable::Extensions::String
  # Evolve the string into a mongodb friendly date.
  #
  # @example Evolve the string.
  #   "2012-1-1".__evolve_date__
  # @return [Time] The time at UTC midnight.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#18
  def __evolve_date__; end

  # Evolve the string into a mongodb friendly time.
  #
  # @example Evolve the string.
  #   "2012-1-1".__evolve_time__
  # @return [Time] The string as a time.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#29
  def __evolve_time__; end

  # Get the string as a specification.
  #
  # @example Get the string as a criteria.
  #   "field".__expr_part__(value)
  # @param negating [true | false] If the selection should be negated.
  # @param value [Object] The value of the criteria.
  # @return [Hash] The selection.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#67
  def __expr_part__(value, negating = T.unsafe(nil)); end

  # Get the string as a mongo expression, adding $ to the front.
  #
  # @example Get the string as an expression.
  #   "test".__mongo_expression__
  # @return [String] The string with $ at the front.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#39
  def __mongo_expression__; end

  # Get the string as a sort option.
  #
  # @example Get the string as a sort option.
  #   "field ASC".__sort_option__
  # @return [Hash] The string as a sort option hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#49
  def __sort_option__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#71
module Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
  # Get the value as a expression.
  #
  # @example Get the value as an expression.
  #   String.__expr_part__("field", value)
  # @param key [String | Symbol] The field key.
  # @param negating [true | false] If the selection should be negated.
  # @param value [Object] The value of the criteria.
  # @return [Hash] The selection.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#83
  def __expr_part__(key, value, negating = T.unsafe(nil)); end

  # Evolves the string into a MongoDB friendly value - in this case
  # a string.
  #
  # @example Evolve the string
  #   String.evolve(1)
  # @param object [Object] The object to convert.
  # @return [String] The value as a string.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#100
  def evolve(object); end

  private

  # Returns whether the object is Regexp-like.
  #
  # @param object [Object] The object to evaluate.
  # @return [Boolean] Whether the object is Regexp-like.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/string.rb#113
  def __regexp?(object); end
end

# Adds query type-casting behavior to Symbol class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/symbol.rb#10
module Mongoid::Criteria::Queryable::Extensions::Symbol
  # Get the symbol as a specification.
  #
  # @example Get the symbol as a criteria.
  #   :field.__expr_part__(value)
  # @param negating [true | false] If the selection should be negated.
  # @param value [Object] The value of the criteria.
  # @return [Hash] The selection.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/symbol.rb#21
  def __expr_part__(value, negating = T.unsafe(nil)); end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/symbol.rb#25
module Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
  # Adds a method on symbol as a convenience for the MongoDB operator.
  #
  # @example Add the $in method.
  #   Symbol.add_key(:in, "$in")
  # @param additional [String] The additional MongoDB operator.
  # @param name [Symbol] The name of the method.
  # @param operator [String] The MongoDB operator.
  # @param strategy [Symbol] The name of the merge strategy.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/symbol.rb#36
  def add_key(name, strategy, operator, additional = T.unsafe(nil), &block); end

  # Evolves the symbol into a MongoDB friendly value - in this case
  # a symbol.
  #
  # @example Evolve the symbol
  #   Symbol.evolve("test")
  # @param object [Object] The object to convert.
  # @return [Symbol] The value as a symbol.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/symbol.rb#52
  def evolve(object); end
end

# Adds query type-casting behavior to Time class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/time.rb#10
module Mongoid::Criteria::Queryable::Extensions::Time
  # Evolve the time as a date, UTC midnight.
  #
  # @example Evolve the time to a date query format.
  #   time.__evolve_date__
  # @return [Time] The date at midnight UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time.rb#18
  def __evolve_date__; end

  # Evolve the time into a utc time.
  #
  # @example Evolve the time.
  #   time.__evolve_time__
  # @return [Time] The time in UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time.rb#28
  def __evolve_time__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/time.rb#32
module Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
  # Evolve the object to an date.
  #
  # @example Evolve date ranges.
  # @example Evolve dates.
  # @example Evolve string dates.
  # @param object [Object] The object to evolve.
  # @return [Time] The evolved date time.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time.rb#45
  def evolve(object); end
end

# Adds query type-casting behavior to
# ActiveSupport::TimeWithZone class.
#
# source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#11
module Mongoid::Criteria::Queryable::Extensions::TimeWithZone
  # Evolve the time as a date, UTC midnight.
  #
  # @example Evolve the time to a date query format.
  #   time.__evolve_date__
  # @return [Time] The date at midnight UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#19
  def __evolve_date__; end

  # Evolve the time into a utc time.
  #
  # @example Evolve the time.
  #   time.__evolve_time__
  # @return [Time] The time in UTC.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#29
  def __evolve_time__; end
end

# source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#33
module Mongoid::Criteria::Queryable::Extensions::TimeWithZone::ClassMethods
  # Evolve the object to an date.
  #
  # @example Evolve date ranges.
  # @example Evolve dates.
  # @example Evolve string dates.
  # @param object [Object] The object to evolve.
  # @return [Time] The evolved date time.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/extensions/time_with_zone.rb#46
  def evolve(object); end
end

# Key objects represent specifications for building query expressions
# utilizing MongoDB selectors.
#
# Simple key-value conditions are translated directly into expression
# hashes by Mongoid without utilizing Key objects. For example, the
# following condition:
#
#   Foo.where(price: 1)
#
# ... is translated to the following simple expression:
#
#   {price: 1}
#
# More complex conditions would start involving Key objects. For example:
#
#   Foo.where(:price.gt => 1)
#
# ... causes a Key instance to be created as follows:
#
#   Key.new(:price, :__override__, '$gt')
#
# This Key instance utilizes +operator+ but not +expanded+ nor +block+.
# The corresponding MongoDB query expression is:
#
#    {price: {'$gt' => 1}}
#
# A yet more more complex example is the following condition:
#
#   Foo.geo_spatial(:boundary.intersects_point => [1, 10])
#
# Processing this condition will cause a Key instance to be created as
# follows:
#
#   Key.new(:location, :__override__, '$geoIntersects', '$geometry') do |value|
#     { "type" => POINT, "coordinates" => value }
#   end
#
# ... eventually producing the following MongoDB query expression:
#
# {
#   boundary: {
#     '$geoIntersects' => {
#       '$geometry' => {
#         type: "Point" ,
#         coordinates: [ 1, 10 ]
#       }
#     }
#   }
# }
#
# Key instances can be thought of as procs that map a value to the
# MongoDB query expression required to obtain the key's condition,
# given the value.
#
# source://mongoid//lib/mongoid/criteria/queryable/key.rb#61
class Mongoid::Criteria::Queryable::Key
  # Instantiate the new key.
  #
  # @example Instantiate a key for sorting.
  #   Key.new(:field, :__override__, 1)
  # @example Instantiate a key.
  #   Key.new("age", :__override__, "$gt")
  # @param expanded [String] The Mongo expanded operator.
  # @param name [String | Symbol] The field name.
  # @param operator [String | Integer] The MongoDB operator,
  #   or sort direction (1 or -1).
  # @param strategy [Symbol] The name of the merge strategy.
  # @return [Key] a new instance of Key
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#113
  def initialize(name, strategy, operator, expanded = T.unsafe(nil), &block); end

  # Does the key equal another object?
  #
  # @example Is the key equal to another?
  #   key == other
  #   key.eql? other
  # @param other [Object] The object to compare to.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#87
  def ==(other); end

  # Gets the raw selector that would be passed to Mongo from this key.
  #
  # @example Specify the raw selector.
  #   key.__expr_part__(50)
  # @param negating [true | false] If the selection should be negated.
  # @param object [Object] The value to be included.
  # @return [Hash] The raw MongoDB selector.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#131
  def __expr_part__(object, negating = T.unsafe(nil)); end

  # Get the key as raw Mongo sorting options.
  #
  # @example Get the key as a sort.
  #   key.__sort_option__
  # @return [Hash] The field/direction pair.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#170
  def __sort_option__; end

  # Get the key as raw Mongo sorting options.
  #
  # @example Get the key as a sort.
  #   key.__sort_option__
  # @return [Hash] The field/direction pair.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#173
  def __sort_pair__; end

  # @return [Proc] The optional block to transform values.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#76
  def block; end

  # Does the key equal another object?
  #
  # @example Is the key equal to another?
  #   key == other
  #   key.eql? other
  # @param other [Object] The object to compare to.
  # @return [true | false] If the objects are equal.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#91
  def eql?(other); end

  # @return [String] The MongoDB expanded query operator.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#70
  def expanded; end

  # Calculate the hash code for a key.
  #
  # @return [Integer] The hash code for the key.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#96
  def hash; end

  # @return [String | Symbol] The name of the field.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#64
  def name; end

  # @return [String] The MongoDB query operator.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#67
  def operator; end

  # @return [Symbol] The name of the merge strategy.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#73
  def strategy; end

  # Convert the key to a string.
  #
  # @example Convert the key to a string.
  #   key.to_s
  # @return [String] The key as a string.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#181
  def to_s; end

  # Gets the raw selector condition that would be passed to Mongo.
  #
  # @example Gets the raw selector condition.
  #   key.transform_value(50)
  # @param negating [true | false] If the selection should be negated.
  # @param value [Object] The value to be included.
  # @return [Hash] The raw MongoDB selector.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/key.rb#144
  def transform_value(value, negating = T.unsafe(nil)); end
end

# Adds macro behavior for adding symbol methods.
#
# source://mongoid//lib/mongoid/criteria/queryable/macroable.rb#9
module Mongoid::Criteria::Queryable::Macroable
  # Adds a method on Symbol for convenience in where queries for the
  # provided operators.
  #
  # @example Add a symbol key.
  #   key :all, "$all
  # @param additional [String] The additional MongoDB operator.
  # @param name [Symbol] The name of the method.
  # @param operator [String] The MongoDB operator.
  # @param strategy [Symbol] The merge strategy.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/macroable.rb#21
  def key(name, strategy, operator, additional = T.unsafe(nil), &block); end
end

# Contains behavior for merging existing selection with new selection.
#
# source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#9
module Mongoid::Criteria::Queryable::Mergeable
  # Merge criteria with operators using the and operator.
  #
  # @param criterion [Hash] The criterion to add to the criteria.
  # @param operator [String] The MongoDB operator.
  # @return [Criteria] The resulting criteria.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#62
  def and_with_operator(criterion, operator); end

  # Instruct the next mergeable call to use intersection.
  #
  # @example Use intersection on the next call.
  #   mergeable.intersect.in(field: [ 1, 2, 3 ])
  # @return [Mergeable] The intersect flagged mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#20
  def intersect; end

  # Instruct the next mergeable call to use override.
  #
  # @example Use override on the next call.
  #   mergeable.override.in(field: [ 1, 2, 3 ])
  # @return [Mergeable] The override flagged mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#30
  def override; end

  # Clear the current strategy and negating flag, used after cloning.
  #
  # @example Reset the strategies.
  #   mergeable.reset_strategies!
  # @return [Criteria] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#50
  def reset_strategies!; end

  # Returns the value of attribute strategy.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#12
  def strategy; end

  # Sets the attribute strategy
  #
  # @param value the value to set the attribute strategy to.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#12
  def strategy=(_arg0); end

  # Instruct the next mergeable call to use union.
  #
  # @example Use union on the next call.
  #   mergeable.union.in(field: [ 1, 2, 3 ])
  # @return [Mergeable] The union flagged mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#40
  def union; end

  private

  # Adds the criterion to the existing selection.
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__add__({ name: 1 }, "$in")
  # @param criterion [Hash] The criteria.
  # @param operator [String] The MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#90
  def __add__(criterion, operator); end

  # Adds the criterion to the existing selection.
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__expanded__([ 1, 10 ], "$within", "$center")
  # @param criterion [Hash] The criteria.
  # @param inner [String] The inner MongoDB operator.
  # @param outer [String] The outer MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#106
  def __expanded__(criterion, outer, inner); end

  # Adds the criterion to the existing selection.
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__intersect__([ 1, 2 ], "$in")
  # @param criterion [Hash] The criteria.
  # @param operator [String] The MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#140
  def __intersect__(criterion, operator); end

  # Perform a straight merge of the criterion into the selection and let the
  # symbol overrides do all the work.
  #
  # @api private
  # @example Straight merge the expanded criterion.
  #   mergeable.__merge__(location: [ 1, 10 ])
  # @param criterion [Hash] The criteria.
  # @return [Mergeable] The cloned object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#123
  def __merge__(criterion); end

  # Adds $and/$or/$nor criteria to a copy of this selection.
  #
  # Each of the criteria can be a Hash of key/value pairs or MongoDB
  # operators (keys beginning with $), or a Selectable object
  # (which typically will be a Criteria instance).
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__multi__([ 1, 2 ], "$in")
  # @param criteria [Array<Hash | Criteria>] Multiple key/value pair
  #   matches or Criteria objects.
  # @param operator [String] The MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#160
  def __multi__(criteria, operator); end

  # Adds the criterion to the existing selection.
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__override__([ 1, 2 ], "$in")
  # @param criterion [Hash | Criteria] The criteria.
  # @param operator [String] The MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#343
  def __override__(criterion, operator); end

  # Adds the criterion to the existing selection.
  #
  # @api private
  # @example Add the criterion.
  #   mergeable.__union__([ 1, 2 ], "$in")
  # @param criterion [Hash] The criteria.
  # @param operator [String] The MongoDB operator.
  # @return [Mergeable] The new mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#369
  def __union__(criterion, operator); end

  # Combines criteria into a MongoDB selector.
  #
  # Criteria is an array of criterion objects which will be flattened.
  #
  # Each criterion can be:
  # - A hash
  # - A Criteria instance
  # - nil, in which case it is ignored
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#185
  def _mongoid_add_top_level_operation(operator, criteria); end

  # Takes a criteria hash and expands Key objects into hashes containing
  # MQL corresponding to said key objects. Also converts the input to
  # BSON::Document to permit indifferent access.
  #
  # The argument must be a hash containing key-value pairs of the
  # following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {:$operator => operator_value_expression}
  # - {'$operator' => operator_value_expression}
  #
  # Ruby does not permit multiple symbol operators. For example,
  # {:foo.gt => 1, :foo.gt => 2} is collapsed to {:foo.gt => 2} by the
  # language. Therefore this method never has to deal with multiple
  # identical operators.
  #
  # Similarly, this method should never need to expand a literal value
  # and an operator at the same time.
  #
  # This method effectively converts symbol keys to string keys in
  # the input +expr+, such that the downstream code can assume that
  # conditions always contain string keys.
  #
  # @param expr [Hash] Criteria including Key instances.
  # @return [BSON::Document] The expanded criteria.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#259
  def _mongoid_expand_keys(expr); end

  # Calling .flatten on an array which includes a Criteria instance
  # evaluates the criteria, which we do not want. Hence this method
  # explicitly only expands Array objects and Array subclasses.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#216
  def _mongoid_flatten_arrays(array); end

  # Prepare the value for merging.
  #
  # @api private
  # @example Prepare the value.
  #   mergeable.prepare("field", "$gt", 10)
  # @param field [String] The name of the field.
  # @param value [Object] The value.
  # @return [Object] The serialized value.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#421
  def prepare(field, operator, value); end

  # Use the named strategy for the next operation.
  #
  # @api private
  # @example Use intersection.
  #   mergeable.use(:__intersect__)
  # @param strategy [Symbol] The strategy to use.
  # @return [Mergeable] The existing mergeable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#383
  def use(strategy); end

  # Add criterion to the selection with the named strategy.
  #
  # @api private
  # @example Add criterion with a strategy.
  #   mergeable.with_strategy(:__union__, {field_name: [ 1, 2, 3 ]}, "$in")
  # @param criterion [Object] The criterion to add.
  # @param operator [String] The MongoDB operator.
  # @param strategy [Symbol] The name of the strategy method.
  # @return [Mergeable] The cloned query.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/mergeable.rb#401
  def with_strategy(strategy, criterion, operator); end
end

# The optional module includes all behavior that has to do with extra
# options surrounding queries, like skip, limit, sorting, etc.
#
# source://mongoid//lib/mongoid/criteria/queryable/optional.rb#10
module Mongoid::Criteria::Queryable::Optional
  extend ::Mongoid::Criteria::Queryable::Macroable

  # Add ascending sorting options for all the provided fields.
  #
  # @example Add ascending sorting.
  #   optional.ascending(:first_name, :last_name)
  # @param *fields [Symbol...] The field(s) to sort.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#27
  def asc(*fields); end

  # Add ascending sorting options for all the provided fields.
  #
  # @example Add ascending sorting.
  #   optional.ascending(:first_name, :last_name)
  # @param *fields [Symbol...] The field(s) to sort.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#24
  def ascending(*fields); end

  # Adds the option for telling MongoDB how many documents to retrieve in
  # it's batching.
  #
  # @example Apply the batch size options.
  #   optional.batch_size(500)
  # @param value [Integer] The batch size.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#40
  def batch_size(value = T.unsafe(nil)); end

  # Set the collation.
  #
  # @example Set the collation.
  #   optional.collation(locale: 'fr', strength: 2)
  # @param collation_doc [Hash] The document describing the collation to use.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#303
  def collation(collation_doc); end

  # Associate a comment with the query.
  #
  # @example Add a comment.
  #   optional.comment('slow query')
  # @note Set profilingLevel to 2 and the comment will be logged in the profile
  #   collection along with the query.
  # @param comment [String] The comment to be associated with the query.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#274
  def comment(comment = T.unsafe(nil)); end

  # Set the cursor type.
  #
  # @example Set the cursor type.
  #   optional.cursor_type(:tailable)
  #   optional.cursor_type(:tailable_await)
  # @note The cursor can be type :tailable or :tailable_await.
  # @param type [Symbol] The type of cursor to create.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#291
  def cursor_type(type); end

  # Add descending sorting options for all the provided fields.
  #
  # @example Add descending sorting.
  #   optional.descending(:first_name, :last_name)
  # @param *fields [Symbol...] The field(s) to sort.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#55
  def desc(*fields); end

  # Add descending sorting options for all the provided fields.
  #
  # @example Add descending sorting.
  #   optional.descending(:first_name, :last_name)
  # @param *fields [Symbol...] The field(s) to sort.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#52
  def descending(*fields); end

  # Add an index hint to the query options.
  #
  # @example Add an index hint.
  #   optional.hint("$natural" => 1)
  # @param value [Hash] The index hint.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#67
  def hint(value = T.unsafe(nil)); end

  # Add the number of documents to limit in the returned results.
  #
  # @example Limit the number of returned documents.
  #   optional.limit(20)
  # @param value [Integer] The number of documents to return.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#79
  def limit(value = T.unsafe(nil)); end

  # Adds the option to limit the number of documents scanned in the
  # collection.
  #
  # @example Add the max scan limit.
  #   optional.max_scan(1000)
  # @param value [Integer] The max number of documents to scan.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#96
  def max_scan(value = T.unsafe(nil)); end

  # Adds a cumulative time limit in milliseconds for processing operations on a cursor.
  #
  # @example Add the max time ms option.
  #   optional.max_time_ms(200)
  # @param value [Integer] The max time in milliseconds for processing operations on a cursor.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#108
  def max_time_ms(value = T.unsafe(nil)); end

  # Tell the query not to timeout.
  #
  # @example Tell the query not to timeout.
  #   optional.no_timeout
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#118
  def no_timeout; end

  # Add the number of documents to skip.
  #
  # @example Add the number to skip.
  #   optional.skip(100)
  # @param value [Integer] The number to skip.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#212
  def offset(value = T.unsafe(nil)); end

  # Limits the results to only contain the fields provided.
  #
  # @example Limit the results to the provided fields.
  #   optional.only(:name, :dob)
  # @param *args [Symbol...] The field(s) to return.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#130
  def only(*args); end

  # Returns the value of attribute options.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#14
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#14
  def options=(_arg0); end

  # Adds sorting criterion to the options.
  #
  # @example Add sorting options via a hash with integer directions.
  #   optional.order_by(name: 1, dob: -1)
  # @example Add sorting options via a hash with string directions.
  #   optional.order_by(name: "asc", dob: "desc")
  # @example Add sorting options via a hash with symbol directions.
  #   optional.order_by(name: :asc, dob: :desc)
  # @example Add sorting options via a string.
  #   optional.order_by("name ASC, dob DESC")
  # @example Add sorting options via an array with integer directions.
  #   optional.order_by([[ name, 1 ], [ dob, -1 ]])
  # @example Add sorting options via an array with string directions.
  #   optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
  # @example Add sorting options via an array with symbol directions.
  #   optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
  # @example Add sorting options with keys.
  #   optional.order_by(:name.asc, :dob.desc)
  # @param *spec [[ Array | Hash | String ]...] The sorting specification.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#180
  def order(*spec); end

  # Adds sorting criterion to the options.
  #
  # @example Add sorting options via a hash with integer directions.
  #   optional.order_by(name: 1, dob: -1)
  # @example Add sorting options via a hash with string directions.
  #   optional.order_by(name: "asc", dob: "desc")
  # @example Add sorting options via a hash with symbol directions.
  #   optional.order_by(name: :asc, dob: :desc)
  # @example Add sorting options via a string.
  #   optional.order_by("name ASC, dob DESC")
  # @example Add sorting options via an array with integer directions.
  #   optional.order_by([[ name, 1 ], [ dob, -1 ]])
  # @example Add sorting options via an array with string directions.
  #   optional.order_by([[ "name", "asc" ], [ "dob", "desc" ]])
  # @example Add sorting options via an array with symbol directions.
  #   optional.order_by([[ :name, :asc ], [ :dob, :desc ]])
  # @example Add sorting options with keys.
  #   optional.order_by(:name.asc, :dob.desc)
  # @param *spec [[ Array | Hash | String ]...] The sorting specification.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#170
  def order_by(*spec); end

  # Instead of merging the order criteria, use this method to completely
  # replace the existing ordering with the provided.
  #
  # @example Replace the ordering.
  #   optional.reorder(name: :asc)
  # @param *spec [[ Array | Hash | String ]...] The sorting specification.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#191
  def reorder(*spec); end

  # Add the number of documents to skip.
  #
  # @example Add the number to skip.
  #   optional.skip(100)
  # @param value [Integer] The number to skip.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#205
  def skip(value = T.unsafe(nil)); end

  # Limit the returned results via slicing embedded arrays.
  #
  # @example Slice the returned results.
  #   optional.slice(aliases: [ 0, 5 ])
  # @param criterion [Hash] The slice options.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#222
  def slice(criterion = T.unsafe(nil)); end

  # Tell the query to operate in snapshot mode.
  #
  # @example Add the snapshot option.
  #   optional.snapshot
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#238
  def snapshot; end

  # Limits the results to only contain the fields not provided.
  #
  # @example Limit the results to the fields not provided.
  #   optional.without(:name, :dob)
  # @param *args [Symbol...] The field(s) to ignore.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#252
  def without(*args); end

  private

  # Add a single sort option.
  #
  # @api private
  # @example Add a single sort option.
  #   optional.add_sort_option({}, :name, 1)
  # @param direction [Integer] The sort direction.
  # @param field [String] The field name.
  # @param options [Hash] The options.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#321
  def add_sort_option(options, field, direction); end

  # Take the provided criterion and store it as an option in the query
  # options.
  #
  # @api private
  # @example Store the option.
  #   optional.option({ skip: 10 })
  # @param *args [Object...] The options.
  # @return [Queryable] The cloned queryable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#338
  def option(*args); end

  # Add multiple sort options at once.
  #
  # @api private
  # @example Add multiple sort options.
  #   optional.sort_with_list(:name, :dob, 1)
  # @param *fields [[ Symbol | String ]...] The field name(s).
  # @param direction [Integer] The sort direction.
  # @return [Optional] The cloned optional.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#357
  def sort_with_list(*fields, direction); end

  class << self
    # Get the methods on the optional that can be forwarded to from a model.
    #
    # @example Get the forwardable methods.
    #   Optional.forwardables
    # @return [Array<Symbol>] The names of the forwardable methods.
    #
    # source://mongoid//lib/mongoid/criteria/queryable/optional.rb#374
    def forwardables; end
  end
end

# The options is a hash representation of options passed to MongoDB queries,
# such as skip, limit, and sorting criteria.
#
# source://mongoid//lib/mongoid/criteria/queryable/options.rb#10
class Mongoid::Criteria::Queryable::Options < ::Mongoid::Criteria::Queryable::Smash
  # Store the value in the options for the provided key. The options will
  # handle all necessary serialization and localization in this step.
  #
  # @example Store a value in the options.
  #   options.store(:key, "testing")
  # @param key [String | Symbol] The name of the attribute.
  # @param value [Object] The value to add.
  # @return [Object] The stored object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#65
  def []=(key, value, localize = T.unsafe(nil)); end

  # Perform a deep copy of the options.
  #
  # @example Perform a deep copy.
  #   options.__deep_copy__
  # @return [Options] The copied options.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#87
  def __deep_copy__; end

  # Convenience method for getting the field options.
  #
  # @example Get the fields options.
  #   options.fields
  # @return [Hash] The fields options.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#18
  def fields; end

  # Convenience method for getting the limit option.
  #
  # @example Get the limit option.
  #   options.limit
  # @return [Integer] The limit option.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#28
  def limit; end

  # Convenience method for getting the skip option.
  #
  # @example Get the skip option.
  #   options.skip
  # @return [Integer] The skip option.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#38
  def skip; end

  # Convenience method for getting the sort options.
  #
  # @example Get the sort options.
  #   options.sort
  # @return [Hash] The sort options.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#48
  def sort; end

  # Store the value in the options for the provided key. The options will
  # handle all necessary serialization and localization in this step.
  #
  # @example Store a value in the options.
  #   options.store(:key, "testing")
  # @param key [String | Symbol] The name of the attribute.
  # @param value [Object] The value to add.
  # @return [Object] The stored object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#62
  def store(key, value, localize = T.unsafe(nil)); end

  # Convert the options to aggregation pipeline friendly options.
  #
  # @example Convert the options to a pipeline.
  #   options.to_pipeline
  # @return [Array<Hash>] The options in pipeline form.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#73
  def to_pipeline; end

  private

  # Evolve a single key selection with various types of values.
  #
  # @api private
  # @example Evolve a simple selection.
  #   options.evolve(field, 5)
  # @param value [Object] The value to serialize.
  # @return [Object] The serialized object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#107
  def evolve(value, localize = T.unsafe(nil)); end

  # Evolve a single key selection with hash values.
  #
  # @api private
  # @example Evolve a simple selection.
  #   options.evolve(field, { "$gt" => 5 })
  # @param value [Hash] The hash to serialize.
  # @return [Object] The serialized hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/options.rb#126
  def evolve_hash(value, localize = T.unsafe(nil)); end
end

# Represents an aggregation pipeline.
#
# source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#9
class Mongoid::Criteria::Queryable::Pipeline < ::Array
  # Initialize the new pipeline.
  #
  # @example Initialize the new pipeline.
  #   Queryable::Pipeline.new(aliases)
  # @param aliases [Hash] A hash of mappings from aliases to the actual
  #   field names in the database.
  # @return [Pipeline] a new instance of Pipeline
  # @yield [_self]
  # @yieldparam _self [Mongoid::Criteria::Queryable::Pipeline] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#48
  def initialize(aliases = T.unsafe(nil)); end

  # Deep copy the aggregation pipeline. Will clone all the values in the
  # pipeline as well as the pipeline itself.
  #
  # @example Deep copy the pipeline.
  #   pipeline.__deep_copy__
  # @return [Pipeline] The cloned pipeline.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#21
  def __deep_copy__; end

  # Returns the value of attribute aliases.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#12
  def aliases; end

  # Add a group operation to the aggregation pipeline.
  #
  # @example Add a group operation.
  #   pipeline.group(:_id => "foo", :count.sum => 1, :max.max => "likes")
  # @param entry [Hash] The group entry.
  # @return [Pipeline] The pipeline.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#37
  def group(entry); end

  # Adds a $project entry to the aggregation pipeline.
  #
  # @example Add the projection.
  #   pipeline.project(name: 1)
  # @param entry [Hash] The projection.
  # @return [Pipeline] The pipeline.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#61
  def project(entry); end

  # Add the $unwind entry to the pipeline.
  #
  # @example Add the unwind.
  #   pipeline.unwind(:field)
  #   pipeline.unwind(document)
  # @param field_or_doc [String | Symbol | Hash] A field name or a
  #   document.
  # @return [Pipeline] The pipeline.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#75
  def unwind(field_or_doc); end

  private

  # Evolve the entry using the aliases.
  #
  # @api private
  # @example Evolve the entry.
  #   pipeline.evolve(name: 1)
  # @param entry [Hash] The entry to evolve.
  # @return [Hash] The evolved entry.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/pipeline.rb#97
  def evolve(entry); end
end

# An queryable selectable is selectable, in that it has the ability to select
# document from the database. The selectable module brings all functionality
# to the selectable that has to do with building MongoDB selectors.
#
# source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#11
module Mongoid::Criteria::Queryable::Selectable
  extend ::Mongoid::Criteria::Queryable::Macroable

  # Add the $all criterion.
  #
  # @example Add the criterion.
  #   selectable.all(field: [ 1, 2 ])
  # @example Execute an $all in a where query.
  #   selectable.where(:field.all => [ 1, 2 ])
  # @param *criteria [Hash...] The key value pair(s) for $all matching.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#38
  def all(*criteria); end

  # Add the $all criterion.
  #
  # @example Add the criterion.
  #   selectable.all(field: [ 1, 2 ])
  # @example Execute an $all in a where query.
  #   selectable.where(:field.all => [ 1, 2 ])
  # @param *criteria [Hash...] The key value pair(s) for $all matching.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#65
  def all_in(*criteria); end

  # Add the $and criterion.
  #
  # @example Add the criterion.
  #   selectable.and({ field: value }, { other: value })
  # @param *criteria [[ Hash | Criteria | Array<Hash | Criteria> ]...] Multiple key/value pair matches or Criteria objects that all must
  #   match to return results.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#111
  def all_of(*criteria); end

  # Add the $and criterion.
  #
  # @example Add the criterion.
  #   selectable.and({ field: value }, { other: value })
  # @param *criteria [[ Hash | Criteria | Array<Hash | Criteria> ]...] Multiple key/value pair matches or Criteria objects that all must
  #   match to return results.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#78
  def and(*criteria); end

  # Adds the $in selection to the selectable.
  #
  # @example Add $in selection on a range.
  #   selectable.in(age: 18..24)
  # @example Add $in selection on an array.
  #   selectable.in(age: [ 1, 2, 3 ])
  # @example Execute an $in in a where query.
  #   selectable.where(:field.in => [ 1, 2, 3 ])
  # @param condition [Hash] The field/value criterion pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#339
  def any_in(condition); end

  # Adds a disjunction of the arguments as an additional constraint
  # to the criteria already existing in the receiver.
  #
  # Use +or+ to make the receiver one of the disjunction operands.
  #
  # Each argument can be a Hash, a Criteria object, an array of
  # Hash or Criteria objects, or a nested array. Nested arrays will be
  # flattened and can be of any depth. Passing arrays is deprecated.
  #
  # @example Add the $or selection where both fields must have the specified values.
  #   selectable.any_of(field: 1, field: 2)
  # @example Add the $or selection where either value match is sufficient.
  #   selectable.any_of({field: 1}, {field: 2})
  # @example Same as previous example but using the deprecated array wrap.
  #   selectable.any_of([{field: 1}, {field: 2}])
  # @example Same as previous example, also deprecated.
  #   selectable.any_of([{field: 1}], [{field: 2}])
  # @param *criteria [[ Hash | Criteria | Array<Hash | Criteria> ]...] Multiple key/value pair matches or Criteria objects, or arrays
  #   thereof. Passing arrays is deprecated.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#674
  def any_of(*criteria); end

  # Add the range selection.
  #
  # @example Match on results between multiple ranges.
  #   selectable.between(field: 1..2, other: 5..7)
  # @example Match on results within a single range.
  #   selectable.between(field: 1..2)
  # @param criterion [Hash] Multiple key/range pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#124
  def between(criterion); end

  # Select with an $elemMatch.
  #
  # @example Add criterion for a single match.
  #   selectable.elem_match(field: { name: "value" })
  # @example Add criterion for multiple matches.
  #   selectable.elem_match(
  #   field: { name: "value" },
  #   other: { name: "value"}
  #   )
  # @example Execute an $elemMatch in a where query.
  #   selectable.where(:field.elem_match => { name: "value" })
  # @param criterion [Hash] The field/match pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#154
  def elem_match(criterion); end

  # Add the $eq criterion to the selector.
  #
  # @example Add the $eq criterion.
  #   selectable.eq(age: 60)
  # @example Execute an $eq in a where query.
  #   selectable.where(:field.eq => 10)
  # @param criterion [Hash] The field/value pairs to check.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#257
  def eq(criterion); end

  # Adds $ne selection to the selectable.
  #
  # @example Execute an $ne in a where query.
  #   selectable.where(:field.ne => "value")
  # @example Query for a value $ne to something.
  #   selectable.ne(field: 10)
  # @param criterion [Hash] The field/ne selections.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#437
  def excludes(criterion); end

  # Add the $exists selection.
  #
  # @example Add a single selection.
  #   selectable.exists(field: true)
  # @example Add multiple selections.
  #   selectable.exists(field: true, other: false)
  # @example Execute an $exists in a where query.
  #   selectable.where(:field.exists => true)
  # @param criterion [Hash] The field/boolean existence checks.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#177
  def exists(criterion); end

  # Add a $geoIntersects or $geoWithin selection. Symbol operators must
  # be used as shown in the examples to expand the criteria.
  #
  # @example Add a geo intersect criterion for a line.
  #   query.geo_spatial(:location.intersects_line => [[ 1, 10 ], [ 2, 10 ]])
  # @example Add a geo intersect criterion for a point.
  #   query.geo_spatial(:location.intersects_point => [[ 1, 10 ]])
  # @example Add a geo intersect criterion for a polygon.
  #   query.geo_spatial(:location.intersects_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
  # @example Add a geo within criterion for a box.
  #   query.geo_spatial(:location.within_box => [[ 1, 10 ], [ 2, 10 ])
  # @example Add a geo within criterion for a polygon.
  #   query.geo_spatial(:location.within_polygon => [[ 1, 10 ], [ 2, 10 ], [ 1, 10 ]])
  # @note The only valid geometry shapes for a $geoIntersects are:
  #   :intersects_line, :intersects_point, and :intersects_polygon.
  # @note The only valid options for a $geoWithin query are the geometry
  #   shape :within_polygon and the operator :within_box.
  # @note The :within_box operator for the $geoWithin query expects the
  #   lower left (south west) coordinate pair as the first argument and
  #   the upper right (north east) as the second argument.
  #   Important: When latitude and longitude are passed, longitude is
  #   expected as the first element of the coordinate pair.
  #   Source: https://www.mongodb.com/docs/manual/reference/operator/query/box/
  # @param criterion [Hash] The criterion.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#224
  def geo_spatial(criterion); end

  # Add the $gt criterion to the selector.
  #
  # @example Add the $gt criterion.
  #   selectable.gt(age: 60)
  # @example Execute an $gt in a where query.
  #   selectable.where(:field.gt => 10)
  # @param criterion [Hash] The field/value pairs to check.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#277
  def gt(criterion); end

  # Add the $gte criterion to the selector.
  #
  # @example Add the $gte criterion.
  #   selectable.gte(age: 60)
  # @example Execute an $gte in a where query.
  #   selectable.where(:field.gte => 10)
  # @param criterion [Hash] The field/value pairs to check.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#297
  def gte(criterion); end

  # Adds the $in selection to the selectable.
  #
  # @example Add $in selection on a range.
  #   selectable.in(age: 18..24)
  # @example Add $in selection on an array.
  #   selectable.in(age: [ 1, 2, 3 ])
  # @example Execute an $in in a where query.
  #   selectable.where(:field.in => [ 1, 2, 3 ])
  # @param condition [Hash] The field/value criterion pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#320
  def in(condition); end

  # Add the $lt criterion to the selector.
  #
  # @example Add the $lt criterion.
  #   selectable.lt(age: 60)
  # @example Execute an $lt in a where query.
  #   selectable.where(:field.lt => 10)
  # @param criterion [Hash] The field/value pairs to check.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#353
  def lt(criterion); end

  # Add the $lte criterion to the selector.
  #
  # @example Add the $lte criterion.
  #   selectable.lte(age: 60)
  # @example Execute an $lte in a where query.
  #   selectable.where(:field.lte => 10)
  # @param criterion [Hash] The field/value pairs to check.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#373
  def lte(criterion); end

  # Add a $maxDistance selection to the selectable.
  #
  # @example Add the $maxDistance selection.
  #   selectable.max_distance(location: 10)
  # @param criterion [Hash] The field/distance pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#390
  def max_distance(criterion); end

  # Adds $mod selection to the selectable.
  #
  # @example Add the $mod selection.
  #   selectable.mod(field: [ 10, 1 ])
  # @example Execute an $mod in a where query.
  #   selectable.where(:field.mod => [ 10, 1 ])
  # @param criterion [Hash] The field/mod selections.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#410
  def mod(criterion); end

  # Adds $ne selection to the selectable.
  #
  # @example Execute an $ne in a where query.
  #   selectable.where(:field.ne => "value")
  # @example Query for a value $ne to something.
  #   selectable.ne(field: 10)
  # @param criterion [Hash] The field/ne selections.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#430
  def ne(criterion); end

  # Adds a $near criterion to a geo selection.
  #
  # @example Add the $near selection.
  #   selectable.near(location: [ 23.1, 12.1 ])
  # @example Execute an $near in a where query.
  #   selectable.where(:field.near => [ 23.2, 12.1 ])
  # @param criterion [Hash] The field/location pair.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#451
  def near(criterion); end

  # Adds a $nearSphere criterion to a geo selection.
  #
  # @example Add the $nearSphere selection.
  #   selectable.near_sphere(location: [ 23.1, 12.1 ])
  # @example Execute an $nearSphere in a where query.
  #   selectable.where(:field.near_sphere => [ 10.11, 3.22 ])
  # @param criterion [Hash] The field/location pair.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#471
  def near_sphere(criterion); end

  # Returns the value of attribute negating.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#25
  def negating; end

  # Sets the attribute negating
  #
  # @param value the value to set the attribute negating to.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#25
  def negating=(_arg0); end

  # Is the current selectable negating the next selection?
  #
  # @example Is the selectable negating?
  #   selectable.negating?
  # @return [true | false] If the selectable is negating.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#535
  def negating?; end

  # Adds the $nin selection to the selectable.
  #
  # @example Add $nin selection on a range.
  #   selectable.nin(age: 18..24)
  # @example Add $nin selection on an array.
  #   selectable.nin(age: [ 1, 2, 3 ])
  # @example Execute an $nin in a where query.
  #   selectable.where(:field.nin => [ 1, 2, 3 ])
  # @param condition [Hash] The field/value criterion pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#494
  def nin(condition); end

  # Negate the arguments, constraining the query to only those documents
  # that do NOT match the arguments.
  #
  # @example Exclude a single criterion.
  #   selectable.none_of(name: /Bob/)
  # @example Exclude multiple criteria as an array.
  #   selectable.none_of([{ name: /Bob/ }, { country: "USA" }])
  # @example Exclude multiple criteria.
  #   selectable.none_of(name: /Bob/, country: "USA")
  # @param *criteria [[ Hash | Criteria ]...] The key/value pair
  #   matches or Criteria objects to negate.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#601
  def none_of(*criteria); end

  # Adds $nor selection to the selectable.
  #
  # @example Add the $nor selection.
  #   selectable.nor(field: 1, field: 2)
  # @param *criteria [[ Hash | Criteria | Array<Hash | Criteria> ]...] Multiple key/value pair matches or Criteria objects.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#525
  def nor(*criteria); end

  # Negate the arguments, or the next selection if no arguments are given.
  #
  # @example Add the $not criterion.
  #   selectable.not(name: /Bob/)
  # @example Execute a $not in a where query.
  #   selectable.where(:field.not => /Bob/)
  # @example Negate the next selection.
  #   selectable.not.in(field: [ 1, 2 ])
  # @param *criteria [[ Hash | Criteria ]...] The key/value pair
  #   matches or Criteria objects to negate.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#554
  def not(*criteria); end

  # Adds the $nin selection to the selectable.
  #
  # @example Add $nin selection on a range.
  #   selectable.nin(age: 18..24)
  # @example Add $nin selection on an array.
  #   selectable.nin(age: [ 1, 2, 3 ])
  # @example Execute an $nin in a where query.
  #   selectable.where(:field.nin => [ 1, 2, 3 ])
  # @param condition [Hash] The field/value criterion pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#513
  def not_in(condition); end

  # Creates a disjunction using $or from the existing criteria in the
  # receiver and the provided arguments.
  #
  # This behavior (receiver becoming one of the disjunction operands)
  # matches ActiveRecord's +or+ behavior.
  #
  # Use +any_of+ to add a disjunction of the arguments as an additional
  # constraint to the criteria already existing in the receiver.
  #
  # Each argument can be a Hash, a Criteria object, an array of
  # Hash or Criteria objects, or a nested array. Nested arrays will be
  # flattened and can be of any depth. Passing arrays is deprecated.
  #
  # @example Add the $or selection where both fields must have the specified values.
  #   selectable.or(field: 1, field: 2)
  # @example Add the $or selection where either value match is sufficient.
  #   selectable.or({field: 1}, {field: 2})
  # @example Same as previous example but using the deprecated array wrap.
  #   selectable.or([{field: 1}, {field: 2}])
  # @example Same as previous example, also deprecated.
  #   selectable.or([{field: 1}], [{field: 2}])
  # @param *criteria [[ Hash | Criteria | Array<Hash | Criteria> ]...] Multiple key/value pair matches or Criteria objects, or arrays
  #   thereof. Passing arrays is deprecated.
  # @return [Selectable] The new selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#644
  def or(*criteria); end

  # Returns the value of attribute selector.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#25
  def selector; end

  # Sets the attribute selector
  #
  # @param value the value to set the attribute selector to.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#25
  def selector=(_arg0); end

  # Construct a text search selector.
  #
  # @example Construct a text search selector with options.
  #   selectable.text_search("testing", :$language => "fr")
  # @example Construct a text search selector.
  #   selectable.text_search("testing")
  # @note Per https://www.mongodb.com/docs/manual/reference/operator/query/text/
  #   it is not currently possible to supply multiple text search
  #   conditions in a query. Mongoid will build such a query but the
  #   server will return an error when trying to execute it.
  # @param opts [Hash] Text search options. See MongoDB documentation
  #   for options.
  # @param terms [String | Symbol] A string of terms that MongoDB parses
  #   and uses to query the text index.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#776
  def text_search(terms, opts = T.unsafe(nil)); end

  # This is the general entry point for most MongoDB queries. This either
  # creates a standard field: value selection, and expanded selection with
  # the use of hash methods, or a $where selection if a string is provided.
  #
  # @example Add a javascript selection.
  #   selectable.where("this.name == 'syd'")
  # @example Add a standard selection.
  #   selectable.where(name: "syd")
  # @param *criterion [[ Hash | String ]...] The standard selection
  #   or javascript string.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#812
  def where(*criteria); end

  # Add a $size selection for array fields.
  #
  # @example Add the $size selection.
  #   selectable.with_size(field: 5)
  # @example Execute an $size in a where query.
  #   selectable.where(:field.with_size => 10)
  # @note This method is named #with_size not to conflict with any existing
  #   #size method on enumerables or symbols.
  # @param criterion [Hash] The field/size pairs criterion.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#718
  def with_size(criterion); end

  # Adds a $type selection to the selectable.
  #
  # @example Add the $type selection.
  #   selectable.with_type(field: 15)
  # @example Execute an $type in a where query.
  #   selectable.where(:field.with_type => 15)
  # @note http://vurl.me/PGOU contains a list of all types.
  # @param criterion [Hash] The field/type pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#744
  def with_type(criterion); end

  private

  # Adds the specified expression to the query.
  #
  # Criterion must be a hash in one of the following forms:
  # - {field_name: value}
  # - {'field_name' => value}
  # - {key_instance: value}
  # - {'$operator' => operator_value_expression}
  #
  # Field name and operator may be given as either strings or symbols.
  #
  # @api private
  # @example Create the selection.
  #   selectable.expr_query(age: 50)
  # @param criterion [Hash] The field/value pairs.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#852
  def expr_query(criterion); end

  # Create a javascript selection.
  #
  # @api private
  # @example Create the javascript selection.
  #   selectable.js_query("this.age == 50")
  # @param criterion [String] The javascript as a string.
  # @return [Selectable] The cloned selectable
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#904
  def js_query(criterion); end

  # Take the provided criterion and store it as a selection in the query
  # selector.
  #
  # @api private
  # @example Store the selection.
  #   selectable.selection({ field: "value" })
  # @param criterion [Hash] The selection to store.
  # @return [Selectable] The cloned selectable.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#926
  def selection(criterion = T.unsafe(nil)); end

  # Force the values of the criterion to be evolved.
  #
  # @api private
  # @example Force values to booleans.
  #   selectable.force_typing(criterion) do |val|
  #   Boolean.evolve(val)
  #   end
  # @param criterion [Hash] The criterion.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#885
  def typed_override(criterion, operator); end

  class << self
    # Get the methods on the selectable that can be forwarded to from a model.
    #
    # @example Get the forwardable methods.
    #   Selectable.forwardables
    # @return [Array<Symbol>] The names of the forwardable methods.
    #
    # source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#945
    def forwardables; end
  end
end

# Constant for a LineString $geometry.
#
# source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#15
Mongoid::Criteria::Queryable::Selectable::LINE_STRING = T.let(T.unsafe(nil), String)

# Constant for a Point $geometry.
#
# source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#18
Mongoid::Criteria::Queryable::Selectable::POINT = T.let(T.unsafe(nil), String)

# Constant for a Polygon $geometry.
#
# source://mongoid//lib/mongoid/criteria/queryable/selectable.rb#21
Mongoid::Criteria::Queryable::Selectable::POLYGON = T.let(T.unsafe(nil), String)

# The selector is a special kind of hash that knows how to serialize values
# coming into it as well as being alias and locale aware for key names.
#
# source://mongoid//lib/mongoid/criteria/queryable/selector.rb#10
class Mongoid::Criteria::Queryable::Selector < ::Mongoid::Criteria::Queryable::Smash
  # Store the value in the selector for the provided key. The selector will
  # handle all necessary serialization and localization in this step.
  #
  # @example Store a value in the selector.
  #   selector.store(:key, "testing")
  # @param key [String | Symbol] The name of the attribute.
  # @param value [Object] The value to add.
  # @return [Object] The stored object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#61
  def []=(key, value); end

  # Merges another selector into this one.
  #
  # @example Merge in another selector.
  #   selector.merge!(name: "test")
  # @param other [Hash | Selector] The object to merge in.
  # @return [Selector] The selector.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#20
  def merge!(other); end

  # Store the value in the selector for the provided key. The selector will
  # handle all necessary serialization and localization in this step.
  #
  # @example Store a value in the selector.
  #   selector.store(:key, "testing")
  # @param key [String | Symbol] The name of the attribute.
  # @param value [Object] The value to add.
  # @return [Object] The stored object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#51
  def store(key, value); end

  # Convert the selector to an aggregation pipeline entry.
  #
  # @example Convert the selector to a pipeline.
  #   selector.to_pipeline
  # @return [Array<Hash>] The pipeline entry for the selector.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#69
  def to_pipeline; end

  private

  # Evolve a single key selection with various types of values.
  #
  # @api private
  # @example Evolve a simple selection.
  #   selector.evolve(field, 5)
  # @param serializer [Object] The optional serializer for the field.
  # @param value [Object] The value to serialize.
  # @return [Object] The serialized object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#153
  def evolve(serializer, value); end

  # Evolve a single key selection with array values.
  #
  # @api private
  # @example Evolve a simple selection.
  #   selector.evolve(field, [ 1, 2, 3 ])
  # @param serializer [Object] The optional serializer for the field.
  # @param value [Array<Object>] The array to serialize.
  # @return [Object] The serialized array.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#179
  def evolve_array(serializer, value); end

  # Evolve a single key selection with hash values.
  #
  # @api private
  # @example Evolve a simple selection.
  #   selector.evolve(field, { "$gt" => 5 })
  # @param serializer [Object] The optional serializer for the field.
  # @param value [Hash] The hash to serialize.
  # @return [Object] The serialized hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#196
  def evolve_hash(serializer, value); end

  # Evolves a multi-list selection, like an $and or $or criterion, and
  # performs the necessary serialization.
  #
  # @api private
  # @example Evolve the multi-selection.
  #   selector.evolve_multi([{ field: "value" }])
  # @param specs [Array<Hash>] The multi-selection.
  # @return [Array<Hash>] The serialized values.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#106
  def evolve_multi(specs); end

  # Evolve a single key selection with range values. This method traverses
  # the association tree to build a query for the given value and
  # serializer. There are three parts to the query here:
  #
  # (1) "klass.child.gchild" => {
  #       "$elemMatch" => {
  #     (2) "ggchild.field" => (3) { "$gte" => 6, "$lte" => 10 }
  #       }
  #     }
  # (1) The first n fields are dotted together until the last
  #     embeds_many or field of type array. In the above case, gchild
  #     would be an embeds_many or Array, and ggchild would be an
  #     embeds_one or a hash.
  # (2) The last fields are used inside the $elemMatch. This one is
  #     actually optional, and will be ignored if the last field is an
  #     array or embeds_many. If the last field is an array (1), (2) and
  #     (3) will look like:
  #
  #       "klass.child.gchild.ggchild.field" => {
  #         { "$elemMatch" => { "$gte" => 6, "$lte" => 10 } }
  #       }
  #
  # (3) This is calculated by:
  #
  #       value.__evolve_range__(serializer: serializer).
  #
  # @api private
  # @param key [String] The key at which to store the range.
  # @param serializer [Object] The optional serializer for the field.
  # @param value [Range] The Range to serialize.
  # @return [Array<String, Hash>] The store name and serialized Range.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#239
  def evolve_range(key, serializer, value); end

  # Determines if the selection is a multi-select, like an $and or $or or $nor
  # selection.
  #
  # @api private
  # @example Is the selection a multi-select?
  #   selector.multi_selection?("$and")
  # @param key [String] The key to check.
  # @return [true | false] If the key is for a multi-select.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#284
  def multi_selection?(key); end

  # Get the store name and store value. If the value is of type range,
  # we need may need to change the store_name as well as the store_value,
  # therefore, we cannot just use the evolve method.
  #
  # @param name [String] The name of the field.
  # @param serializer [Object] The optional serializer for the field.
  # @param value [Object] The value to serialize.
  # @return [Array<String, String>] The store name and store value.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/selector.rb#86
  def store_creds(name, serializer, value); end
end

# This is a smart hash for use with options and selectors.
#
# source://mongoid//lib/mongoid/criteria/queryable/smash.rb#9
class Mongoid::Criteria::Queryable::Smash < ::Hash
  # Initialize the new selector.
  #
  # @example Initialize the new selector.
  #   Queryable::Smash.new(aliases, serializers)
  # @param aliased_associations [Hash] An optional hash of mappings from
  #   aliases for associations to their actual field names in the database.
  # @param aliases [Hash] A hash of mappings from aliases to the actual
  #   field names in the database.
  # @param associations [Hash] An optional hash of names to association
  #   objects.
  # @param serializers [Hash] An optional hash of objects that are
  #   responsible for serializing values. The keys of the hash must be
  #   strings that match the field name, and the values must respond to
  #   #localized? and #evolve(object).
  # @return [Smash] a new instance of Smash
  # @yield [_self]
  # @yieldparam _self [Mongoid::Criteria::Queryable::Smash] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#52
  def initialize(aliases = T.unsafe(nil), serializers = T.unsafe(nil), associations = T.unsafe(nil), aliased_associations = T.unsafe(nil)); end

  # Get an item from the smart hash by the provided key.
  #
  # @example Get an item by the key.
  #   smash["test"]
  # @param key [String] The key.
  # @return [Object] The found object.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#68
  def [](key); end

  # Perform a deep copy of the smash.
  #
  # @example Perform a deep copy.
  #   smash.__deep_copy__
  # @return [Smash] The copied hash.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#29
  def __deep_copy__; end

  # Returns the value of attribute aliased_associations.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#21
  def aliased_associations; end

  # Returns the value of attribute aliases.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#12
  def aliases; end

  # Returns the value of attribute associations.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#18
  def associations; end

  # Returns the value of attribute serializers.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#15
  def serializers; end

  private

  # Retrieves the serializer for the given name. If the name exists in
  # the serializers hash then return that immediately, otherwise
  # recursively look through the associations and find the appropriate
  # field.
  #
  # @param name [String] The name of the db field.
  # @return [Object] The serializer.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#119
  def get_serializer(name); end

  # Get the localized value for the key if needed. If the field uses
  # localization the current locale will be appended to the key in
  # MongoDB dot notation.
  #
  # @api private
  # @example Get the normalized key name.
  #   smash.localized_key("field", serializer)
  # @param name [String] The name of the field.
  # @param serializer [Object] The optional field serializer.
  # @return [String] The normalized key.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#87
  def localized_key(name, serializer); end

  # Get the pair of objects needed to store the value in a hash by the
  # provided key. This is the database field name and the serializer.
  #
  # @api private
  # @example Get the name and serializer.
  #   smash.storage_pair("id")
  # @param key [Symbol | String] The key provided to the selection.
  # @return [Array<String, Object>] The name of the db field and
  #   serializer.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/smash.rb#103
  def storage_pair(key); end
end

# This module encapsulates methods that write query expressions into
# the Criteria's selector.
#
# The query expressions must have already been expanded as necessary.
# The methods of this module do not perform processing on expression
# values.
#
# Methods in this module do not handle negation - if negation is needed,
# it must have already been handled upstream of these methods.
#
# @api private
#
# source://mongoid//lib/mongoid/criteria/queryable/storable.rb#18
module Mongoid::Criteria::Queryable::Storable
  # Adds a field expression to the query.
  #
  # +field+ must be a field name, and it must be a string. The upstream
  # code must have converted other field/key types to the simple string
  # form by the time this method is invoked.
  #
  # +value+ can be of any type, it is written into the selector unchanged.
  #
  # This method performs no processing on the provided field value.
  #
  # Mutates the receiver.
  #
  # @api private
  # @param field [String] The field name.
  # @param value [Object] The field value.
  # @return [Storable] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/storable.rb#36
  def add_field_expression(field, value); end

  # Adds a logical operator expression to the selector.
  #
  # This method only handles logical operators ($and, $nor and $or).
  # It raises ArgumentError if called with another operator. Note that
  # in MQL, $not is a field-level operator and not a query-level one,
  # and therefore $not is not handled by this method.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # If the selector consists of a single condition which is the specified
  # operator (on the top level), the new condition given in op_expr is
  # added to the existing conditions for the specified operator.
  # For example, if the selector is currently:
  #
  #     {'$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is +[{'test' => 123'}]+,
  # the resulting selector will be:
  #
  #     {'$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This method always adds the new conditions as additional requirements;
  # in other words, it does not implement the ActiveRecord or/nor behavior
  # where the receiver becomes one of the operands. It is expected that
  # code upstream of this method implements such behavior.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  # Such simplification is also expected to have already been performed
  # by the upstream code.
  #
  # This method mutates the receiver.
  #
  # @api private
  # @param op_expr [Array<Hash>] Operator value to add.
  # @param operator [String] The operator to add.
  # @return [Storable] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/storable.rb#108
  def add_logical_operator_expression(operator, op_expr); end

  # Adds an arbitrary expression to the query.
  #
  # Field can either be a field name or an operator.
  #
  # Mutates the receiver.
  #
  # @api private
  # @param field [String] Field name or operator name.
  # @param value [Object] Field value or operator expression.
  # @return [Storable] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/storable.rb#223
  def add_one_expression(field, value); end

  # Adds an operator expression to the selector.
  #
  # This method takes the operator and the operator value expression
  # separately for callers' convenience. It can be considered to
  # handle storing the hash +{operator => op_expr}+.
  #
  # The operator value can be of any type.
  #
  # If the selector already has the specified operator in it (on the
  # top level), the new condition given in op_expr is added to the
  # existing conditions for the specified operator. This is
  # straightforward for $and; for other logical operators, the behavior
  # of this method is to add the new conditions to the existing operator.
  # For example, if the selector is currently:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}]}
  #
  # ... and operator is '$or' and op_expr is +{'test' => 123'}+,
  # the resulting selector will be:
  #
  #     {'foo' => 'bar', '$or' => [{'hello' => 'world'}, {'test' => 123}]}
  #
  # This does not implement an OR between the existing selector and the
  # new operator expression - handling this is the job of upstream
  # methods. This method simply stores op_expr into the selector on the
  # assumption that the existing selector is the correct left hand side
  # of the operation already.
  #
  # For non-logical query-level operators like $where and $text, if
  # there already is a top-level operator with the same name, the
  # op_expr is added to the selector via a top-level $and operator,
  # thus producing a selector having both operator values.
  #
  # This method does not simplify values (i.e. if the selector is
  # currently empty and operator is $and, op_expr is written to the
  # selector with $and even if the $and can in principle be elided).
  #
  # This method mutates the receiver.
  #
  # @api private
  # @param op_expr [Object] Operator value to add.
  # @param operator [String] The operator to add.
  # @return [Storable] self.
  #
  # source://mongoid//lib/mongoid/criteria/queryable/storable.rb#188
  def add_operator_expression(operator, op_expr); end
end

# Mixin module included in Mongoid::Criteria which adds
# functionality related to default query scopes and named
# scopes.
#
# source://mongoid//lib/mongoid/criteria/scopable.rb#10
module Mongoid::Criteria::Scopable
  # Applies the default scope to the criteria.
  #
  # @example Apply the default scope.
  #   criteria.apply_default_scope
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#18
  def apply_default_scope; end

  # Applies a scope to the current criteria.
  #
  # This method does not modify the receiver but it may return a new
  # object or the receiver depending on the argument: if the +scope+
  # argument is nil, the receiver is returned without modification,
  # otherwise a new criteria object is returned.
  #
  # @api private
  # @param scope [Proc | Symbol | Criteria | nil] The scope to apply.
  # @return [Criteria] The criteria with the scope applied.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#37
  def apply_scope(scope); end

  # Given another criteria, remove the other criteria's scoping from this
  # criteria.
  #
  # @example Remove the scoping.
  #   criteria.remove_scoping(other)
  # @param other [Criteria] The other criteria.
  # @return [Criteria] The criteria with scoping removed.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#59
  def remove_scoping(other); end

  # Forces the criteria to be scoped, unless its inside an unscoped block.
  #
  # @example Force the criteria to be scoped.
  #   criteria.scoped(skip: 10)
  # @param options [Hash] Additional query options.
  # @return [Criteria] The scoped criteria.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#77
  def scoped(options = T.unsafe(nil)); end

  # Has the criteria had the default scope applied?
  #
  # @example Is the default scope applied?
  #   criteria.scoped?
  # @return [true | false] If the default scope is applied.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#92
  def scoped?; end

  # Get the criteria scoping options, as a pair (scoped, unscoped).
  #
  # @example Get the scoping options.
  #   criteria.scoping_options
  # @return [Array] Scoped, unscoped.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#127
  def scoping_options; end

  # Set the criteria scoping options, as a pair (scoped, unscoped).
  #
  # @example Set the scoping options.
  #   criteria.scoping_options = true, false
  # @param options [Array] Scoped, unscoped.
  # @return [Array] The new scoping options.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#139
  def scoping_options=(options); end

  # Clears all scoping from the criteria.
  #
  # @example Clear all scoping from the criteria.
  #   criteria.unscoped
  # @return [Criteria] The unscoped criteria.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#102
  def unscoped; end

  # Is the criteria unscoped?
  #
  # @example Is the criteria unscoped?
  #   criteria.unscoped?
  # @return [true | false] If the criteria is force unscoped.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#117
  def unscoped?; end

  # Get the criteria with the default scope applied, if the default scope
  # is able to be applied. Cases in which it cannot are: If we are in an
  # unscoped block, if the criteria is already forced unscoped, or the
  # default scope has already been applied.
  #
  # @example Get the criteria with the default scope.
  #   criteria.with_default_scope
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/criteria/scopable.rb#152
  def with_default_scope; end

  private

  # source://mongoid//lib/mongoid/criteria/scopable.rb#162
  def reject_matching(other, *methods); end
end

# This is a helper module for translating atomic and composite
# Ruby values into corresponding query and option components.
# Originally implemented as patches to core classes, that approach
# has generally fallen into disfavor, as it bleeds too much into
# the public namespace.
#
# @api private
#
# source://mongoid//lib/mongoid/criteria/translator.rb#14
module Mongoid::Criteria::Translator
  extend ::Mongoid::Criteria::Translator

  # Converts the given value to a direction specification for use in
  # sorting.
  #
  # @api private
  # @example Convert the value to a direction.
  #   Translator.to_direction(:desc)
  #   Translator.to_direction("1")
  #   Translator.to_direction(-1)
  #   Translator.to_direction(score: { "$meta": "textScore" })
  # @param value [Hash | Numeric | String | Symbol] The value to convert.
  # @return [Hash | Numeric] The direction.
  #
  # source://mongoid//lib/mongoid/criteria/translator.rb#29
  def to_direction(value); end
end

# Adds ability to declare Mongoid-specific deprecations.
#
# @api private
#
# source://mongoid//lib/mongoid/deprecable.rb#11
module Mongoid::Deprecable
  # Declares method(s) as deprecated.
  #
  # @api private
  # @example Deprecate a method and declare the replacement method.
  #   Mongoid.deprecate(Cat, meow: :speak); Cat.new.meow
  #   #=> Mongoid.logger.warn("meow is deprecated and will be removed from Mongoid 8.0 (use speak instead)")
  # @example Deprecate a method and give replacement instructions.
  #   Mongoid.deprecate(Cat, meow: 'eat :catnip instead'); Cat.new.meow
  #   #=> Mongoid.logger.warn("meow is deprecated and will be removed from Mongoid 8.0 (eat :catnip instead)")
  # @example Deprecate a method.
  #   Mongoid.deprecate(Cat, :meow); Cat.new.meow
  #   #=> Mongoid.logger.warn("meow is deprecated and will be removed from Mongoid 8.0")
  # @param *method_descriptors [[ Symbol | Hash<Symbol, [ Symbol | String ]> ]...] The methods to deprecate, with optional replacement instructions.
  # @param target_module [Module] The parent which contains the method.
  #
  # source://mongoid//lib/mongoid/deprecable.rb#30
  def deprecate(target_module, *method_descriptors); end
end

# Utility class for logging deprecation warnings.
#
# source://mongoid//lib/mongoid/deprecation.rb#7
class Mongoid::Deprecation < ::ActiveSupport::Deprecation
  # @return [Deprecation] a new instance of Deprecation
  #
  # source://mongoid//lib/mongoid/deprecation.rb#9
  def initialize; end

  # Overrides default ActiveSupport::Deprecation behavior
  # to use Mongoid's logger.
  #
  # @return [Array<Proc>] The deprecation behavior.
  #
  # source://mongoid//lib/mongoid/deprecation.rb#21
  def behavior; end
end

# This is the base module for all domain objects that need to be persisted to
# the database as documents.
#
# source://mongoid//lib/mongoid/document.rb#25
module Mongoid::Document
  include ::Mongoid::Touchable::InstanceMethods
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::Model
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Validatable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Interceptable
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable
  include ::Mongoid::Composable

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveModel::Conversion::ClassMethods
  mixes_in_class_methods ::Mongoid::Changeable::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::StorageOptions::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Options::ClassMethods
  mixes_in_class_methods ::Mongoid::Clients::Sessions::ClassMethods
  mixes_in_class_methods ::Mongoid::CollectionConfigurable::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Nested::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::Readonly::ClassMethods
  mixes_in_class_methods ::Mongoid::Attributes::ClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods
  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Depending::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Macros::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Reflections::ClassMethods
  mixes_in_class_methods ::Mongoid::Association::Referenced::Syncable::ClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods
  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods
  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::Mongoid::Equality::ClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods
  mixes_in_class_methods ::Mongoid::Findable
  mixes_in_class_methods ::Mongoid::Document::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  # Instantiate a new +Document+, setting the Document's attributes if
  # given. If no attributes are provided, they will be initialized with
  # an empty +Hash+.
  #
  # If a primary key is defined, the document's id will be set to that key,
  # otherwise it will be set to a fresh +BSON::ObjectId+ string.
  #
  # @example Create a new document.
  #   Person.new(:title => 'Sir')
  # @param attrs [Hash] The attributes to set up the document with.
  # @return [Document] A new document.
  #
  # source://mongoid//lib/mongoid/document.rb#104
  def initialize(attrs = T.unsafe(nil), &block); end

  # Returns the value of attribute __selected_fields.
  #
  # source://mongoid//lib/mongoid/document.rb#30
  def __selected_fields; end

  # Sets the attribute __selected_fields
  #
  # @param value the value to set the attribute __selected_fields to.
  #
  # source://mongoid//lib/mongoid/document.rb#30
  def __selected_fields=(_arg0); end

  # Handles the setup and execution of callbacks, if callbacks are to
  # be executed; otherwise, adds the appropriate callbacks to the pending
  # callbacks list.
  #
  # @api private
  # @param execute_callbacks [true | false] Whether callbacks should be
  #   executed or not.
  #
  # source://mongoid//lib/mongoid/document.rb#186
  def _handle_callbacks_after_instantiation(execute_callbacks); end

  # Return a hash of the entire document hierarchy from this document and
  # below. Used when the attributes are needed for everything and not just
  # the current document.
  #
  # @example Get the full hierarchy.
  #   person.as_document
  # @return [Hash] A hash of all attributes in the hierarchy.
  #
  # source://mongoid//lib/mongoid/document.rb#136
  def as_document; end

  # Returns an instance of the specified class with the attributes,
  # errors, and embedded documents of the current document.
  #
  # @example Return a subclass document as a superclass instance.
  #   manager.becomes(Person)
  # @param klass [Class] The class to become.
  # @raise [ArgumentError] If the class doesn't include Mongoid::Document
  # @return [Document] An instance of the specified class.
  #
  # source://mongoid//lib/mongoid/document.rb#151
  def becomes(klass); end

  # Freezes the internal attributes of the document.
  #
  # @example Freeze the document
  #   document.freeze
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/document.rb#51
  def freeze; end

  # Checks if the document is frozen
  #
  # @example Check if frozen
  #   document.frozen?
  # @return [true | false] True if frozen, else false.
  #
  # source://mongoid//lib/mongoid/document.rb#61
  def frozen?; end

  # Delegates to identity in order to allow two records of the same identity
  # to work with something like:
  #
  #   [ Person.find(1), Person.find(2), Person.find(3) ] &
  #   [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  #
  # @example Get the hash.
  #   document.hash
  # @return [Integer] The hash of the document's identity.
  #
  # source://mongoid//lib/mongoid/document.rb#75
  def hash; end

  # A Document's is identified absolutely by its class and database id:
  #
  # Person.first.identity #=> [Person, BSON::ObjectId('4f775130a04745933a000003')]
  #
  # @example Get the identity
  #   document.identity
  # @return [Array] An array containing [document.class, document._id]
  #
  # source://mongoid//lib/mongoid/document.rb#87
  def identity; end

  # Sets the internal state of this document. Used only by #becomes to
  # help initialize a retyped document.
  #
  # @api private
  # @param state [Hash] The map of internal state values.
  #
  # source://mongoid//lib/mongoid/document.rb#166
  def internal_state=(state); end

  # Return the model name of the document.
  #
  # @example Return the model name.
  #   document.model_name
  # @return [String] The model name.
  #
  # source://mongoid//lib/mongoid/document.rb#114
  def model_name; end

  # Returns the value of attribute new_record.
  #
  # source://mongoid//lib/mongoid/document.rb#31
  def new_record; end

  # Return the key value for the document.
  #
  # @example Return the key.
  #   document.to_key
  # @return [String] The id of the document or nil if new.
  #
  # source://mongoid//lib/mongoid/document.rb#124
  def to_key; end

  private

  # Adds the attributes for the given relation to the document's attributes.
  #
  # @param meta [Mongoid::Assocation::Relatable] the relation object
  # @param name [String | Symbol] the name of the relation to add
  #
  # source://mongoid//lib/mongoid/document.rb#283
  def add_attributes_for_relation(name, meta); end

  # Returns a hash of the attributes.
  #
  # Note this method modifies the attributes hash that already exists on the
  # class and returns it. This means that the hash returned by this method
  # refers to the same hash as calling #attributes on the instance. See
  # MONGOID-4476 for an explanation on how this is used.
  #
  # @return [Hash] The attributes hash.
  #
  # source://mongoid//lib/mongoid/document.rb#267
  def as_attributes; end

  # Does the construction of a document.
  #
  # @api private
  # @note A Ruby 2.x bug prevents the options hash from being keyword
  #   arguments. Once we drop support for Ruby 2.x, we can reimplement
  #   the options hash as keyword arguments.
  #   See https://bugs.ruby-lang.org/issues/15753
  # @option options
  # @param attrs [Hash] The attributes to set up the document with.
  # @param options [Hash] The options to use.
  # @return [Document] A new document.
  #
  # source://mongoid//lib/mongoid/document.rb#216
  def construct_document(attrs = T.unsafe(nil), options = T.unsafe(nil)); end

  # Constructs a hash representing the internal state of this object,
  # suitable for passing to #internal_state=.
  #
  # @return [Hash] the map of internal state values
  #
  # source://mongoid//lib/mongoid/document.rb#310
  def internal_state; end

  # Returns the logger
  #
  # @return [Logger] The configured logger or a default Logger instance.
  #
  # source://mongoid//lib/mongoid/document.rb#245
  def logger; end

  # Marks all embedded documents with the given "new_record" state.
  #
  # @param new_record [true | false] whether or not the embedded records
  #   should be flagged as new records or not.
  #
  # source://mongoid//lib/mongoid/document.rb#334
  def mark_persisted_state_for_embedded_documents(new_record); end

  # Get the name of the model used in caching.
  #
  # @example Get the model key.
  #   model.model_key
  # @return [String] The model key.
  #
  # source://mongoid//lib/mongoid/document.rb#255
  def model_key; end

  # Checks that the given argument is an instance of `Mongoid::Document`.
  #
  # @param klass [Class] The class to test.
  # @raise [ArgumentError] if the class does not include
  #   Mongoid::Document.
  #
  # source://mongoid//lib/mongoid/document.rb#300
  def mongoid_document_check!(klass); end

  # Initializes the object state prior to attribute processing; this is
  # called only from #construct_document.
  #
  # source://mongoid//lib/mongoid/document.rb#235
  def prepare_to_process_attributes; end

  # Either executes or enqueues the post-construction callbacks.
  #
  # @param execute_callbacks [true | false] whether the callbacks
  #   should be executed (true) or enqueued (false)
  #
  # source://mongoid//lib/mongoid/document.rb#349
  def resolve_post_construction_callbacks(execute_callbacks); end

  # Updates the value of the discriminator_key for this object, setting its
  # previous value to `key_was`.
  #
  # @param key_was [String] the previous value of the discriminator key.
  #
  # source://mongoid//lib/mongoid/document.rb#325
  def update_discriminator(key_was); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
    def embedded; end
    def embedded=(value); end
    def embedded?; end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter; end
    def param_delimiter=(value); end
    def param_delimiter?; end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def storage_options; end
    def storage_options=(value); end
    def storage_options?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def _validators; end
    def _validators?; end
    def aliased_associations; end
    def aliased_associations=(value); end
    def aliased_associations?; end
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def cyclic; end
    def cyclic=(value); end
    def cyclic?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
    def dependents; end
    def dependents=(value); end
    def dependents?; end
    def dependents_owner; end
    def dependents_owner=(value); end
    def dependents_owner?; end
    def embedded=(value); end
    def embedded_relations; end
    def embedded_relations=(value); end
    def embedded_relations?; end
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def include_root_in_json; end
    def include_root_in_json?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def nested_attributes; end
    def nested_attributes=(value); end
    def nested_attributes?; end
    def param_delimiter=(value); end
    def polymorphic; end
    def polymorphic=(value); end
    def polymorphic?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
    def readonly_attributes; end
    def readonly_attributes=(value); end
    def readonly_attributes?; end
    def relations; end
    def relations=(value); end
    def relations?; end
    def stored_as_associations; end
    def stored_as_associations=(value); end
    def stored_as_associations?; end
  end
end

# Class-level methods for Document objects.
#
# source://mongoid//lib/mongoid/document.rb#360
module Mongoid::Document::ClassMethods
  # Clear the @_type cache. This is generally called when changing the discriminator
  # key/value on a class.
  #
  # @api private
  # @example Get the types.
  #   document._mongoid_clear_types
  #
  # source://mongoid//lib/mongoid/document.rb#463
  def _mongoid_clear_types; end

  # Returns all types to query for when using this class as the base.
  #
  # @example Get the types.
  #   document._types
  # @return [Array<Class>] All subclasses of the current document.
  #
  # source://mongoid//lib/mongoid/document.rb#452
  def _types; end

  # Allocates and constructs a document.
  #
  # @api private
  # @note A Ruby 2.x bug prevents the options hash from being keyword
  #   arguments. Once we drop support for Ruby 2.x, we can reimplement
  #   the options hash as keyword arguments.
  #   See https://bugs.ruby-lang.org/issues/15753
  # @option options
  # @param attrs [Hash] The attributes to set up the document with.
  # @param options [Hash] The options to use.
  # @return [Document] A new document.
  #
  # source://mongoid//lib/mongoid/document.rb#441
  def construct_document(attrs = T.unsafe(nil), options = T.unsafe(nil)); end

  # Set the i18n scope to overwrite ActiveModel.
  #
  # @return [Symbol] :mongoid
  #
  # source://mongoid//lib/mongoid/document.rb#471
  def i18n_scope; end

  # Instantiate a new object, only when loaded from the database or when
  # the attributes have already been typecast.
  #
  # @example Create the document.
  #   Person.instantiate(:title => 'Sir', :age => 30)
  # @param attrs [Hash] The hash of attributes to instantiate with.
  # @param selected_fields [Integer] The selected fields from the
  #   criteria.
  # @return [Document] A new document.
  #
  # source://mongoid//lib/mongoid/document.rb#386
  def instantiate(attrs = T.unsafe(nil), selected_fields = T.unsafe(nil), &block); end

  # Instantiate the document.
  #
  # @api private
  # @note A Ruby 2.x bug prevents the options hash from being keyword
  #   arguments. Once we drop support for Ruby 2.x, we can reimplement
  #   the options hash as keyword arguments.
  # @option options
  # @param attrs [Hash] The hash of attributes to instantiate with.
  # @param options [Hash] The options to use.
  # @param selected_fields [Integer] The selected fields from the
  #   criteria.
  # @return [Document] A new document.
  # @yield [Mongoid::Document] If a block is given, yields the newly
  #   instantiated document to it.
  #
  # source://mongoid//lib/mongoid/document.rb#410
  def instantiate_document(attrs = T.unsafe(nil), selected_fields = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the logger
  #
  # @example Get the logger.
  #   Person.logger
  # @return [Logger] The configured logger or a default Logger instance.
  #
  # source://mongoid//lib/mongoid/document.rb#481
  def logger; end

  # Indicate whether callbacks should be invoked by default or not,
  # within the block. Callbacks may always be explicitly invoked by passing
  # `execute_callbacks: true` where available.
  #
  # @param execute_callbacks [true | false] Whether callbacks should be
  #   suppressed or not.
  #
  # source://mongoid//lib/mongoid/document.rb#367
  def with_callbacks(execute_callbacks); end
end

# Regex for matching illegal BSON keys.
# Note that bson 4.1 has the constant BSON::String::ILLEGAL_KEY
# that should be used instead.
# When ruby driver 2.3.0 is released and Mongoid can be updated
# to require >= 2.3.0, the BSON constant can be used.
#
# source://mongoid//lib/mongoid/document.rb#43
Mongoid::Document::ILLEGAL_KEY = T.let(T.unsafe(nil), Regexp)

# This module is used to extend Mongoid::Document
# to add encryption functionality.
#
# source://mongoid//lib/mongoid/encryptable.rb#5
module Mongoid::Encryptable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Encryptable::ClassMethods

  module GeneratedClassMethods
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
  end

  module GeneratedInstanceMethods
    def encrypt_metadata; end
    def encrypt_metadata=(value); end
    def encrypt_metadata?; end
  end
end

# source://mongoid//lib/mongoid/encryptable.rb#14
module Mongoid::Encryptable::ClassMethods
  # Set the encryption metadata for the model. Parameters set here will be
  # used to encrypt the fields of the model, unless overridden on the
  # field itself.
  #
  # is deterministic or not.
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The encryption metadata.
  #
  # source://mongoid//lib/mongoid/encryptable.rb#27
  def encrypt_with(options = T.unsafe(nil)); end

  # Whether the model is encrypted. It means that either the encrypt_with
  # method was called on the model, or at least one of the fields
  # is encrypted.
  #
  # @return [true | false] Whether the model is encrypted.
  #
  # source://mongoid//lib/mongoid/encryptable.rb#36
  def encrypted?; end

  # Override the key_id for the model.
  #
  # This method is solely for testing purposes and should not be used in
  # the application code. The schema_map is generated very early in the
  # application lifecycle, and overriding the key_id after that will not
  # have any effect.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/encryptable.rb#48
  def set_key_id(key_id); end
end

# This module contains the behavior of Mongoid's clone/dup of documents.
#
# source://mongoid//lib/mongoid/equality.rb#7
module Mongoid::Equality
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Equality::ClassMethods

  # Default comparison is via the string version of the id.
  #
  # @example Compare two documents.
  #   person <=> other_person
  # @param other [Document] The document to compare with.
  # @return [Integer] -1, 0, 1.
  #
  # source://mongoid//lib/mongoid/equality.rb#20
  def <=>(other); end

  # Performs equality checking on the document ids. For more robust
  # equality checking please override this method.
  #
  # @example Compare for equality.
  #   document == other
  # @param other [Document | Object] The other object to compare with.
  # @return [true | false] True if the ids are equal, false if not.
  #
  # source://mongoid//lib/mongoid/equality.rb#34
  def ==(other); end

  # Delegates to ==. Used when needing checks in hashes.
  #
  # @example Perform equality checking.
  #   document.eql?(other)
  # @param other [Document | Object] The object to check against.
  # @return [true | false] True if equal, false if not.
  #
  # source://mongoid//lib/mongoid/equality.rb#47
  def eql?(other); end
end

# source://mongoid//lib/mongoid/equality.rb#51
module Mongoid::Equality::ClassMethods
  # Performs class equality checking.
  #
  # @example Compare the classes.
  #   document === other
  # @param other [Document | Object] The other object to compare with.
  # @return [true | false] True if the classes are equal, false if not.
  #
  # source://mongoid//lib/mongoid/equality.rb#60
  def ===(other); end
end

# source://mongoid//lib/mongoid/errors/mongoid_error.rb#5
module Mongoid::Errors; end

# This error is raised in case of an ambiguous association.
#
# @example An ambiguous association.
#   class Person
#   include Mongoid::Document
#
#   has_many :invitations, inverse_of: :person
#   has_many :referred_invitations, class_name: "Invitation", inverse_of: :referred_by
#   end
#
#   class Invitation
#   include Mongoid::Document
#
#   belongs_to :person
#   belongs_to :referred_by, class_name: "Person"
#   end
#
# source://mongoid//lib/mongoid/errors/ambiguous_relationship.rb#23
class Mongoid::Errors::AmbiguousRelationship < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   AmbiguousRelationship.new(
  #   Person, Drug, :person, [ :drugs, :evil_drugs ]
  #   )
  # @param candidates [Array<Symbol>] The potential inverses.
  # @param inverse [Class] The inverse class.
  # @param klass [Class] The base class.
  # @param name [Symbol] The relation name.
  # @return [AmbiguousRelationship] a new instance of AmbiguousRelationship
  #
  # source://mongoid//lib/mongoid/errors/ambiguous_relationship.rb#36
  def initialize(klass, inverse, name, candidates); end
end

# Raised when attempting to read or write an attribute which has
# not been loaded. This can occur when using `.only` or `.without`
# query projection methods.
#
# @example Getting a field which has not been loaded.
#   Band.only(:name).first.label
#   #=> raises Mongoid::Errors::AttributeNotLoaded
# @example Setting a field which has not been loaded.
#   Band.without(:label).first.label = 'Sub Pop Records'
#   #=> raises Mongoid::Errors::AttributeNotLoaded
#
# source://mongoid//lib/mongoid/errors/attribute_not_loaded.rb#18
class Mongoid::Errors::AttributeNotLoaded < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Instantiate the error.
  #   AttributeNotLoaded.new(Person, "title")
  # @param klass [Class] The model class.
  # @param name [String | Symbol] The name of the attribute.
  # @return [AttributeNotLoaded] a new instance of AttributeNotLoaded
  #
  # source://mongoid//lib/mongoid/errors/attribute_not_loaded.rb#27
  def initialize(klass, name); end
end

# This error is raised when calling #save! or .create! on a model when one
# of the callbacks returns false.
#
# source://mongoid//lib/mongoid/errors/callback.rb#9
class Mongoid::Errors::Callback < ::Mongoid::Errors::MongoidError
  # Create the new callbacks error.
  #
  # @example Create the new callbacks error.
  #   Callbacks.new(Post, :create!)
  # @param klass [Class] The class of the document.
  # @param method [Symbol] The name of the method.
  # @return [Callback] a new instance of Callback
  #
  # source://mongoid//lib/mongoid/errors/callback.rb#18
  def initialize(klass, method); end
end

# Raised when an attempt to create a collection failed.
#
# source://mongoid//lib/mongoid/errors/create_collection_failure.rb#8
class Mongoid::Errors::CreateCollectionFailure < ::Mongoid::Errors::MongoidError
  # Instantiate the create collection error.
  #
  # @api private
  # @param collection_name [String] The name of the collection that
  #   Mongoid failed to create.
  # @param collection_options [Hash] The options that were used when
  #   tried to create the collection.
  # @param error [Mongo::Error::OperationFailure] The error raised when
  #   tried to create the collection.
  # @return [CreateCollectionFailure] a new instance of CreateCollectionFailure
  #
  # source://mongoid//lib/mongoid/errors/create_collection_failure.rb#20
  def initialize(collection_name, collection_options, error); end
end

# This error is raised when a method on Criteria is given a nil argument.
#
# source://mongoid//lib/mongoid/errors/criteria_argument_required.rb#8
class Mongoid::Errors::CriteriaArgumentRequired < ::Mongoid::Errors::MongoidError
  # Creates the new exception instance.
  #
  # @api private
  # @return [CriteriaArgumentRequired] a new instance of CriteriaArgumentRequired
  #
  # source://mongoid//lib/mongoid/errors/criteria_argument_required.rb#13
  def initialize(query_method); end
end

# This error is raised when attempting to destroy a model which has
# an association with dependency option set to restrict.
#
# source://mongoid//lib/mongoid/errors/delete_restriction.rb#9
class Mongoid::Errors::DeleteRestriction < ::Mongoid::Errors::MongoidError
  # Create the new callbacks error.
  #
  # @param association_name [Symbol] The name of the dependent
  #   association that prevents the document from being deleted.
  # @param document [Document] The document that was attempted to be
  #   destroyed.
  # @return [DeleteRestriction] a new instance of DeleteRestriction
  #
  # source://mongoid//lib/mongoid/errors/delete_restriction.rb#17
  def initialize(document, association_name); end
end

# Raised when attempting to destroy a document that had destroy callbacks
# return false.
#
# source://mongoid//lib/mongoid/errors/document_not_destroyed.rb#9
class Mongoid::Errors::DocumentNotDestroyed < ::Mongoid::Errors::MongoidError
  # Instantiate the exception.
  #
  # @example Create the error.
  #   DocumentNotDestroyed.new(Band)
  # @param id [Object] The document id.
  # @param klass [Class] The document class.
  # @return [DocumentNotDestroyed] a new instance of DocumentNotDestroyed
  #
  # source://mongoid//lib/mongoid/errors/document_not_destroyed.rb#18
  def initialize(id, klass); end
end

# Raised when querying the database for a document by a specific id or by
# set of attributes which does not exist. If multiple ids were passed then
# it will display all of those.
#
# source://mongoid//lib/mongoid/errors/document_not_found.rb#10
class Mongoid::Errors::DocumentNotFound < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error with attributes instead of ids
  #   DocumentNotFound.new(Person, :ssn => "1234", :name => "Helen")
  # @example Create the error.
  #   DocumentNotFound.new(Person, ["1", "2"])
  # @param klass [Class] The model class.
  # @param params [Hash | Array | Object] The attributes or ids.
  # @param unmatched [Array | Hash] The unmatched ids, if appropriate. If
  #   there is a shard key this will be a hash.
  # @return [DocumentNotFound] a new instance of DocumentNotFound
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#26
  def initialize(klass, params, unmatched = T.unsafe(nil)); end

  # Returns the value of attribute klass.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#12
  def klass; end

  # Returns the value of attribute params.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#12
  def params; end

  private

  # Create the problem.
  #
  # @example Create the problem.
  #   error.problem
  # @return [String] The problem.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#101
  def message_key(params, unmatched); end

  # Get the string to display the document params that were unmatched.
  #
  # @example Get the missing string.
  #   error.missing(1)
  # @param unmatched [Object | Array] The ids that did not match.
  # @return [String] The missing string.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#57
  def missing(unmatched); end

  # Get the string to display the document params that were searched for.
  #
  # @example Get the searched string.
  #   error.searched(1)
  # @param params [Object | Array] The ids that were searched for.
  # @return [String] The searched string.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#75
  def searched(params); end

  # Get the shard key from the unmatched hash.
  #
  # @return [String] the shard key and value.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#116
  def shard_key(unmatched); end

  # Get the total number of expected documents.
  #
  # @example Get the total.
  #   error.total([ 1, 2, 3 ])
  # @param params [Object | Array] What was searched for.
  # @return [Integer] The total number.
  #
  # source://mongoid//lib/mongoid/errors/document_not_found.rb#91
  def total(params); end
end

# This error is raised when an empty configuration file is attempted to be
# loaded.
#
# source://mongoid//lib/mongoid/errors/empty_config_file.rb#9
class Mongoid::Errors::EmptyConfigFile < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @param path [String] The path of the config file used.
  # @return [EmptyConfigFile] a new instance of EmptyConfigFile
  #
  # source://mongoid//lib/mongoid/errors/empty_config_file.rb#16
  def initialize(path); end
end

# This error is raised when attempting the change the value of an
# immutable attribute. For example, the _id attribute is immutable,
# and attempting to change it on a document that has already been
# persisted will result in this error.
#
# source://mongoid//lib/mongoid/errors/immutable_attribute.rb#11
class Mongoid::Errors::ImmutableAttribute < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   ImmutableAttribute.new(:_id, "1234")
  # @param name [Symbol | String] The name of the attribute.
  # @param value [Object] The attempted set value.
  # @return [ImmutableAttribute] a new instance of ImmutableAttribute
  #
  # source://mongoid//lib/mongoid/errors/immutable_attribute.rb#20
  def initialize(name, value); end
end

# This error is raised when attempting to do a query with a
# collation on documents in memory.
#
# source://mongoid//lib/mongoid/errors/in_memory_collation_not_supported.rb#9
class Mongoid::Errors::InMemoryCollationNotSupported < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new unsupported collation error.
  #   InMemoryCollationNotSupported.new
  # @return [InMemoryCollationNotSupported] a new instance of InMemoryCollationNotSupported
  #
  # source://mongoid//lib/mongoid/errors/in_memory_collation_not_supported.rb#15
  def initialize; end
end

# This error is raised when an around callback is
# defined by the user without a yield
#
# source://mongoid//lib/mongoid/errors/invalid_around_callback.rb#7
class Mongoid::Errors::InvalidAroundCallback < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @return [InvalidAroundCallback] a new instance of InvalidAroundCallback
  #
  # source://mongoid//lib/mongoid/errors/invalid_around_callback.rb#11
  def initialize; end
end

# This error is raised when automatic encryption configuration for a client
# is invalid.
#
# source://mongoid//lib/mongoid/errors/invalid_auto_encryption_configuration.rb#9
class Mongoid::Errors::InvalidAutoEncryptionConfiguration < ::Mongoid::Errors::MongoidError
  # Initialize the error.
  #
  # @param name [Symbol] The name of the client config.
  # @return [InvalidAutoEncryptionConfiguration] a new instance of InvalidAutoEncryptionConfiguration
  #
  # source://mongoid//lib/mongoid/errors/invalid_auto_encryption_configuration.rb#14
  def initialize(name, kms_provider = T.unsafe(nil)); end
end

# This error is raised when trying to access a Mongo::Collection from an
# embedded document.
#
# @example Create the error.
#   InvalidCollection.new(Address)
#
# source://mongoid//lib/mongoid/errors/invalid_collection.rb#12
class Mongoid::Errors::InvalidCollection < ::Mongoid::Errors::MongoidError
  # @return [InvalidCollection] a new instance of InvalidCollection
  #
  # source://mongoid//lib/mongoid/errors/invalid_collection.rb#13
  def initialize(klass); end
end

# This error is raised when a bad configuration file is attempted to be
# loaded.
#
# source://mongoid//lib/mongoid/errors/invalid_config_file.rb#9
class Mongoid::Errors::InvalidConfigFile < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @param path [String] The path of the config file used.
  # @return [InvalidConfigFile] a new instance of InvalidConfigFile
  #
  # source://mongoid//lib/mongoid/errors/invalid_config_file.rb#16
  def initialize(path); end
end

# This error is raised when a bad configuration option is attempted to be
# set.
#
# source://mongoid//lib/mongoid/errors/invalid_config_option.rb#9
class Mongoid::Errors::InvalidConfigOption < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   InvalidConfigOption.new(:name, [ :option ])
  # @param name [Symbol | String] The attempted config option name.
  # @return [InvalidConfigOption] a new instance of InvalidConfigOption
  #
  # source://mongoid//lib/mongoid/errors/invalid_config_option.rb#17
  def initialize(name); end
end

# This error is raised when an invalid strategy is defined for an association dependency.
#
# source://mongoid//lib/mongoid/errors/invalid_dependent_strategy.rb#8
class Mongoid::Errors::InvalidDependentStrategy < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   InvalidDependentStrategy.new(association, invalid_strategy, valid_strategies)
  # @param association [Mongoid::Association] The association for which this
  #   dependency is defined.
  # @param invalid_strategy [Symbol | String] The attempted invalid strategy.
  # @param valid_strategies [Array<Symbol>] The valid strategies.
  # @return [InvalidDependentStrategy] a new instance of InvalidDependentStrategy
  #
  # source://mongoid//lib/mongoid/errors/invalid_dependent_strategy.rb#19
  def initialize(association, invalid_strategy, valid_strategies); end
end

# Creates the exception raised when trying to set or get the
# discriminator key on a child class.
#
# @api private
# @param class_name [String] The class name.
# @param operator [String] The class' superclass.
#
# source://mongoid//lib/mongoid/errors/invalid_discriminator_key_target.rb#14
class Mongoid::Errors::InvalidDiscriminatorKeyTarget < ::Mongoid::Errors::MongoidError
  # @api private
  # @return [InvalidDiscriminatorKeyTarget] a new instance of InvalidDiscriminatorKeyTarget
  #
  # source://mongoid//lib/mongoid/errors/invalid_discriminator_key_target.rb#15
  def initialize(class_name, superclass); end
end

# This error is raised when trying to use the setter for a field that starts
# with a dollar sign ($) or contains a dot/period (.).
#
# source://mongoid//lib/mongoid/errors/invalid_dot_dollar_assignment.rb#9
class Mongoid::Errors::InvalidDotDollarAssignment < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @param attr [Class] The attribute attempted to be written.
  # @param klass [Class] The class of the document.
  # @return [InvalidDotDollarAssignment] a new instance of InvalidDotDollarAssignment
  #
  # source://mongoid//lib/mongoid/errors/invalid_dot_dollar_assignment.rb#17
  def initialize(klass, attr); end
end

# Raised when invalid field-level operator is passed to the $elemMatch
# embedded matcher.
#
# source://mongoid//lib/mongoid/errors/invalid_elem_match_operator.rb#9
class Mongoid::Errors::InvalidElemMatchOperator < ::Mongoid::Errors::InvalidQuery
  # Creates the exception.
  #
  # @api private
  # @param operator [String] The operator that was used.
  # @return [InvalidElemMatchOperator] a new instance of InvalidElemMatchOperator
  #
  # source://mongoid//lib/mongoid/errors/invalid_elem_match_operator.rb#21
  def initialize(operator); end

  # @return [String] The operator that was used.
  #
  # source://mongoid//lib/mongoid/errors/invalid_elem_match_operator.rb#30
  def operator; end
end

# @api private
#
# source://mongoid//lib/mongoid/errors/invalid_elem_match_operator.rb#12
Mongoid::Errors::InvalidElemMatchOperator::VALID_OPERATORS = T.let(T.unsafe(nil), Array)

# This error is raised when trying to call estimated_count
# on a filtered criteria.
#
# source://mongoid//lib/mongoid/errors/invalid_estimated_count_criteria.rb#9
class Mongoid::Errors::InvalidEstimatedCountCriteria < ::Mongoid::Errors::MongoidError
  # Creates the exception.
  #
  # @api private
  # @param class_name [String] The name of the criteria
  #   class used to call estimated count.
  # @return [InvalidEstimatedCountCriteria] a new instance of InvalidEstimatedCountCriteria
  #
  # source://mongoid//lib/mongoid/errors/invalid_estimated_count_criteria.rb#17
  def initialize(class_name); end
end

# This error is raised when trying to call estimated_count
# on a model with a default scope.
#
# source://mongoid//lib/mongoid/errors/invalid_estimated_count_scoping.rb#9
class Mongoid::Errors::InvalidEstimatedCountScoping < ::Mongoid::Errors::MongoidError
  # Creates the exception.
  #
  # @api private
  # @param class_name [String] The name of the criteria
  #   class used to call estimated count.
  # @return [InvalidEstimatedCountScoping] a new instance of InvalidEstimatedCountScoping
  #
  # source://mongoid//lib/mongoid/errors/invalid_estimated_count_scoping.rb#17
  def initialize(class_name); end
end

# Raised when invalid expression-level operator is passed to an
# embedded matcher.
#
# source://mongoid//lib/mongoid/errors/invalid_expression_operator.rb#9
class Mongoid::Errors::InvalidExpressionOperator < ::Mongoid::Errors::InvalidQuery
  # Creates the exception.
  #
  # @api private
  # @param operator [String] The operator that was used.
  # @return [InvalidExpressionOperator] a new instance of InvalidExpressionOperator
  #
  # source://mongoid//lib/mongoid/errors/invalid_expression_operator.rb#16
  def initialize(operator); end

  # @return [String] The operator that was used.
  #
  # source://mongoid//lib/mongoid/errors/invalid_expression_operator.rb#25
  def operator; end
end

# This error is raised when trying to create a field that conflicts with
# an already defined method.
#
# source://mongoid//lib/mongoid/errors/invalid_field.rb#9
class Mongoid::Errors::InvalidField < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @example Create the error.
  #   InvalidField.new(person, :crazy_method_name)
  # @param field [Symbol] The field name.
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [InvalidField] a new instance of InvalidField
  #
  # source://mongoid//lib/mongoid/errors/invalid_field.rb#21
  def initialize(klass, field, name); end

  private

  # Get the location of the method.
  #
  # @example Get the location of the method on the filesystem.
  #   error.location(Person, :crazy_method_name)
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [Array<String, Integer>] The location of the method.
  #
  # source://mongoid//lib/mongoid/errors/invalid_field.rb#60
  def location(klass, name); end

  # Get the queryable of the method.
  #
  # @example Get the originating class or module.
  #   error.queryable(Person, :crazy_method_name)
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [Class | Module] The originating class or module.
  #
  # source://mongoid//lib/mongoid/errors/invalid_field.rb#47
  def origin(klass, name); end
end

# Raised when invalid field-level operator is passed to an
# embedded matcher.
#
# source://mongoid//lib/mongoid/errors/invalid_field_operator.rb#9
class Mongoid::Errors::InvalidFieldOperator < ::Mongoid::Errors::InvalidQuery
  # Creates the exception.
  #
  # @api private
  # @param operator [String] The operator that was used.
  # @return [InvalidFieldOperator] a new instance of InvalidFieldOperator
  #
  # source://mongoid//lib/mongoid/errors/invalid_field_operator.rb#21
  def initialize(operator); end

  # @return [String] The operator that was used.
  #
  # source://mongoid//lib/mongoid/errors/invalid_field_operator.rb#30
  def operator; end
end

# @api private
#
# source://mongoid//lib/mongoid/errors/invalid_field_operator.rb#12
Mongoid::Errors::InvalidFieldOperator::VALID_OPERATORS = T.let(T.unsafe(nil), Array)

# This error is raised when trying to create a field that has an invalid
# option.
#
# source://mongoid//lib/mongoid/errors/invalid_field_option.rb#9
class Mongoid::Errors::InvalidFieldOption < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   InvalidFieldOption.new(Model, :name, :localized, [ :localize ])
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @param option [Symbol] The option name.
  # @param valid [Array<Symbol>] All the valid options.
  # @return [InvalidFieldOption] a new instance of InvalidFieldOption
  #
  # source://mongoid//lib/mongoid/errors/invalid_field_option.rb#20
  def initialize(klass, name, option, valid); end
end

# This error is raised when trying to define a field using a :type option value
# that is not present in the field type mapping.
#
# source://mongoid//lib/mongoid/errors/invalid_field_type.rb#9
class Mongoid::Errors::InvalidFieldType < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Instantiate the error.
  #   InvalidFieldType.new('Person', 'first_name', 'stringgy')
  # @param field [String] The field on which the invalid type is used.
  # @param klass [String] The model class.
  # @param type [Symbol | String] The value of the field :type option.
  # @return [InvalidFieldType] a new instance of InvalidFieldType
  #
  # source://mongoid//lib/mongoid/errors/invalid_field_type.rb#19
  def initialize(klass, field, type); end
end

# Raised when invalid arguments are passed to #find.
#
# source://mongoid//lib/mongoid/errors/invalid_find.rb#8
class Mongoid::Errors::InvalidFind < ::Mongoid::Errors::MongoidError
  # Create the new invalid find error.
  #
  # @example Create the error.
  #   InvalidFind.new
  # @return [InvalidFind] a new instance of InvalidFind
  #
  # source://mongoid//lib/mongoid/errors/invalid_find.rb#14
  def initialize; end
end

# This error is raised when a bad global executor concurrency option is attempted
# to be set.
#
# source://mongoid//lib/mongoid/errors/invalid_global_executor_concurrency.rb#9
class Mongoid::Errors::InvalidGlobalExecutorConcurrency < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @return [InvalidGlobalExecutorConcurrency] a new instance of InvalidGlobalExecutorConcurrency
  #
  # source://mongoid//lib/mongoid/errors/invalid_global_executor_concurrency.rb#14
  def initialize; end
end

# This error is raised when an invalid value is passed to an eager
# loading query.
#
# source://mongoid//lib/mongoid/errors/invalid_includes.rb#9
class Mongoid::Errors::InvalidIncludes < ::Mongoid::Errors::MongoidError
  # Initialize the error.
  #
  # @example Initialize the error.
  #   InvalidIncludes.new(Band, [ :members ])
  # @param args [Array<Object>] The arguments passed to the includes.
  # @param klass [Class] The model class.
  # @return [InvalidIncludes] a new instance of InvalidIncludes
  #
  # source://mongoid//lib/mongoid/errors/invalid_includes.rb#18
  def initialize(klass, args); end
end

# Raised when an invalid index is defined.
#
# source://mongoid//lib/mongoid/errors/invalid_index.rb#8
class Mongoid::Errors::InvalidIndex < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   InvalidIndex.new(Band, name: 1)
  # @param klass [Class] The model class.
  # @param options [Hash] The invalid options.
  # @param spec [Hash] The invalid specification.
  # @return [InvalidIndex] a new instance of InvalidIndex
  #
  # source://mongoid//lib/mongoid/errors/invalid_index.rb#18
  def initialize(klass, spec, options); end
end

# Raised when invalid options are passed to an association macro.
#
# source://mongoid//lib/mongoid/errors/invalid_options.rb#8
class Mongoid::Errors::InvalidOptions < ::Mongoid::Errors::MongoidError
  # Instantiate the options error.
  #
  # @example Create the error.
  #   InvalidOptions.new(:name, :polymorphic, [ :as ])
  # @param invalid [Symbol] The invalid option.
  # @param name [Symbol] The name of the association.
  # @param valid [Array<Symbol>] The allowed options.
  # @return [InvalidOptions] a new instance of InvalidOptions
  #
  # source://mongoid//lib/mongoid/errors/invalid_options.rb#18
  def initialize(name, invalid, valid); end
end

# Used when attempting to get embedded paths with incorrect root path set.
#
# source://mongoid//lib/mongoid/errors/invalid_path.rb#8
class Mongoid::Errors::InvalidPath < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   InvalidPath.new(Address)
  # @param klass [Class] The document class.
  # @return [InvalidPath] a new instance of InvalidPath
  #
  # source://mongoid//lib/mongoid/errors/invalid_path.rb#16
  def initialize(klass); end
end

# Raised when invalid options are used to create a persistence context.
#
# source://mongoid//lib/mongoid/errors/invalid_persistence_option.rb#8
class Mongoid::Errors::InvalidPersistenceOption < ::Mongoid::Errors::MongoidError
  # Instantiate the persistence context option error.
  #
  # @example Create the error.
  #   InvalidPersistenceOption.new(:invalid_option, [ :connect_timeout, :database ])
  # @param invalid [Symbol] The invalid option.
  # @param valid [Array<Symbol>] The allowed options.
  # @return [InvalidPersistenceOption] a new instance of InvalidPersistenceOption
  #
  # source://mongoid//lib/mongoid/errors/invalid_persistence_option.rb#17
  def initialize(invalid, valid); end
end

# Raised when invalid query is passed to an embedded matcher, or an
# invalid query fragment is passed to the query builder (Criteria object).
#
# source://mongoid//lib/mongoid/errors/invalid_query.rb#9
class Mongoid::Errors::InvalidQuery < ::Mongoid::Errors::MongoidError
  # Create the new invalid query error.
  #
  # @api private
  # @return [InvalidQuery] a new instance of InvalidQuery
  #
  # source://mongoid//lib/mongoid/errors/invalid_query.rb#14
  def initialize(msg); end

  class << self
    # Stringifies the argument using #inspect and truncates the result to
    # about 100 characters.
    #
    # @api private
    # @param expr [Object] An expression to stringify and truncate.
    #
    # source://mongoid//lib/mongoid/errors/invalid_query.rb#24
    def truncate_expr(expr); end
  end
end

# This error is raised when a bad async query executor option is attempted
# to be set.
#
# source://mongoid//lib/mongoid/errors/invalid_async_query_executor.rb#9
class Mongoid::Errors::InvalidQueryExecutor < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @api private
  # @param executor [Symbol | String] The attempted async query executor.
  # @return [InvalidQueryExecutor] a new instance of InvalidQueryExecutor
  #
  # source://mongoid//lib/mongoid/errors/invalid_async_query_executor.rb#16
  def initialize(executor); end
end

# This error is raised when trying to create an association that conflicts with
# an already defined method.
#
# source://mongoid//lib/mongoid/errors/invalid_relation.rb#9
class Mongoid::Errors::InvalidRelation < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   InvalidRelation.new(person, :crazy_relation_name)
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [InvalidRelation] a new instance of InvalidRelation
  #
  # source://mongoid//lib/mongoid/errors/invalid_relation.rb#18
  def initialize(klass, name); end

  private

  # Get the location of the association definition.
  #
  # @example Get the location of the method on the filesystem.
  #   error.location(Person, :crazy_method_name)
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [Array<String, Integer>] The location of the method.
  #
  # source://mongoid//lib/mongoid/errors/invalid_relation.rb#56
  def location(klass, name); end

  # Get the queryable of the method.
  #
  # @example Get the originating class or module.
  #   error.queryable(Person, :crazy_method_name)
  # @param klass [Class] The document class.
  # @param name [Symbol] The method name.
  # @return [Class | Module] The originating class or module.
  #
  # source://mongoid//lib/mongoid/errors/invalid_relation.rb#43
  def origin(klass, name); end
end

# Raised when an option provided for an association is invalid.
#
# source://mongoid//lib/mongoid/errors/invalid_relation_option.rb#8
class Mongoid::Errors::InvalidRelationOption < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   InvalidRelationOption.new(Person, invalid_option: 'make_me_a_sandwich')
  # @param klass [Class] The model class.
  # @param name [String | Symbol] The association name.
  # @param option [Symbol] The invalid option.
  # @param valid_options [Array<Symbol>] The valid option.
  # @return [InvalidRelationOption] a new instance of InvalidRelationOption
  #
  # source://mongoid//lib/mongoid/errors/invalid_relation_option.rb#19
  def initialize(klass, name, option, valid_options); end
end

# This error is raised when defining a scope of an invalid type.
#
# source://mongoid//lib/mongoid/errors/invalid_scope.rb#8
class Mongoid::Errors::InvalidScope < ::Mongoid::Errors::MongoidError
  # Create the error.
  #
  # @example Create the error.
  #   InvalidScope.new(Band, {})
  # @param klass [Class] The model class.
  # @param value [Object] The attempted scope value.
  # @return [InvalidScope] a new instance of InvalidScope
  #
  # source://mongoid//lib/mongoid/errors/invalid_scope.rb#17
  def initialize(klass, value); end
end

# This error is raised when a session is attempted to be used with a model whose client already
# has an opened session.
#
# source://mongoid//lib/mongoid/errors/invalid_session_nesting.rb#9
class Mongoid::Errors::InvalidSessionNesting < ::Mongoid::Errors::MongoidError
  # Create the error.
  #
  # @return [InvalidSessionNesting] a new instance of InvalidSessionNesting
  #
  # source://mongoid//lib/mongoid/errors/invalid_session_nesting.rb#12
  def initialize; end
end

# Raised when trying to set a polymorphic "references in" association to a
# model with multiple "references many/one" associations pointing to that
# first model.
#
# @example Invalid setting of a polymorphic association.
#   class Face
#   include Mongoid::Document
#
#   has_one :left_eye, class_name: "Eye", as: :eyeable
#   has_one :right_eye, class_name: "Eye", as: :eyeable
#   end
#
#   class Eye
#   include Mongoid::Document
#
#   belongs_to :eyeable, polymorphic: true
#   end
#
#   eye = Eye.new
#   face = Face.new
#   eye.eyeable = face # Raises error
#
# source://mongoid//lib/mongoid/errors/invalid_set_polymorphic_relation.rb#28
class Mongoid::Errors::InvalidSetPolymorphicRelation < ::Mongoid::Errors::MongoidError
  # Create the new invalid set polymorphic association error.
  #
  # @example Create the error.
  #   InvalidSetPolymorphicRelation.new
  # @return [InvalidSetPolymorphicRelation] a new instance of InvalidSetPolymorphicRelation
  #
  # source://mongoid//lib/mongoid/errors/invalid_set_polymorphic_relation.rb#34
  def initialize(name, klass, other_klass); end
end

# Raised when options provided to :store_in are invalid.
#
# source://mongoid//lib/mongoid/errors/invalid_storage_options.rb#8
class Mongoid::Errors::InvalidStorageOptions < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   InvalidStorageOptions.new(Person, invalid_option: 'name')
  # @param klass [Class] The model class.
  # @param options [Hash | String | Symbol] The provided options.
  # @return [InvalidStorageOptions] a new instance of InvalidStorageOptions
  #
  # source://mongoid//lib/mongoid/errors/invalid_storage_options.rb#17
  def initialize(klass, options); end
end

# This exception is raised when a bad value is attempted to be converted to
# a date or time.
#
# source://mongoid//lib/mongoid/errors/invalid_time.rb#9
class Mongoid::Errors::InvalidTime < ::Mongoid::Errors::MongoidError
  # Create the new invalid date error.
  #
  # @example Create the new invalid date error.
  #   InvalidTime.new("this is not a time")
  # @param value [Object] The value that was attempted.
  # @return [InvalidTime] a new instance of InvalidTime
  #
  # source://mongoid//lib/mongoid/errors/invalid_time.rb#17
  def initialize(value); end
end

# This error is raised when a transaction is attempted to be used with a model whose client already
# has an opened transaction.
#
# source://mongoid//lib/mongoid/errors/invalid_transaction_nesting.rb#9
class Mongoid::Errors::InvalidTransactionNesting < ::Mongoid::Errors::MongoidError
  # Create the error.
  #
  # @return [InvalidTransactionNesting] a new instance of InvalidTransactionNesting
  #
  # source://mongoid//lib/mongoid/errors/invalid_transaction_nesting.rb#12
  def initialize; end
end

# Raised when no inverse_of definition can be found when needed.
#
# source://mongoid//lib/mongoid/errors/inverse_not_found.rb#8
class Mongoid::Errors::InverseNotFound < ::Mongoid::Errors::MongoidError
  # Create then new error.
  #
  # @example Create the new error.
  #   InverseNotFound.new(Town, :citizens, Person, :town_id)
  # @param base [Class] The base class.
  # @param inverse [Symbol] The attempted inverse key.
  # @param klass [Class] The child class.
  # @param name [Symbol] The name of the association.
  # @return [InverseNotFound] a new instance of InverseNotFound
  #
  # source://mongoid//lib/mongoid/errors/inverse_not_found.rb#19
  def initialize(base, name, klass, inverse); end
end

# This error is raised when a client configuration contains both a uri and
# other standard options.
#
# source://mongoid//lib/mongoid/errors/mixed_client_configuration.rb#9
class Mongoid::Errors::MixedClientConfiguration < ::Mongoid::Errors::MongoidError
  # Initialize the error.
  #
  # @example Initialize the error.
  #   MixedClientConfiguration.new(:name, {})
  # @param config [Hash] The configuration options.
  # @param name [Symbol] The name of the client config.
  # @return [MixedClientConfiguration] a new instance of MixedClientConfiguration
  #
  # source://mongoid//lib/mongoid/errors/mixed_client_configuration.rb#18
  def initialize(name, config); end
end

# This error is raised when trying to reference an embedded document from
# a document in another collection that is not its parent.
#
# @example An illegal reference to an embedded document.
#   class Post
#   include Mongoid::Document
#   references_many :addresses
#   end
#
#   class Address
#   include Mongoid::Document
#   embedded_in :person
#   referenced_in :post
#   end
#
# source://mongoid//lib/mongoid/errors/mixed_relations.rb#21
class Mongoid::Errors::MixedRelations < ::Mongoid::Errors::MongoidError
  # @return [MixedRelations] a new instance of MixedRelations
  #
  # source://mongoid//lib/mongoid/errors/mixed_relations.rb#22
  def initialize(root_klass, embedded_klass); end
end

# Default parent Mongoid error for all custom errors. This handles the base
# key for the translations and provides the convenience method for
# translating the messages.
#
# source://mongoid//lib/mongoid/errors/mongoid_error.rb#10
class Mongoid::Errors::MongoidError < ::StandardError
  # Compose the message.
  #
  # @example Create the message
  #   error.compose_message
  # @return [String] The composed message.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#22
  def compose_message(key, attributes = T.unsafe(nil)); end

  # Returns the value of attribute problem.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#12
  def problem; end

  # Returns the value of attribute resolution.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#12
  def resolution; end

  # Returns the value of attribute summary.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#12
  def summary; end

  private

  # Given the key of the specific error and the options hash, translate the
  # message.
  #
  # @example Translate the message.
  #   error.translate("errors", :key => value)
  # @param key [String] The key of the error in the locales.
  # @param options [Hash] The objects to pass to create the message.
  # @return [String] A localized error message string.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#48
  def translate(key, options); end

  # Create the problem.
  #
  # @example Create the problem.
  #   error.problem("error", {})
  # @param attributes [Hash] The attributes to interpolate.
  # @param key [String | Symbol] The error key.
  # @return [String] The problem.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#61
  def translate_problem(key, attributes); end

  # Create the resolution.
  #
  # @example Create the resolution.
  #   error.resolution("error", {})
  # @param attributes [Hash] The attributes to interpolate.
  # @param key [String | Symbol] The error key.
  # @return [String] The resolution.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#87
  def translate_resolution(key, attributes); end

  # Create the summary.
  #
  # @example Create the summary.
  #   error.summary("error", {})
  # @param attributes [Hash] The attributes to interpolate.
  # @param key [String | Symbol] The error key.
  # @return [String] The summary.
  #
  # source://mongoid//lib/mongoid/errors/mongoid_error.rb#74
  def translate_summary(key, attributes); end
end

# source://mongoid//lib/mongoid/errors/mongoid_error.rb#14
Mongoid::Errors::MongoidError::BASE_KEY = T.let(T.unsafe(nil), String)

# This error is raised when metadata could not be found when defining
# nested attributes, or the name was incorrect.
#
# source://mongoid//lib/mongoid/errors/nested_attributes_metadata_not_found.rb#9
class Mongoid::Errors::NestedAttributesMetadataNotFound < ::Mongoid::Errors::MongoidError
  # Create the new metadata error.
  #
  # @example Create the new metadata error.
  #   NestedAttributesMetadataNotFound.new(klass, name)
  # @param klass [Class] The class of the document.
  # @param name [Symbol | String] The name of the association
  # @return [NestedAttributesMetadataNotFound] a new instance of NestedAttributesMetadataNotFound
  #
  # source://mongoid//lib/mongoid/errors/nested_attributes_metadata_not_found.rb#18
  def initialize(klass, name); end
end

# This error is raised when attempting to create a new client that does
# not have a named configuration.
#
# source://mongoid//lib/mongoid/errors/no_client_config.rb#9
class Mongoid::Errors::NoClientConfig < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   NoClientConfig.new(:analytics)
  # @param name [String | Symbol] The name of the client.
  # @return [NoClientConfig] a new instance of NoClientConfig
  #
  # source://mongoid//lib/mongoid/errors/no_client_config.rb#17
  def initialize(name); end
end

# This error is raised when a client is configured without a database.
#
# source://mongoid//lib/mongoid/errors/no_client_database.rb#8
class Mongoid::Errors::NoClientDatabase < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   NoClientDatabase.new(:default, {}})
  # @param config [Hash] The hash configuration options.
  # @param name [Symbol | String] The db config key.
  # @return [NoClientDatabase] a new instance of NoClientDatabase
  #
  # source://mongoid//lib/mongoid/errors/no_client_database.rb#17
  def initialize(name, config); end
end

# This error is raised when a client is configured without hosts.
#
# source://mongoid//lib/mongoid/errors/no_client_hosts.rb#8
class Mongoid::Errors::NoClientHosts < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   NoClientHosts.new(:default, {}})
  # @param config [Hash] The hash configuration options.
  # @param name [Symbol | String] The db config key.
  # @return [NoClientHosts] a new instance of NoClientHosts
  #
  # source://mongoid//lib/mongoid/errors/no_client_hosts.rb#17
  def initialize(name, config); end
end

# This error is raised when no clients exists in the database
# configuration.
#
# source://mongoid//lib/mongoid/errors/no_clients_config.rb#9
class Mongoid::Errors::NoClientsConfig < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   NoClientsConfig.new
  # @return [NoClientsConfig] a new instance of NoClientsConfig
  #
  # source://mongoid//lib/mongoid/errors/no_clients_config.rb#15
  def initialize; end
end

# This error is raised when a default client is not defined.
#
# source://mongoid//lib/mongoid/errors/no_default_client.rb#8
class Mongoid::Errors::NoDefaultClient < ::Mongoid::Errors::MongoidError
  # Create the new error with the defined client names.
  #
  # @example Create the new error.
  #   NoDefaultClient.new([ :analytics ])
  # @param keys [Array<Symbol>] The defined clients.
  # @return [NoDefaultClient] a new instance of NoDefaultClient
  #
  # source://mongoid//lib/mongoid/errors/no_default_client.rb#16
  def initialize(keys); end
end

# Raised when trying to load configuration with no RACK_ENV set
#
# source://mongoid//lib/mongoid/errors/no_environment.rb#8
class Mongoid::Errors::NoEnvironment < ::Mongoid::Errors::MongoidError
  # Create the new no environment error.
  #
  # @example Create the new no environment error.
  #   NoEnvironment.new
  # @return [NoEnvironment] a new instance of NoEnvironment
  #
  # source://mongoid//lib/mongoid/errors/no_environment.rb#14
  def initialize; end
end

# Raised when executing a map/reduce without specifying the output
# location.
#
# source://mongoid//lib/mongoid/errors/no_map_reduce_output.rb#9
class Mongoid::Errors::NoMapReduceOutput < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   NoMapReduceOutput.new({ map: "" })
  # @param command [Hash] The map/reduce command.
  # @return [NoMapReduceOutput] a new instance of NoMapReduceOutput
  #
  # source://mongoid//lib/mongoid/errors/no_map_reduce_output.rb#17
  def initialize(command); end
end

# Used when trying to persist data when metadata has not been set.
#
# source://mongoid//lib/mongoid/errors/no_metadata.rb#8
class Mongoid::Errors::NoMetadata < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the error.
  #   NoMetadata.new(Address)
  # @param klass [Class] The document class.
  # @return [NoMetadata] a new instance of NoMetadata
  #
  # source://mongoid//lib/mongoid/errors/no_metadata.rb#16
  def initialize(klass); end
end

# This error is raised when trying to persist an embedded document
# when there is no parent set.
#
# source://mongoid//lib/mongoid/errors/no_parent.rb#9
class Mongoid::Errors::NoParent < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   NoParent.new(klass)
  # @param klass [Class] The class of the embedded document.
  # @return [NoParent] a new instance of NoParent
  #
  # source://mongoid//lib/mongoid/errors/no_parent.rb#17
  def initialize(klass); end
end

# This error is raised when attempting the change the value of a readonly
# attribute after the document has been persisted.
#
# source://mongoid//lib/mongoid/errors/readonly_attribute.rb#9
class Mongoid::Errors::ReadonlyAttribute < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Create the new error.
  #   ReadonlyAttribute.new(:title, "mr")
  # @param name [Symbol | String] The name of the attribute.
  # @param value [Object] The attempted set value.
  # @return [ReadonlyAttribute] a new instance of ReadonlyAttribute
  #
  # source://mongoid//lib/mongoid/errors/readonly_attribute.rb#18
  def initialize(name, value); end
end

# Raised when attempting to persist a document that was loaded from the
# database with partial fields.
#
# source://mongoid//lib/mongoid/errors/readonly_document.rb#9
class Mongoid::Errors::ReadonlyDocument < ::Mongoid::Errors::MongoidError
  # Instantiate the exception.
  #
  # @example Create the error.
  #   ReadonlyDocument.new(Band)
  # @param klass [Class] The document class.
  # @return [ReadonlyDocument] a new instance of ReadonlyDocument
  #
  # source://mongoid//lib/mongoid/errors/readonly_document.rb#17
  def initialize(klass); end
end

# This error should be raised to deliberately rollback a transaction without
# passing on an exception.
# Normally, raising an exception inside a Mongoid transaction causes rolling
# the MongoDB transaction back, and the exception is passed on.
# If Mongoid::Error::Rollback exception is raised, then the MongoDB
# transaction will be rolled back, without passing on the exception.
#
# source://mongoid//lib/mongoid/errors/rollback.rb#13
class Mongoid::Errors::Rollback < ::Mongoid::Errors::MongoidError; end

# This error is raised when trying to create a scope with an name already
# taken by another scope or method
#
# @example Create the error.
#   ScopeOverwrite.new(Person,'teenies')
#
# source://mongoid//lib/mongoid/errors/scope_overwrite.rb#12
class Mongoid::Errors::ScopeOverwrite < ::Mongoid::Errors::MongoidError
  # @return [ScopeOverwrite] a new instance of ScopeOverwrite
  #
  # source://mongoid//lib/mongoid/errors/scope_overwrite.rb#13
  def initialize(model_name, scope_name); end
end

# This error is raised when a session is attempted to be used with a model whose client cannot use it since
# the mongodb deployment doesn't support sessions.
#
# source://mongoid//lib/mongoid/errors/sessions_not_supported.rb#9
class Mongoid::Errors::SessionsNotSupported < ::Mongoid::Errors::MongoidError
  # Create the error.
  #
  # @return [SessionsNotSupported] a new instance of SessionsNotSupported
  #
  # source://mongoid//lib/mongoid/errors/sessions_not_supported.rb#12
  def initialize; end
end

# This error is raised when trying to create set nested documents above the
# specified :limit
#
# @example Create the error.
#   TooManyNestedAttributeRecords.new('association', limit)
#
# source://mongoid//lib/mongoid/errors/too_many_nested_attribute_records.rb#12
class Mongoid::Errors::TooManyNestedAttributeRecords < ::Mongoid::Errors::MongoidError
  # @return [TooManyNestedAttributeRecords] a new instance of TooManyNestedAttributeRecords
  #
  # source://mongoid//lib/mongoid/errors/too_many_nested_attribute_records.rb#13
  def initialize(association, limit); end
end

# This error is raised when a transaction failed because
# of an unexpected error.
#
# source://mongoid//lib/mongoid/errors/transaction_error.rb#9
class Mongoid::Errors::TransactionError < ::Mongoid::Errors::MongoidError
  # Creates the exception.
  #
  # @param error [StandardError] Error that caused the
  #   transaction failure.
  # @return [TransactionError] a new instance of TransactionError
  #
  # source://mongoid//lib/mongoid/errors/transaction_error.rb#15
  def initialize(error); end
end

# This error is raised when a transaction is attempted to be used with a model whose client cannot use it since
# the mongodb deployment doesn't support transactions.
#
# source://mongoid//lib/mongoid/errors/transactions_not_supported.rb#9
class Mongoid::Errors::TransactionsNotSupported < ::Mongoid::Errors::MongoidError
  # Create the error.
  #
  # @return [TransactionsNotSupported] a new instance of TransactionsNotSupported
  #
  # source://mongoid//lib/mongoid/errors/transactions_not_supported.rb#12
  def initialize; end
end

# This error is raised when trying to set a value in Mongoid that is not
# already set with dynamic attributes or the field is not defined.
#
# source://mongoid//lib/mongoid/errors/unknown_attribute.rb#9
class Mongoid::Errors::UnknownAttribute < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Instantiate the error.
  #   UnknownAttribute.new(Person, "gender")
  # @param klass [Class] The model class.
  # @param name [String | Symbol] The name of the attribute.
  # @return [UnknownAttribute] a new instance of UnknownAttribute
  #
  # source://mongoid//lib/mongoid/errors/unknown_attribute.rb#18
  def initialize(klass, name); end
end

# This error is raised when trying to instantiate a model object from the value in
# the '_type' field of a document and the class doesn't exist.
#
# source://mongoid//lib/mongoid/errors/unknown_model.rb#9
class Mongoid::Errors::UnknownModel < ::Mongoid::Errors::MongoidError
  # Create the new error.
  #
  # @example Instantiate the error.
  #   UnknownModel.new('InvalidClass', "invalid_class")
  # @param klass [String] The model class.
  # @param value [String] The value used to determine the (invalid) class.
  # @return [UnknownModel] a new instance of UnknownModel
  #
  # source://mongoid//lib/mongoid/errors/unknown_model.rb#18
  def initialize(klass, value); end
end

# Raised when a polymorphic association is queried, but the type of the
# association cannot be resolved. This usually happens when the data in
# the database references a type that no longer exists.
#
# For example, consider the following model:
#
#   class Manager
#     include Mongoid::Document
#     belongs_to :unit, polymorphic: true
#   end
#
# Imagine there is a document in the `managers` collection that looks
# something like this:
#
#   { _id: ..., unit_id: ..., unit_type: 'Department::Engineering' }
#
# If, at some point in your refactoring, you rename the `Department::Engineering`
# model to something else, Mongoid will no longer be able to resolve the
# type of this association, and asking for `manager.unit` will raise this
# exception.
#
# To fix this exception, you can add an alias to the model class so that it
# can still be found, even after renaming it:
#
#   module Engineering
#     class Department
#       include Mongoid::Document
#
#       identify_as 'Department::Engineering'
#
#       # ...
#     end
#   end
#
# Better practice would be to use unique strings instead of class names to
# identify these polymorphic types in the database (e.g. 'dept' instead of
# 'Department::Engineering').
#
# source://mongoid//lib/mongoid/errors/unrecognized_model_alias.rb#42
class Mongoid::Errors::UnrecognizedModelAlias < ::Mongoid::Errors::MongoidError
  # @return [UnrecognizedModelAlias] a new instance of UnrecognizedModelAlias
  #
  # source://mongoid//lib/mongoid/errors/unrecognized_model_alias.rb#43
  def initialize(model_alias); end
end

# Raised when a model resolver is referenced, but not registered.
#
#   class Manager
#     include Mongoid::Document
#     belongs_to :unit, polymorphic: :org
#   end
#
# If `:org` has not previously been registered as a model resolver,
# Mongoid will raise UnrecognizedResolver when it tries to resolve
# a manager's unit.
#
# source://mongoid//lib/mongoid/errors/unrecognized_resolver.rb#15
class Mongoid::Errors::UnrecognizedResolver < ::Mongoid::Errors::MongoidError
  # @return [UnrecognizedResolver] a new instance of UnrecognizedResolver
  #
  # source://mongoid//lib/mongoid/errors/unrecognized_resolver.rb#16
  def initialize(resolver); end
end

# Raised when Mongoid tries to query the identifier to use for a given
# class in a polymorphic association, but the class has not previously
# been registered by resolver that was used for the query.
#
# Here's an exammple:
#
#   class Department
#     include Mongoid::Document
#     has_many :managers, as: :unit
#   end
#
#   class Manager
#     include Mongoid::Document
#     belongs_to :unit, polymorphic: :org
#   end
#
# The Manager class is configured to use a custom resolver named `:org`
# when resolving the polymorphic `unit` association. However, the `Department`
# class is not registered with that resolver. When the program tries to
# associate a manager record with a department, it will not be able to find
# the required key in the `:org` resolver, and will fail with this exception.
#
# The solution is to make sure the `Department` class is properly registered
# with the `:org` resolver:
#
#   class Department
#     include Mongoid::Document
#     identify_as resolver: :org
#     has_many :managers, as: :unit
#   end
#
# source://mongoid//lib/mongoid/errors/unregistered_class.rb#35
class Mongoid::Errors::UnregisteredClass < ::Mongoid::Errors::MongoidError
  # @return [UnregisteredClass] a new instance of UnregisteredClass
  #
  # source://mongoid//lib/mongoid/errors/unregistered_class.rb#36
  def initialize(klass, resolver); end
end

# Raised when attempting to call create or create! through a
# references_many when the parent document has not been saved. This
# prevents the child from getting persisted and immediately being orphaned.
#
# source://mongoid//lib/mongoid/errors/unsaved_document.rb#10
class Mongoid::Errors::UnsavedDocument < ::Mongoid::Errors::MongoidError
  # @return [UnsavedDocument] a new instance of UnsavedDocument
  #
  # source://mongoid//lib/mongoid/errors/unsaved_document.rb#11
  def initialize(base, document); end
end

# Raised when Javascript criteria selector is passed for embedded document.
#
# source://mongoid//lib/mongoid/errors/unsupported_javascript.rb#8
class Mongoid::Errors::UnsupportedJavascript < ::Mongoid::Errors::MongoidError
  # Create the new error caused by using Javascript in embedded document criteria selector.
  #
  # @example Create the error.
  #   UnsupportedJavascriptSelector.new(Album, "this.name == '101'")
  # @param javascript [String] The javascript expression.
  # @param klass [Class] The embedded document class.
  # @return [UnsupportedJavascript] a new instance of UnsupportedJavascript
  #
  # source://mongoid//lib/mongoid/errors/unsupported_javascript.rb#17
  def initialize(klass, javascript); end
end

# Raised when a persistence method ending in ! fails validation. The message
# will contain the full error messages from the +Document+ in question.
#
# @example Create the error.
#   Validations.new(person.errors)
#
# source://mongoid//lib/mongoid/errors/validations.rb#12
class Mongoid::Errors::Validations < ::Mongoid::Errors::MongoidError
  # @return [Validations] a new instance of Validations
  #
  # source://mongoid//lib/mongoid/errors/validations.rb#16
  def initialize(document); end

  # Returns the value of attribute document.
  #
  # source://mongoid//lib/mongoid/errors/validations.rb#13
  def document; end

  # Returns the value of attribute document.
  #
  # source://mongoid//lib/mongoid/errors/validations.rb#14
  def record; end
end

# Contains behavior specific to evolving for queryable queries.
#
# source://mongoid//lib/mongoid/evolvable.rb#7
module Mongoid::Evolvable
  # Evolve the document into an object id.
  #
  # @example Evolve the document.
  #   document.__evolve_object_id__
  # @return [Object] The document's id.
  #
  # source://mongoid//lib/mongoid/evolvable.rb#15
  def __evolve_object_id__; end
end

# source://mongoid//lib/mongoid/extensions/array.rb#5
module Mongoid::Extensions; end

# Adds type-casting behavior to Array class.
#
# source://mongoid//lib/mongoid/extensions/array.rb#7
module Mongoid::Extensions::Array
  # Evolve the array into an array of object ids.
  #
  # @example Evolve the array to object ids.
  #   [ id ].__evolve_object_id__
  # @return [Array<BSON::ObjectId>] The converted array.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#15
  def __evolve_object_id__; end

  # Get the array of args as arguments for a find query.
  #
  # @deprecated
  # @example Get the array as find args.
  #   [ 1, 2, 3 ].__find_args__
  # @return [Array] The array of args.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#27
  def __find_args__(*args, **_arg1, &block); end

  # Mongoize the array into an array of object ids.
  #
  # @example Evolve the array to object ids.
  #   [ id ].__mongoize_object_id__
  # @return [Array<BSON::ObjectId>] The converted array.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#38
  def __mongoize_object_id__; end

  # Converts the array for storing as a time.
  #
  # @example Convert the array to a time.
  #   [ 2010, 1, 1 ].__mongoize_time__
  #   # => 2010-01-01 00:00:00 -0500
  # @note Returns a local time in the default time zone.
  # @return [Time | ActiveSupport::TimeWithZone] Local time in the
  #   configured default time zone corresponding to date/time components
  #   in this array.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#54
  def __mongoize_time__; end

  # Delete the first object in the array that is equal to the supplied
  # object and return it. This is much faster than performing a standard
  # delete for large arrays since it does not perform multiple deletes.
  #
  # @example Delete the first object.
  #   [ "1", "2", "1" ].delete_one("1")
  # @param object [Object] The object to delete.
  # @return [Object] The deleted object.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#91
  def delete_one(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   object.mongoize
  # @return [Array | nil] The object or nil.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#77
  def mongoize; end

  # Is the array a set of multiple arguments in a method?
  #
  # @deprecated
  # @example Is this multi args?
  #   [ 1, 2, 3 ].multi_arged?
  # @return [true | false] If the array is multi args.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#65
  def multi_arged?(*args, **_arg1, &block); end

  # Returns whether the object's size can be changed.
  #
  # @example Is the object resizable?
  #   object.resizable?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#102
  def resizable?; end
end

# source://mongoid//lib/mongoid/extensions/array.rb#106
module Mongoid::Extensions::Array::ClassMethods
  # Convert the provided object to a proper array of foreign keys.
  #
  # @deprecated
  # @example Mongoize the object.
  #   Array.__mongoize_fk__(constraint, object)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param object [Object] The object to convert.
  # @return [Array] The array of ids.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#118
  def __mongoize_fk__(*args, **_arg1, &block); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Array.mongoize([ 1, 2, 3 ])
  # @param object [Object] The object to mongoize.
  # @return [Array | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#136
  def mongoize(object); end

  # Returns whether the object's size can be changed.
  #
  # @example Is the object resizable?
  #   Array.resizable?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/extensions/array.rb#150
  def resizable?; end
end

# Adds type-casting behavior to BigDecimal class.
#
# source://mongoid//lib/mongoid/extensions/big_decimal.rb#7
module Mongoid::Extensions::BigDecimal
  mixes_in_class_methods ::Mongoid::Extensions::BigDecimal::ClassMethods

  # Convert the big decimal to an $inc-able value.
  #
  # @deprecated
  # @example Convert the big decimal.
  #   bd.__to_inc__
  # @return [Float] The big decimal as a float.
  #
  # source://mongoid//lib/mongoid/extensions/big_decimal.rb#24
  def __to_inc__(*args, **_arg1, &block); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   object.mongoize
  # @return [String | BSON::Decimal128 | nil] The object or nil.
  #
  # source://mongoid//lib/mongoid/extensions/big_decimal.rb#36
  def mongoize; end

  # Is the BigDecimal a number?
  #
  # @example Is the object a number?.
  #   object.numeric?
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/extensions/big_decimal.rb#46
  def numeric?; end

  class << self
    # Behavior to be invoked when the module is included.
    #
    # @api private
    # @param base [Module] the class or module doing the including
    #
    # source://mongoid//lib/mongoid/extensions/big_decimal.rb#13
    def included(base); end
  end
end

# source://mongoid//lib/mongoid/extensions/big_decimal.rb#50
module Mongoid::Extensions::BigDecimal::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @param object [Object] The object to demongoize.
  # @return [BigDecimal | nil] A BigDecimal derived from the object or nil.
  #
  # source://mongoid//lib/mongoid/extensions/big_decimal.rb#56
  def demongoize(object); end

  # Mongoize an object of any type to how it's stored in the db.
  #
  # @example Mongoize the object.
  #   BigDecimal.mongoize(123)
  # @param object [Object] The object to Mongoize
  # @return [String | BSON::Decimal128 | nil] A String or Decimal128
  #   representing the object or nil. String if Mongoid.map_big_decimal_to_decimal128
  #   is false, BSON::Decimal128 otherwise.
  #
  # source://mongoid//lib/mongoid/extensions/big_decimal.rb#75
  def mongoize(object); end
end

# Adds type-casting behavior to BSON::Binary class.
#
# source://mongoid//lib/mongoid/extensions/binary.rb#8
module Mongoid::Extensions::Binary
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   object.mongoize
  # @return [BSON::Binary | nil] The object.
  #
  # source://mongoid//lib/mongoid/extensions/binary.rb#17
  def mongoize; end
end

# source://mongoid//lib/mongoid/extensions/binary.rb#21
module Mongoid::Extensions::Binary::ClassMethods
  # Mongoize an object of any type to how it's stored in the db.
  #
  # @example Mongoize the object.
  #   BigDecimal.mongoize(123)
  # @param object [Object] The object to Mongoize
  # @return [BSON::Binary | nil] A Binary representing the object or nil.
  #
  # source://mongoid//lib/mongoid/extensions/binary.rb#38
  def demongoize(object); end

  # Mongoize an object of any type to how it's stored in the db.
  #
  # @example Mongoize the object.
  #   BigDecimal.mongoize(123)
  # @param object [Object] The object to Mongoize
  # @return [BSON::Binary | nil] A Binary representing the object or nil.
  #
  # source://mongoid//lib/mongoid/extensions/binary.rb#31
  def mongoize(object); end
end

# Adds type-casting behavior to Date class.
#
# source://mongoid//lib/mongoid/extensions/date.rb#8
module Mongoid::Extensions::Date
  # Convert the date into a time.
  #
  # @example Convert the date to a time.
  #   Date.new(2018, 11, 1).__mongoize_time__
  #   # => Thu, 01 Nov 2018 00:00:00 EDT -04:00
  # @return [Time | ActiveSupport::TimeWithZone] Local time in the
  #   configured default time zone corresponding to local midnight of
  #   this date.
  #
  # source://mongoid//lib/mongoid/extensions/date.rb#19
  def __mongoize_time__; end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   date.mongoize
  # @return [Time] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/date.rb#30
  def mongoize; end
end

# source://mongoid//lib/mongoid/extensions/date.rb#34
module Mongoid::Extensions::Date::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   Date.demongoize(object)
  # @param object [Time] The time from Mongo.
  # @return [Date | nil] The object as a date or nil.
  #
  # source://mongoid//lib/mongoid/extensions/date.rb#44
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Date.mongoize("2012-1-1")
  # @param object [Object] The object to mongoize.
  # @return [Time | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/date.rb#68
  def mongoize(object); end
end

# Adds type-casting behavior to Time class.
#
# source://mongoid//lib/mongoid/extensions/date_time.rb#8
module Mongoid::Extensions::DateTime
  # Mongoize the date time into a time.
  #
  # @example Mongoize the date time.
  #   date_time.__mongoize_time__
  # @return [Time | ActiveSupport::TimeWithZone] The mongoized time.
  #
  # source://mongoid//lib/mongoid/extensions/date_time.rb#16
  def __mongoize_time__; end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   date_time.mongoize
  # @return [Time] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/date_time.rb#27
  def mongoize; end
end

# source://mongoid//lib/mongoid/extensions/date_time.rb#31
module Mongoid::Extensions::DateTime::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   DateTime.demongoize(object)
  # @param object [Time] The time from Mongo.
  # @return [DateTime | nil] The object as a datetime or nil.
  #
  # source://mongoid//lib/mongoid/extensions/date_time.rb#41
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   DateTime.mongoize("2012-1-1")
  # @param object [Object] The object to convert.
  # @return [Time] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/date_time.rb#54
  def mongoize(object); end
end

# Adds type-casting behavior to BSON::Decimal128 class.
#
# source://mongoid//lib/mongoid/extensions/decimal128.rb#8
module Mongoid::Extensions::Decimal128
  # Evolve the decimal128.
  #
  # @example Evolve the decimal128.
  #   decimal128.__evolve_decimal128__
  # @return [BSON::Decimal128] self.
  #
  # source://mongoid//lib/mongoid/extensions/decimal128.rb#16
  def __evolve_decimal128__; end
end

# source://mongoid//lib/mongoid/extensions/decimal128.rb#20
module Mongoid::Extensions::Decimal128::ClassMethods
  # Evolve the object into a mongo-friendly value to query with.
  #
  # @example Evolve the object.
  #   Decimal128.evolve(dec)
  # @param object [Object] The object to evolve.
  # @return [BSON::Decimal128] The decimal128.
  #
  # source://mongoid//lib/mongoid/extensions/decimal128.rb#30
  def evolve(object); end
end

# Adds type-casting behavior to FalseClass.
#
# source://mongoid//lib/mongoid/extensions/false_class.rb#7
module Mongoid::Extensions::FalseClass
  # Get the value of the object as a mongo friendly sort value.
  #
  # @deprecated
  # @example Get the object as sort criteria.
  #   object.__sortable__
  # @return [Integer] 0.
  #
  # source://mongoid//lib/mongoid/extensions/false_class.rb#15
  def __sortable__(*args, **_arg1, &block); end

  # Is the passed value a boolean?
  #
  # @example Is the value a boolean type?
  #   false.is_a?(Boolean)
  # @param other [Class] The class to check.
  # @return [true | false] If the other is a boolean.
  #
  # source://mongoid//lib/mongoid/extensions/false_class.rb#28
  def is_a?(other); end
end

# Adds type-casting behavior to Float class.
#
# source://mongoid//lib/mongoid/extensions/float.rb#8
module Mongoid::Extensions::Float
  # Converts the float into a time as the number of seconds since the epoch.
  #
  # @example Convert the float into a time.
  #   1335532685.117847.__mongoize_time__
  # @return [Time | ActiveSupport::TimeWithZone] The time.
  #
  # source://mongoid//lib/mongoid/extensions/float.rb#16
  def __mongoize_time__; end

  # Is the float a number?
  #
  # @example Is the object a number?.
  #   object.numeric?
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/extensions/float.rb#26
  def numeric?; end
end

# source://mongoid//lib/mongoid/extensions/float.rb#30
module Mongoid::Extensions::Float::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Float.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [Float | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/float.rb#51
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Float.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [Float | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/float.rb#41
  def mongoize(object); end
end

# Adds type-casting behavior to Hash class.
#
# source://mongoid//lib/mongoid/extensions/hash.rb#8
module Mongoid::Extensions::Hash
  # Consolidate the key/values in the hash under an atomic $set.
  # DEPRECATED. This was never intended to be a public API and
  # the functionality will no longer be exposed once this method
  # is eventually removed.
  #
  # @deprecated
  # @example Consolidate the hash.
  #   { name: "Placebo" }.__consolidate__
  # @return [Hash] A new consolidated hash.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#45
  def __consolidate__(*args, **_arg1, &block); end

  # Evolves each value in the hash to an object id if it is convertable.
  #
  # @example Convert the hash values.
  #   { field: id }.__evolve_object_id__
  # @return [Hash] The converted hash.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#16
  def __evolve_object_id__; end

  # Mongoizes each value in the hash to an object id if it is convertable.
  #
  # @example Convert the hash values.
  #   { field: id }.__mongoize_object_id__
  # @return [Hash] The converted hash.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#26
  def __mongoize_object_id__; end

  # Deletes an id value from the hash.
  #
  # @deprecated
  # @example Delete an id value.
  #   {}.delete_id
  # @return [Object] The deleted value, or nil.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#57
  def delete_id(*args, **_arg1, &block); end

  # Get the id attribute from this hash, whether it's prefixed with an
  # underscore or is a symbol.
  #
  # @deprecated
  # @example Extract the id.
  #   { :_id => 1 }.extract_id
  # @return [Object] The value of the id.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#70
  def extract_id(*args, **_arg1, &block); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   object.mongoize
  # @return [Hash | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#82
  def mongoize; end

  # Can the size of this object change?
  #
  # @example Is the hash resizable?
  #   {}.resizable?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#92
  def resizable?; end

  # Convert this hash to a criteria. Will iterate over each keys in the
  # hash which must correspond to method on a criteria object. The hash
  # must also include a "klass" key.
  #
  # @deprecated
  # @example Convert the hash to a criteria.
  #   { klass: Band, where: { name: "Depeche Mode" }.to_criteria
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#105
  def to_criteria(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/extensions/hash.rb#112
module Mongoid::Extensions::Hash::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Hash.mongoize([ 1, 2, 3 ])
  # @param object [Object] The object to mongoize.
  # @return [Hash | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#123
  def mongoize(object); end

  # Can the size of this object change?
  #
  # @example Is the hash resizable?
  #   {}.resizable?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/extensions/hash.rb#139
  def resizable?; end
end

# Adds type-casting behavior to Integer class.
#
# source://mongoid//lib/mongoid/extensions/integer.rb#8
module Mongoid::Extensions::Integer
  # Converts the integer into a time as the number of seconds since the epoch.
  #
  # @example Convert the integer to a time.
  #   1335532685.__mongoize_time__
  # @return [Time | ActiveSupport::TimeWithZone] The time.
  #
  # source://mongoid//lib/mongoid/extensions/integer.rb#16
  def __mongoize_time__; end

  # Is the integer a number?
  #
  # @example Is the object a number?.
  #   object.numeric?
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/extensions/integer.rb#26
  def numeric?; end

  # Is the object not to be converted to bson on criteria creation?
  #
  # @deprecated
  # @example Is the object unconvertable?
  #   object.unconvertable_to_bson?
  # @return [true] If the object is unconvertable.
  #
  # source://mongoid//lib/mongoid/extensions/integer.rb#37
  def unconvertable_to_bson?(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/extensions/integer.rb#42
module Mongoid::Extensions::Integer::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   BigDecimal.mongoize("123.11")
  # @return [Integer | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/integer.rb#61
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   BigDecimal.mongoize("123.11")
  # @return [Integer | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/integer.rb#51
  def mongoize(object); end
end

# Adds type-casting behavior to Module class.
#
# source://mongoid//lib/mongoid/extensions/module.rb#8
module Mongoid::Extensions::Module
  # Redefine the method. Will undef the method if it exists or simply
  # just define it.
  #
  # @example Redefine the method.
  #   Object.re_define_method("exists?") do
  #   self
  #   end
  # @param &block The method body.
  # @param name [String | Symbol] The name of the method.
  # @return [Method] The new method.
  #
  # source://mongoid//lib/mongoid/extensions/module.rb#22
  def re_define_method(name, &block); end
end

# Adds type-casting behavior to NilClass.
#
# source://mongoid//lib/mongoid/extensions/nil_class.rb#7
module Mongoid::Extensions::NilClass
  # Try to form a setter from this object.
  #
  # @deprecated
  # @example Try to form a setter.
  #   object.__setter__
  # @return [nil] Always nil.
  #
  # source://mongoid//lib/mongoid/extensions/nil_class.rb#15
  def __setter__(*args, **_arg1, &block); end

  # Get the name of a nil collection.
  #
  # @example Get the nil name.
  #   nil.collectionize
  # @return [String] A blank string.
  #
  # source://mongoid//lib/mongoid/extensions/nil_class.rb#26
  def collectionize; end
end

# Adds type-casting behavior to Object class.
#
# source://mongoid//lib/mongoid/extensions/object.rb#7
module Mongoid::Extensions::Object
  # Evolve a plain object into an object id.
  #
  # @example Evolve the object.
  #   object.__evolve_object_id__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#18
  def __evolve_object_id__; end

  # Convert the object to args for a find query.
  #
  # @deprecated
  # @example Convert the object to args.
  #   object.__find_args__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#30
  def __find_args__(*args, **_arg1, &block); end

  # Evolve a plain object into an object id.
  #
  # @example Evolve the object.
  #   object.__evolve_object_id__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#21
  def __mongoize_object_id__; end

  # Try to form a setter from this object.
  #
  # @deprecated
  # @example Try to form a setter.
  #   object.__setter__
  # @return [String] The object as a string plus =.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#42
  def __setter__(*args, **_arg1, &block); end

  # Get the value of the object as a mongo friendly sort value.
  #
  # @deprecated
  # @example Get the object as sort criteria.
  #   object.__sortable__
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#54
  def __sortable__(*args, **_arg1, &block); end

  # Conversion of an object to an $inc-able value.
  #
  # @deprecated
  # @example Convert the object.
  #   1.__to_inc__
  # @return [Object] The object.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#66
  def __to_inc__(*args, **_arg1, &block); end

  # Do or do not, there is no try. -- Yoda.
  #
  # @deprecated
  # @example Do or do not.
  #   object.do_or_do_not(:use, "The Force")
  # @param *args [Object...] The arguments.
  # @param name [String | Symbol] The method name.
  # @return [Object | nil] The result of the method call or nil if the
  #   method does not exist.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#83
  def do_or_do_not(*args, **_arg1, &block); end

  # Get the value for an instance variable or false if it doesn't exist.
  #
  # @example Get the value for an instance var.
  #   document.ivar("person")
  # @param name [String] The name of the variable.
  # @return [Object | false] The value or false.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#96
  def ivar(name); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   object.mongoize
  # @return [Object] The object.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#112
  def mongoize; end

  # Is the object multi args.
  #
  # @deprecated
  # @example Is the object multi args?
  #   object.multi_arged?
  # @return [false] false.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#123
  def multi_arged?(*args, **_arg1, &block); end

  # Is the object a number?
  #
  # @example Is the object a number?.
  #   object.numeric?
  # @return [false] Always false.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#134
  def numeric?; end

  # Remove the instance variable for the provided name.
  #
  # @example Remove the instance variable
  #   document.remove_ivar("person")
  # @param name [String] The name of the variable.
  # @return [true | false] If the variable was defined.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#146
  def remove_ivar(name); end

  # Is the object's size changable? Only returns true for arrays and hashes
  # currently.
  #
  # @example Is the object resizable?
  #   object.resizable?
  # @return [false] false.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#161
  def resizable?; end

  # Get the substitutable version of an object.
  #
  # @example Get the substitutable.
  #   object.substitutable
  # @return [Object] self.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#171
  def substitutable; end

  # You must unlearn what you have learned. -- Yoda
  #
  # @deprecated
  # @example You must perform this execution.
  #   object.you_must(:use, "The Force")
  # @param *args [Object...] The arguments.
  # @param name [String | Symbol] The method name.
  # @return [Object | nil] The result of the method call or nil if the
  #   method does not exist. Nil if the object is frozen.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#186
  def you_must(*args, **_arg1, &block); end

  class << self
    # @private
    #
    # source://mongoid//lib/mongoid/extensions/object.rb#8
    def included(base); end
  end
end

# source://mongoid//lib/mongoid/extensions/object.rb#191
module Mongoid::Extensions::Object::ClassMethods
  # Convert the provided object to a foreign key, given the metadata key
  # contstraint.
  #
  # @deprecated
  # @example Convert the object to a fk.
  #   Object.__mongoize_fk__(association, object)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param object [Object] The object to convert.
  # @return [Object] The converted object.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#203
  def __mongoize_fk__(*args, **_arg1, &block); end

  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   Object.demongoize(object)
  # @param object [Object] The object to demongoize.
  # @return [Object] The object.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#217
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Object.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [Object] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/object.rb#230
  def mongoize(object); end
end

# Adds type-casting behavior to BSON::ObjectId.
#
# source://mongoid//lib/mongoid/extensions/object_id.rb#8
module Mongoid::Extensions::ObjectId
  # Evolve the object id.
  #
  # @example Evolve the object id.
  #   object_id.__evolve_object_id__
  # @return [BSON::ObjectId] self.
  #
  # source://mongoid//lib/mongoid/extensions/object_id.rb#16
  def __evolve_object_id__; end

  # Evolve the object id.
  #
  # @example Evolve the object id.
  #   object_id.__evolve_object_id__
  # @return [BSON::ObjectId] self.
  #
  # source://mongoid//lib/mongoid/extensions/object_id.rb#19
  def __mongoize_object_id__; end
end

# source://mongoid//lib/mongoid/extensions/object_id.rb#21
module Mongoid::Extensions::ObjectId::ClassMethods
  # Evolve the object into a mongo-friendly value to query with.
  #
  # @example Evolve the object.
  #   ObjectId.evolve(id)
  # @param object [Object] The object to evolve.
  # @return [BSON::ObjectId] The object id.
  #
  # source://mongoid//lib/mongoid/extensions/object_id.rb#31
  def evolve(object); end

  # Convert the object into a mongo-friendly value to store.
  #
  # @example Convert the object.
  #   ObjectId.mongoize(id)
  # @param object [Object] The object to convert.
  # @return [BSON::ObjectId] The object id.
  #
  # source://mongoid//lib/mongoid/extensions/object_id.rb#43
  def mongoize(object); end
end

# Adds type-casting behavior to Range class.
#
# source://mongoid//lib/mongoid/extensions/range.rb#7
module Mongoid::Extensions::Range
  mixes_in_class_methods ::Mongoid::Extensions::Range::ClassMethods

  # Get the range as arguments for a find.
  #
  # @deprecated
  # @example Get the range as find args.
  #   range.__find_args__
  # @return [Array] The range as an array.
  #
  # source://mongoid//lib/mongoid/extensions/range.rb#19
  def __find_args__(*args, **_arg1, &block); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   range.mongoize
  # @return [Hash | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/range.rb#31
  def mongoize; end

  # Is this a resizable object.
  #
  # @example Is this resizable?
  #   range.resizable?
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid/extensions/range.rb#41
  def resizable?; end

  class << self
    # @private
    #
    # source://mongoid//lib/mongoid/extensions/range.rb#8
    def included(base); end
  end
end

# source://mongoid//lib/mongoid/extensions/range.rb#45
module Mongoid::Extensions::Range::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   Range.demongoize({ "min" => 1, "max" => 5 })
  # @param object [Hash] The object to demongoize.
  # @return [Range | nil] The range, or nil if object cannot be represented as range.
  #
  # source://mongoid//lib/mongoid/extensions/range.rb#54
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Range.mongoize(1..3)
  # @param object [Object] The object to mongoize.
  # @return [Hash | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/range.rb#79
  def mongoize(object); end

  private

  # source://mongoid//lib/mongoid/extensions/range.rb#89
  def __mongoize_hash__(object); end

  # source://mongoid//lib/mongoid/extensions/range.rb#97
  def __mongoize_range__(object); end
end

# Adds type-casting behavior to Regexp class.
#
# source://mongoid//lib/mongoid/extensions/regexp.rb#8
module Mongoid::Extensions::Regexp; end

# source://mongoid//lib/mongoid/extensions/regexp.rb#10
module Mongoid::Extensions::Regexp::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Regexp.mongoize(/\A[abc]/)
  # @param object [Object] The object to mongoize.
  # @return [Regexp | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/regexp.rb#31
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Regexp.mongoize(/\A[abc]/)
  # @param object [Object] The object to mongoize.
  # @return [Regexp | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/regexp.rb#21
  def mongoize(object); end
end

# Adds type-casting behavior to Set class.
#
# source://mongoid//lib/mongoid/extensions/set.rb#8
module Mongoid::Extensions::Set
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   set.mongoize
  # @return [Array | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/set.rb#16
  def mongoize; end

  # Returns whether the object's size can be changed.
  #
  # @example Is the object resizable?
  #   object.resizable?
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/extensions/set.rb#26
  def resizable?; end
end

# source://mongoid//lib/mongoid/extensions/set.rb#30
module Mongoid::Extensions::Set::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   Set.demongoize([1, 2, 3])
  # @param object [Array] The object to demongoize.
  # @return [Set] The set.
  #
  # source://mongoid//lib/mongoid/extensions/set.rb#39
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Set.mongoize(Set.new([1,2,3]))
  # @param object [Set] The object to mongoize.
  # @return [Array | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/set.rb#55
  def mongoize(object); end
end

# Adds type-casting behavior to String class.
#
# source://mongoid//lib/mongoid/extensions/string.rb#8
module Mongoid::Extensions::String
  # Evolve the string into an object id if possible.
  #
  # @example Evolve the string.
  #   "test".__evolve_object_id__
  # @return [String | BSON::ObjectId] The evolved string.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#21
  def __evolve_object_id__; end

  # Mongoize the string into an object id if possible.
  #
  # @example Evolve the string.
  #   "test".__mongoize_object_id__
  # @return [String | BSON::ObjectId | nil] The mongoized string.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#31
  def __mongoize_object_id__; end

  # Mongoize the string for storage.
  #
  # @example Mongoize the string.
  #   "2012-01-01".__mongoize_time__
  #   # => 2012-01-01 00:00:00 -0500
  # @note Returns a local time in the default time zone.
  # @raise [ArgumentError] The string is not a valid time string.
  # @return [Time | ActiveSupport::TimeWithZone] Local time in the
  #   configured default time zone corresponding to this string.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#47
  def __mongoize_time__; end

  # Does the string end with _before_type_cast?
  #
  # @example Is the string a setter method?
  #   "price_before_type_cast".before_type_cast?
  # @return [true | false] If the string ends with "_before_type_cast"
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#127
  def before_type_cast?; end

  # Convert the string to a collection friendly name.
  #
  # @example Collectionize the string.
  #   "namespace/model".collectionize
  # @return [String] The string in collection friendly form.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#62
  def collectionize; end

  # Is the string a valid value for a Mongoid id?
  #
  # @deprecated
  # @example Is the string an id value?
  #   "_id".mongoid_id?
  # @return [true | false] If the string is id or _id.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#73
  def mongoid_id?(*args, **_arg1, &block); end

  # Is the string a number? The literals "NaN", "Infinity", and "-Infinity"
  # are counted as numbers.
  #
  # @example Is the string a number.
  #   "1234.23".numeric?
  # @return [true | false] If the string is a number.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#85
  def numeric?; end

  # Get the string as a getter string.
  #
  # @example Get the reader/getter
  #   "model=".reader
  # @return [String] The string stripped of "=".
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#97
  def reader; end

  # @deprecated
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#12
  def unconvertable_to_bson(*args, **_arg1, &block); end

  # @deprecated
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#12
  def unconvertable_to_bson=(*args, **_arg1, &block); end

  # Is the object not to be converted to bson on criteria creation?
  #
  # @deprecated
  # @example Is the object unconvertable?
  #   object.unconvertable_to_bson?
  # @return [true | false] If the object is unconvertable.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#139
  def unconvertable_to_bson?(*args, **_arg1, &block); end

  # Is this string a valid_method_name?
  #
  # @example Is the string a valid Ruby identifier for use as a method name
  #   "model=".valid_method_name?
  # @return [true | false] If the string contains a valid Ruby identifier.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#117
  def valid_method_name?; end

  # Is this string a writer?
  #
  # @example Is the string a setter method?
  #   "model=".writer?
  # @return [true | false] If the string contains "=".
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#107
  def writer?; end

  private

  # If the string is a legal object id, convert it.
  #
  # @api private
  # @example Convert to the object id.
  #   string.convert_to_object_id
  # @return [String | BSON::ObjectId] The string or the id.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#154
  def convert_to_object_id; end
end

# source://mongoid//lib/mongoid/extensions/string.rb#158
module Mongoid::Extensions::String::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   String.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [String] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#172
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   String.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [String] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/string.rb#169
  def mongoize(object); end
end

# Adds type-casting behavior to Symbol class.
#
# source://mongoid//lib/mongoid/extensions/symbol.rb#8
module Mongoid::Extensions::Symbol
  # Is the symbol a valid value for a Mongoid id?
  #
  # @deprecated
  # @example Is the string an id value?
  #   :_id.mongoid_id?
  # @return [true | false] If the symbol is :id or :_id.
  #
  # source://mongoid//lib/mongoid/extensions/symbol.rb#17
  def mongoid_id?(*args, **_arg1, &block); end
end

# source://mongoid//lib/mongoid/extensions/symbol.rb#22
module Mongoid::Extensions::Symbol::ClassMethods
  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Symbol.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [Symbol | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/symbol.rb#36
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Symbol.mongoize("123.11")
  # @param object [Object] The object to mongoize.
  # @return [Symbol | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/symbol.rb#33
  def mongoize(object); end
end

# Adds type-casting behavior to Time class.
#
# source://mongoid//lib/mongoid/extensions/time.rb#8
module Mongoid::Extensions::Time
  # Mongoizes a Time into a time.
  #
  # Time always mongoize into Time instances
  # (which are themselves).
  #
  # @return [Time] self.
  #
  # source://mongoid//lib/mongoid/extensions/time.rb#16
  def __mongoize_time__; end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   time.mongoize
  # @return [Time | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/time.rb#27
  def mongoize; end
end

# source://mongoid//lib/mongoid/extensions/time.rb#31
module Mongoid::Extensions::Time::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   Time.demongoize(object)
  # @param object [Time] The time from Mongo.
  # @return [Time | nil] The object as a time.
  #
  # source://mongoid//lib/mongoid/extensions/time.rb#41
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   Time.mongoize("2012-1-1")
  # @param object [Object] The object to mongoize.
  # @return [Time | nil] The object mongoized or nil.
  #
  # source://mongoid//lib/mongoid/extensions/time.rb#71
  def mongoize(object); end
end

# Adds type-casting behavior to ActiveSupport::TimeWithZone class.
#
# source://mongoid//lib/mongoid/extensions/time_with_zone.rb#8
module Mongoid::Extensions::TimeWithZone
  # Mongoizes an ActiveSupport::TimeWithZone into a time.
  #
  # TimeWithZone always mongoize into TimeWithZone instances
  # (which are themselves).
  #
  # @return [ActiveSupport::TimeWithZone] self.
  #
  # source://mongoid//lib/mongoid/extensions/time_with_zone.rb#16
  def __mongoize_time__; end

  # This code is copied from Time class extension in bson-ruby gem. It
  # should be removed from here when the minimum BSON version is 5+.
  # See https://jira.mongodb.org/browse/MONGOID-5491.
  #
  # source://mongoid//lib/mongoid/extensions/time_with_zone.rb#34
  def _bson_to_i; end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   date_time.mongoize
  # @return [Time] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/time_with_zone.rb#27
  def mongoize; end
end

# source://mongoid//lib/mongoid/extensions/time_with_zone.rb#45
module Mongoid::Extensions::TimeWithZone::ClassMethods
  # Convert the object from its mongo friendly ruby type to this type.
  #
  # @example Demongoize the object.
  #   TimeWithZone.demongoize(object)
  # @param object [Time] The time from Mongo.
  # @return [TimeWithZone] The object as a date.
  #
  # source://mongoid//lib/mongoid/extensions/time_with_zone.rb#55
  def demongoize(object); end

  # Turn the object from the ruby type we deal with to a Mongo friendly
  # type.
  #
  # @example Mongoize the object.
  #   TimeWithZone.mongoize("2012-1-1")
  # @param object [Object] The object to convert.
  # @return [Time] The object mongoized.
  #
  # source://mongoid//lib/mongoid/extensions/time_with_zone.rb#68
  def mongoize(object); end
end

# Adds type-casting behavior to TrueClass
#
# source://mongoid//lib/mongoid/extensions/true_class.rb#7
module Mongoid::Extensions::TrueClass
  # Get the value of the object as a mongo friendly sort value.
  #
  # @deprecated
  # @example Get the object as sort criteria.
  #   object.__sortable__
  # @return [Integer] 1.
  #
  # source://mongoid//lib/mongoid/extensions/true_class.rb#15
  def __sortable__(*args, **_arg1, &block); end

  # Is the passed value a boolean?
  #
  # @example Is the value a boolean type?
  #   true.is_a?(Boolean)
  # @param other [Class] The class to check.
  # @return [true | false] If the other is a boolean.
  #
  # source://mongoid//lib/mongoid/extensions/true_class.rb#28
  def is_a?(other); end
end

# Instantiates documents that came from the database.
#
# source://mongoid//lib/mongoid/factory.rb#5
module Mongoid::Factory
  extend ::Mongoid::Factory

  # Builds a new +Document+ from the supplied attributes.
  #
  # This method either instantiates klass or a descendant of klass if the attributes include
  # klass' discriminator key.
  #
  # If the attributes contain the discriminator key (which is _type by default) and the
  # discriminator value does not correspond to a descendant of klass then this method
  # would create an instance of klass.
  #
  # @example Build the document.
  #   Mongoid::Factory.build(Person, { "name" => "Durran" })
  # @option options
  # @param attributes [Hash] The document attributes.
  # @param klass [Class] The class to instantiate from if _type is not present.
  # @param options [Hash] a customizable set of options
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#154
  def build(klass, attributes = T.unsafe(nil)); end

  # Execute the build.
  #
  # @api private
  # @note A Ruby 2.x bug prevents the options hash from being keyword
  #   arguments. Once we drop support for Ruby 2.x, we can reimplement
  #   the options hash as keyword arguments.
  #   See https://bugs.ruby-lang.org/issues/15753
  # @option options
  # @param attributes [Hash] The document attributes.
  # @param klass [Class] The class to instantiate from if _type is not present.
  # @param options [Hash] The options to use.
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#175
  def execute_build(klass, attributes = T.unsafe(nil), options = T.unsafe(nil)); end

  # Execute from_db.
  #
  # @api private
  # @param attributes [Hash] The document attributes.
  # @param criteria [Criteria] Optional criteria object.
  # @param execute_callbacks [true | false] Whether this method should
  #   invoke the callbacks. If true, the callbacks will be invoked normally.
  #   If false, the callbacks will be stored in the +pending_callbacks+ list
  #   and caller is responsible for invoking +run_pending_callbacks+ at a
  #   later time. Use this option to defer callback execution until the
  #   entire object graph containing embedded associations is constructed.
  # @param klass [Class] The class to instantiate from if _type is not present.
  # @param selected_fields [Hash] Fields which were retrieved via
  #   #only. If selected_fields are specified, fields not listed in it
  #   will not be accessible in the returned document.
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#234
  def execute_from_db(klass, attributes = T.unsafe(nil), criteria = T.unsafe(nil), selected_fields = T.unsafe(nil), execute_callbacks: T.unsafe(nil)); end

  # Builds a new +Document+ from the supplied attributes loaded from the
  # database.
  #
  # If the attributes contain the discriminator key (which is _type by default) and the
  # discriminator value does not correspond to a descendant of klass then this method
  # raises an UnknownModel error.
  #
  # If a criteria object is given, it is used in two ways:
  # 1. If the criteria has a list of fields specified via #only,
  #    only those fields are populated in the returned document.
  # 2. If the criteria has a referencing association (i.e., this document
  #    is being instantiated as an association of another document),
  #    the other document is also populated in the returned document's
  #    reverse association, if one exists.
  #
  # @example Build the document.
  #   Mongoid::Factory.from_db(Person, { "name" => "Durran" })
  # @param attributes [Hash] The document attributes.
  # @param criteria [Criteria] Optional criteria object.
  # @param klass [Class] The class to instantiate from if _type is not present.
  # @param selected_fields [Hash] Fields which were retrieved via
  #   #only. If selected_fields are specified, fields not listed in it
  #   will not be accessible in the returned document.
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#212
  def from_db(klass, attributes = T.unsafe(nil), criteria = T.unsafe(nil), selected_fields = T.unsafe(nil)); end
end

# A helper class for instantiating a model using either it's type
# class directly, or via a type class specified via a discriminator
# key.
#
# @api private
#
# source://mongoid//lib/mongoid/factory.rb#13
class Mongoid::Factory::Instantiator
  # Creates a new Factory::Initiator.
  #
  # @api private
  # @param attributes [Hash | nil] (Optional) The hash of attributes to
  #   use when instantiating the model.
  # @param criteria [Mongoid::Criteria | nil] (Optional) The criteria
  #   object to use as a secondary source for the selected fields; also
  #   used when setting the inverse association.
  # @param klass [Mongoid::Document] The primary class to reference when
  #   instantiating the model.
  # @param selected_fields [Array | nil] The list of field names that
  #   should be explicitly (and exclusively) included in the new record.
  # @return [Instantiator] a new instance of Instantiator
  #
  # source://mongoid//lib/mongoid/factory.rb#46
  def initialize(klass, attributes, criteria, selected_fields); end

  # @api private
  # @return [Hash | nil] The Hash of attributes to use when
  #   instantiating the model.
  #
  # source://mongoid//lib/mongoid/factory.rb#19
  def attributes; end

  # @api private
  # @return [Mongoid::Criteria | nil] The criteria object to
  #   use as a secondary source for the selected fields; also used when
  #   setting the inverse association.
  #
  # source://mongoid//lib/mongoid/factory.rb#24
  def criteria; end

  # Builds and returns a new instance of the requested class.
  #
  # @api private
  # @param execute_callbacks [true | false] Whether or not the Document
  #   callbacks should be invoked with the new instance.
  # @raise [Errors::UnknownModel] when the requested type does not exist,
  #   or if it does not respond to the `instantiate` method.
  # @return [Mongoid::Document] The new document instance.
  #
  # source://mongoid//lib/mongoid/factory.rb#64
  def instance(execute_callbacks: T.unsafe(nil)); end

  # @api private
  # @return [Mongoid::Document] The primary model class being referenced
  #
  # source://mongoid//lib/mongoid/factory.rb#15
  def klass; end

  # @api private
  # @return [Array | nil] The list of field names that should
  #   be explicitly (and exclusively) included in the new record.
  #
  # source://mongoid//lib/mongoid/factory.rb#28
  def selected_fields; end

  # @api private
  # @return [String | nil] The identifier of the class that
  #   should be loaded and instantiated, in the case of a polymorphic
  #   class specification.
  #
  # source://mongoid//lib/mongoid/factory.rb#33
  def type; end

  private

  # Attempts to convert the argument into a Class object by camelizing
  # it and treating the result as the name of a constant.
  #
  # @api private
  # @param type [String] The name of the type to constantize
  # @raise [Errors::UnknownModel] if the argument does not correspond to
  #   an existing constant.
  # @return [Class] the Class that the type resolves to
  #
  # source://mongoid//lib/mongoid/factory.rb#127
  def constantize(type); end

  # Retreive the `Class` instance of the requested type, either by finding it
  # in the `klass` discriminator mapping, or by otherwise finding a
  # Document model with the given name.
  #
  # @api private
  # @return [Mongoid::Document] the requested Document model
  #
  # source://mongoid//lib/mongoid/factory.rb#107
  def constantized_type; end

  # Instantiate the given `type`, which must map to another Mongoid::Document
  # model.
  #
  # @api private
  # @param execute_callbacks [true | false] Whether this method should
  #   invoke document callbacks.
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#95
  def instantiate_with_type(execute_callbacks); end

  # Instantiate the given class without any given subclass.
  #
  # @api private
  # @param execute_callbacks [true | false] Whether this method should
  #   invoke document callbacks.
  # @return [Document] The instantiated document.
  #
  # source://mongoid//lib/mongoid/factory.rb#80
  def instantiate_without_type(execute_callbacks); end
end

# This module defines behavior for fields.
#
# source://mongoid//lib/mongoid/fields/standard.rb#5
module Mongoid::Fields
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Fields::ClassMethods

  # Applies a single default value for the given name.
  #
  # @example Apply a single default.
  #   model.apply_default("name")
  # @param name [String] The name of the field.
  #
  # source://mongoid//lib/mongoid/fields.rb#183
  def apply_default(name); end

  # Apply all the defaults at once.
  #
  # @example Apply all the defaults.
  #   model.apply_defaults
  #
  # source://mongoid//lib/mongoid/fields.rb#199
  def apply_defaults; end

  # Apply all default values to the document which are procs.
  #
  # @example Apply all the proc defaults.
  #   model.apply_post_processed_defaults
  # @return [Array<String>] The names of the proc defaults.
  #
  # source://mongoid//lib/mongoid/fields.rb#170
  def apply_post_processed_defaults; end

  # Apply all default values to the document which are not procs.
  #
  # @example Apply all the non-proc defaults.
  #   model.apply_pre_processed_defaults
  # @return [Array<String>] The names of the non-proc defaults.
  #
  # source://mongoid//lib/mongoid/fields.rb#158
  def apply_pre_processed_defaults; end

  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # @example Get the field names
  #   document.attribute_names
  # @return [Array<String>] The field names
  #
  # source://mongoid//lib/mongoid/fields.rb#214
  def attribute_names; end

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # @example Get the database field name.
  #   model.database_field_name(:authorization)
  # @param name [String | Symbol] The name to get.
  # @return [String] The name of the field as it's stored in the db.
  #
  # source://mongoid//lib/mongoid/fields.rb#227
  def database_field_name(name); end

  # Does this field start with a dollar sign ($) or contain a dot/period (.)?
  #
  # @api private
  # @param name [String] The field name.
  # @return [true | false] If this field is dotted or dollared.
  #
  # source://mongoid//lib/mongoid/fields.rb#263
  def dot_dollar_field?(name); end

  # Is the provided field a lazy evaluation?
  #
  # @example If the field is lazy settable.
  #   doc.lazy_settable?(field, nil)
  # @param field [Field] The field.
  # @param value [Object] The current value.
  # @return [true | false] If we set the field lazily.
  #
  # source://mongoid//lib/mongoid/fields.rb#240
  def lazy_settable?(field, value); end

  # Is the document using object ids?
  #
  # @example Is the document using object ids?
  #   model.using_object_ids?
  # @note Refactored from using delegate for class load performance.
  # @return [true | false] Using object ids.
  #
  # source://mongoid//lib/mongoid/fields.rb#252
  def using_object_ids?; end

  # Validate whether or not the field starts with a dollar sign ($) or
  # contains a dot/period (.).
  #
  # @api private
  # @param name [String] The field name.
  # @raise [InvalidDotDollarAssignment] If contains dots or starts with a dollar.
  #
  # source://mongoid//lib/mongoid/fields.rb#276
  def validate_writable_field_name!(name); end

  class << self
    # Get the name of the provided field as it is stored in the database.
    # Used in determining if the field is aliased or not. Recursively
    # finds aliases for embedded documents and fields, delimited with
    # period "." character.
    #
    # Note that this method returns the name of associations as they're
    # stored in the database, whereas the `relations` hash uses their in-code
    # aliases. In order to check for membership in the relations hash, you
    # would first have to look up the string returned from this method in
    # the aliased_associations hash.
    #
    # This method will not expand the alias of a belongs_to association that
    # is not the last item. For example, if we had a School that has_many
    # Students, and the field name passed was (from the Student's perspective):
    #
    #   school._id
    #
    # The alias for a belongs_to association is that association's _id field.
    # Therefore, expanding out this association would yield:
    #
    #   school_id._id
    #
    # This is not the correct field name, because the intention here was not
    # to get a property of the _id field. The intention was to get a property
    # of the referenced document. Therefore, if a part of the name passed is
    # a belongs_to association that is not the last part of the name, we
    # won't expand its alias, and return:
    #
    #   school._id
    #
    # If the belongs_to association is the last part of the name, we will
    # pass back the _id field.
    #
    # @api private
    # @param aliased_associations [Hash] The aliased associations.
    # @param aliased_fields [Hash] The aliased fields.
    # @param name [String | Symbol] The name to get.
    # @param relations [Hash] The associations.
    # @return [String] The name of the field as stored in the database.
    #
    # source://mongoid//lib/mongoid/fields.rb#415
    def database_field_name(name, relations, aliased_fields, aliased_associations); end

    # Stores the provided block to be run when the option name specified is
    # defined on a field.
    #
    # No assumptions are made about what functionality the handler might
    # perform, so it will always be called if the `option_name` key is
    # provided in the field definition -- even if it is false or nil.
    #
    # @example
    #   Mongoid::Fields.option :required do |model, field, value|
    #   model.validates_presence_of field if value
    #   end
    # @param &block the handler to execute when the option is provided.
    # @param option_name [Symbol] the option name to match against
    #
    # source://mongoid//lib/mongoid/fields.rb#298
    def option(option_name, &block); end

    # Return a map of custom option names to their handlers.
    #
    # @example
    #   Mongoid::Fields.options
    #   # => { :required => #<Proc:0x00000100976b38> }
    # @return [Hash] the option map
    #
    # source://mongoid//lib/mongoid/fields.rb#309
    def options; end

    # Traverse down the association tree and search for the field for the
    # given key. To do this, split the key by '.' and for each part (meth) of
    # the key:
    #
    # - If the meth is a field, yield the meth, field, and is_field as true.
    # - If the meth is an association, update the klass to the association's
    #   klass, and yield the meth, klass, and is_field as false.
    #
    # The next iteration will use klass's fields and associations to continue
    # traversing the tree.
    #
    # @api private
    # @param &block The block.
    # @param aliased_associations [Hash] The alaised associations to begin
    #   the search with.
    # @param associations [Hash] The associations to begin the search with.
    # @param fields [Hash] The fields to begin the search with.
    # @param key [String] The key used to search the association tree.
    # @return [Field] The field found for the given key at the end of the
    #   search. This will return nil if the last thing found is an association
    #   or no field was found for the given key.
    # @yieldparam The [Symbol] current method.
    # @yieldparam The [Symbol | String] field or the relation.
    # @yieldparam Whether [true | false] the second yield parameter is a
    #   field or not.
    #
    # source://mongoid//lib/mongoid/fields.rb#340
    def traverse_association_tree(key, fields, associations, aliased_associations); end
  end

  module GeneratedClassMethods
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
  end

  module GeneratedInstanceMethods
    def aliased_fields; end
    def aliased_fields=(value); end
    def aliased_fields?; end
    def fields; end
    def fields=(value); end
    def fields?; end
    def localized_fields; end
    def localized_fields=(value); end
    def localized_fields?; end
    def post_processed_defaults; end
    def post_processed_defaults=(value); end
    def post_processed_defaults?; end
    def pre_processed_defaults; end
    def pre_processed_defaults=(value); end
    def pre_processed_defaults?; end
  end
end

# source://mongoid//lib/mongoid/fields.rb#17
Mongoid::Fields::Boolean = Mongoid::Boolean

# source://mongoid//lib/mongoid/fields.rb#57
module Mongoid::Fields::ClassMethods
  # Returns an array of names for the attributes available on this object.
  #
  # Provides the field names in an ORM-agnostic way. Rails v3.1+ uses this
  # method to automatically wrap params in JSON requests.
  #
  # @example Get the field names
  #   Model.attribute_names
  # @return [Array<String>] The field names
  #
  # source://mongoid//lib/mongoid/fields.rb#454
  def attribute_names; end

  # Removes the _translations from the given field name. This is done only
  # when there doesn't already exist a field name or relation with the
  # same name (i.e. with the _translations suffix). This check for an
  # existing field is done recursively
  #
  # @param name [String | Symbol] The name of the field to cleanse.
  # @return [Field] The field name without _translations
  #
  # source://mongoid//lib/mongoid/fields.rb#100
  def cleanse_localized_field_names(name); end

  # Get the name of the provided field as it is stored in the database.
  # Used in determining if the field is aliased or not.
  #
  # @param name [String | Symbol] The name to get.
  # @return [String] The name of the field as it's stored in the db.
  #
  # source://mongoid//lib/mongoid/fields.rb#464
  def database_field_name(name); end

  # Extracts the id field from the specified attributes hash based on
  # aliases defined in this class.
  #
  # @api private
  # @param attributes [Hash] The attributes to inspect.
  # @return [Object] The id value.
  #
  # source://mongoid//lib/mongoid/fields.rb#83
  def extract_id_field(attributes); end

  # Defines all the fields that are accessible on the Document
  # For each field that is defined, a getter and setter will be
  # added as an instance method to the Document.
  #
  # @example Define a field.
  #   field :score, type: Integer, default: 0
  # @option options
  # @option options
  # @option options
  # @param name [Symbol] The name of the field.
  # @param options [Hash] The options to pass to the field.
  # @return [Field] The generated field
  #
  # source://mongoid//lib/mongoid/fields.rb#483
  def field(name, options = T.unsafe(nil)); end

  # Returns the list of id fields for this model class, as both strings
  # and symbols.
  #
  # @api private
  # @return [Array<Symbol | String>] List of id fields.
  #
  # source://mongoid//lib/mongoid/fields.rb#64
  def id_fields; end

  # Replace a field with a new type.
  #
  # @example Replace the field.
  #   Model.replace_field("_id", String)
  # @param name [String] The name of the field.
  # @param type [Class] The new type of field.
  # @return [Serializable] The new field.
  #
  # source://mongoid//lib/mongoid/fields.rb#502
  def replace_field(name, type); end

  # Traverse down the association tree and search for the field for the
  # given key.
  #
  # @api private
  # @param &block The block.
  # @param key [String] The key used to search the association tree.
  # @return [Field] The field found for the given key at the end of the
  #   search. This will return nil if the last thing found is an association
  #   or no field was found for the given key.
  # @yieldparam The [Symbol] current method.
  # @yieldparam The [Symbol | String] field or the relation.
  # @yieldparam Whether [true | false] the second yield parameter is a
  #   field or not.
  #
  # source://mongoid//lib/mongoid/fields.rb#533
  def traverse_association_tree(key, &block); end

  # Convenience method for determining if we are using +BSON::ObjectIds+ as
  # our id.
  #
  # @example Does this class use object ids?
  #   person.using_object_ids?
  # @return [true | false] If the class uses BSON::ObjectIds for the id.
  #
  # source://mongoid//lib/mongoid/fields.rb#514
  def using_object_ids?; end

  protected

  # Add the defaults to the model. This breaks them up between ones that
  # are procs and ones that are not.
  #
  # @api private
  # @example Add to the defaults.
  #   Model.add_defaults(field)
  # @param field [Field] The field to add for.
  #
  # source://mongoid//lib/mongoid/fields.rb#548
  def add_defaults(field); end

  # Define a field attribute for the +Document+.
  #
  # @api private
  # @example Set the field.
  #   Person.add_field(:name, :default => "Test")
  # @param name [Symbol] The name of the field.
  # @param options [Hash] The hash of options.
  #
  # source://mongoid//lib/mongoid/fields.rb#569
  def add_field(name, options = T.unsafe(nil)); end

  # Create the field accessors.
  #
  # @api private
  # @example Generate the accessors.
  #   Person.create_accessors(:name, "name")
  #   person.name #=> returns the field
  #   person.name = "" #=> sets the field
  #   person.name? #=> Is the field present?
  #   person.name_before_type_cast #=> returns the field before type cast
  # @param meth [Symbol] The name of the accessor.
  # @param name [Symbol] The name of the field.
  # @param options [Hash] The options.
  #
  # source://mongoid//lib/mongoid/fields.rb#622
  def create_accessors(name, meth, options = T.unsafe(nil)); end

  # Create the check method for the provided field.
  #
  # @api private
  # @example Create the check.
  #   Model.create_field_check("name", "name")
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#714
  def create_field_check(name, meth); end

  # Create the getter method for the provided field.
  #
  # @api private
  # @example Create the getter.
  #   Model.create_field_getter("name", "name", field)
  # @param field [Field] The field.
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#647
  def create_field_getter(name, meth, field); end

  # Create the getter_before_type_cast method for the provided field. If
  # the attribute has been assigned, return the attribute before it was
  # type cast. Otherwise, delegate to the getter.
  #
  # @api private
  # @example Create the getter_before_type_cast.
  #   Model.create_field_getter_before_type_cast("name", "name")
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#671
  def create_field_getter_before_type_cast(name, meth); end

  # Create the setter method for the provided field.
  #
  # @api private
  # @example Create the setter.
  #   Model.create_field_setter("name", "name")
  # @param field [Field] The field.
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#693
  def create_field_setter(name, meth, field); end

  # Create the translation getter method for the provided field.
  #
  # @api private
  # @example Create the translation getter.
  #   Model.create_translations_getter("name", "name")
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#732
  def create_translations_getter(name, meth); end

  # Create the translation setter method for the provided field.
  #
  # @api private
  # @example Create the translation setter.
  #   Model.create_translations_setter("name", "name")
  # @param field [Field] The field.
  # @param meth [String] The name of the method.
  # @param name [String] The name of the attribute.
  #
  # source://mongoid//lib/mongoid/fields.rb#752
  def create_translations_setter(name, meth, field); end

  # Create a field for the given name and options.
  #
  # @api private
  # @param name [Symbol] The name of the field.
  # @param options [Hash] The hash of options.
  # @return [Field] The created field.
  #
  # source://mongoid//lib/mongoid/fields.rb#802
  def field_for(name, options); end

  # Include the field methods as a module, so they can be overridden.
  #
  # @api private
  # @example Include the fields.
  #   Person.generated_methods
  # @return [Module] The module of generated methods.
  #
  # source://mongoid//lib/mongoid/fields.rb#773
  def generated_methods; end

  # Run through all custom options stored in Mongoid::Fields.options and
  # execute the handler if the option is provided.
  #
  # @api private
  # @example
  #   Mongoid::Fields.option :custom do
  #   puts "called"
  #   end
  #
  #   field = Mongoid::Fields.new(:test, :custom => true)
  #   Person.process_options(field)
  #   # => "called"
  # @param field [Field] the field to process
  #
  # source://mongoid//lib/mongoid/fields.rb#598
  def process_options(field); end

  # Remove the default keys for the provided name.
  #
  # @api private
  # @example Remove the default keys.
  #   Model.remove_defaults(name)
  # @param name [String] The field name.
  #
  # source://mongoid//lib/mongoid/fields.rb#789
  def remove_defaults(name); end

  # Get the class for the given type.
  #
  # @api private
  # @param name [Symbol] The name of the field.
  # @param type [Symbol | Class] The type of the field.
  # @raise [Mongoid::Errors::InvalidFieldType] if given an invalid field
  #   type.
  # @return [Class] The type of the field.
  #
  # source://mongoid//lib/mongoid/fields.rb#822
  def retrieve_and_validate_type(name, type); end

  # Returns the type of the field if the type was not in the TYPE_MAPPINGS
  # hash.
  #
  # @api private
  # @param type [Symbol | Class] The type of the field.
  # @return [Class] The type of the field.
  #
  # source://mongoid//lib/mongoid/fields.rb#847
  def unmapped_type(type); end

  # Queries whether or not the given type is permitted as a declared field
  # type.
  #
  # @api private
  # @param type [Class] The type to query
  # @return [true | false] whether or not the type is supported
  #
  # source://mongoid//lib/mongoid/fields.rb#863
  def unsupported_type?(type); end
end

# Represents a field that should be encrypted.
#
# source://mongoid//lib/mongoid/fields/encrypted.rb#7
class Mongoid::Fields::Encrypted < ::Mongoid::Fields::Standard
  # @return [Encrypted] a new instance of Encrypted
  #
  # source://mongoid//lib/mongoid/fields/encrypted.rb#8
  def initialize(name, options = T.unsafe(nil)); end

  # @return [true | false | nil] Whether the field should be encrypted using a
  #   deterministic encryption algorithm; if not specified, nil is returned.
  #
  # source://mongoid//lib/mongoid/fields/encrypted.rb#19
  def deterministic?; end

  # @return [String | nil] The key id to use for encryption; if not specified,
  #   nil is returned.
  #
  # source://mongoid//lib/mongoid/fields/encrypted.rb#25
  def key_id; end

  # @return [String | nil] The name of the field that contains the
  #   key alt name to use for encryption; if not specified, nil is returned.
  #
  # source://mongoid//lib/mongoid/fields/encrypted.rb#31
  def key_name_field; end

  # Override the key_id for the field.
  #
  # This method is solely for testing purposes and should not be used in
  # the application code. The schema_map is generated very early in the
  # application lifecycle, and overriding the key_id after that will not
  # have any effect.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/fields/encrypted.rb#43
  def set_key_id(key_id); end
end

# Represents a BSON document field definition which stores
# a foreign key that references the ID of another document.
# Used for association behavior.
#
# source://mongoid//lib/mongoid/fields/foreign_key.rb#10
class Mongoid::Fields::ForeignKey < ::Mongoid::Fields::Standard
  # Adds the atomic changes for this type of resizable field.
  #
  # @todo: Refactor, big time.
  #
  # @example Add the atomic changes.
  #   field.add_atomic_changes(doc, "key", {}, [], [])
  # @param document [Document] The document to add to.
  # @param key [String] The atomic location of the field.
  # @param mods [Hash] The current modifications.
  # @param name [String] The name of the field.
  # @param new_elements [Array] The new elements to add.
  # @param old_elements [Array] The old elements getting removed.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#25
  def add_atomic_changes(document, name, key, mods, new_elements, old_elements); end

  # Evolve the object into an id compatible object.
  #
  # @example Evolve the object.
  #   field.evolve(object)
  # @param object [Object] The object to evolve.
  # @return [Object] The evolved object.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#64
  def evolve(object); end

  # Is this field a foreign key?
  #
  # @example Is the field a foreign key?
  #   field.foreign_key?
  # @return [true | false] If the field is a foreign key.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#52
  def foreign_key?; end

  # Does this field do lazy default evaluation?
  #
  # @example Is the field lazy?
  #   field.lazy?
  # @return [true | false] If the field is lazy.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#84
  def lazy?; end

  # Mongoize the object into the Mongo friendly value.
  #
  # @example Mongoize the object.
  #   field.mongoize(object)
  # @param object [Object] The object to Mongoize.
  # @return [Object] The mongoized object.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#96
  def mongoize(object); end

  # Is the field a BSON::ObjectId?
  #
  # @example Is the field a BSON::ObjectId?
  #   field.object_id_field?
  # @return [true | false] If the field is a BSON::ObjectId.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#110
  def object_id_field?; end

  # Returns true if an array, false if not.
  #
  # @example Is the field resizable?
  #   field.resizable?
  # @return [true | false] If the field is resizable.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#121
  def resizable?; end

  private

  # Evaluate the default proc. In some cases we need to instance exec,
  # in others we don't.
  #
  # @example Eval the default proc.
  #   field.evaluate_default_proc(band)
  # @param doc [Document] The document.
  # @return [Object] The called proc.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#158
  def evaluate_default_proc(doc); end

  # Convert the provided object to a Mongo-friendly foreign key.
  #
  # @example Convert the object to a foreign key.
  #   mongoize_foreign_key(object)
  # @param object [Object] The object to convert.
  # @return [Object] The converted object.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#135
  def mongoize_foreign_key(object); end

  # source://mongoid//lib/mongoid/fields/foreign_key.rb#174
  def primary_key_field; end

  # Get the id field of the association.
  #
  # @api private
  # @example Get the related id field.
  #   field.related_id_field
  # @return [Fields::Standard] The field.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#170
  def related_id_field; end

  # This is used when default values need to be serialized. Most of the
  # time just return the object.
  #
  # @api private
  # @example Serialize the default value.
  #   field.serialize_default(obj)
  # @param object [Object] The default.
  # @return [Object] The serialized default.
  #
  # source://mongoid//lib/mongoid/fields/foreign_key.rb#189
  def serialize_default(object); end
end

# Constant for all names of the _id field in a document.
#
# This does not include aliases of _id field.
#
# @api private
#
# source://mongoid//lib/mongoid/fields.rb#45
Mongoid::Fields::IDS = T.let(T.unsafe(nil), Array)

# BSON classes that are not supported as field types
#
# @api private
#
# source://mongoid//lib/mongoid/fields.rb#50
Mongoid::Fields::INVALID_BSON_CLASSES = T.let(T.unsafe(nil), Array)

# Represents a BSON document field definition which stores
# different values for different user locale keys in a Ruby
# hashmap (BSON "Object" type). Used for internationalization
# (I18n) support.
#
# source://mongoid//lib/mongoid/fields/localized.rb#11
class Mongoid::Fields::Localized < ::Mongoid::Fields::Standard
  # Demongoize the object based on the current locale. Will look in the
  # hash for the current locale.
  #
  # @example Get the demongoized value.
  #   field.demongoize({ "en" => "testing" })
  # @param object [Hash] The hash of translations.
  # @return [Object] The value for the current locale.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#22
  def demongoize(object); end

  # Is the localized field enforcing values to be present?
  #
  # @example Is the localized field enforcing values to be present?
  #   field.localize_present?
  # @return [true | false] If the field enforces present.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#46
  def localize_present?; end

  # Is the field localized or not?
  #
  # @example Is the field localized?
  #   field.localized?
  # @return [true | false] If the field is localized.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#36
  def localized?; end

  # Convert the provided string into a hash for the locale.
  #
  # @example Serialize the value.
  #   field.mongoize("testing")
  # @param object [String] The string to convert.
  # @return [Hash] The locale with string translation.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#58
  def mongoize(object); end

  private

  # Are fallbacks being used for this localized field.
  #
  # @api private
  # @example Should fallbacks be used.
  #   field.fallbacks?
  # @return [true | false] If fallbacks should be used.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#72
  def fallbacks?; end

  # Lookup the value from the provided object.
  #
  # @api private
  # @example Lookup the value.
  #   field.lookup({ "en" => "test" })
  # @param object [Hash] The localized object.
  # @return [Object] The object for the locale.
  #
  # source://mongoid//lib/mongoid/fields/localized.rb#87
  def lookup(object); end
end

# Represents a standard field definition (name, type, etc.)
# used to enforce consistent schema structure to the BSON
# documents which Mongoid persists.
#
# source://mongoid//lib/mongoid/fields/standard.rb#10
class Mongoid::Fields::Standard
  extend ::Forwardable

  # Create the new field with a name and optional additional options.
  #
  # @example Create the new field.
  #   Field.new(:name, :type => String)
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The field options.
  # @return [Standard] a new instance of Standard
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#71
  def initialize(name, options = T.unsafe(nil)); end

  # Adds the atomic changes for this type of resizable field.
  #
  # field.add_atomic_changes(doc, "key", {}, [], [])
  #
  # @example Add the atomic changes.
  # @param document [Document] The document to add to.
  # @param key [String] The atomic location of the field.
  # @param mods [Hash] The current modifications.
  # @param name [String] The name of the field.
  # @param new [Array] The new elements to add.
  # @param old [Array] The old elements getting removed.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#30
  def add_atomic_changes(document, name, key, mods, new, old); end

  # Get the metadata for the field if its a foreign key.
  #
  # @example Get the metadata.
  #   field.metadata
  # @return [Metadata] The association metadata.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#121
  def association; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def default_val; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def default_val=(_arg0); end

  # source://mongoid//lib/mongoid/fields/standard.rb#17
  def demongoize(*_arg0, **_arg1, &_arg2); end

  # Evaluate the default value and return it. Will handle the
  # serialization, proc calls, and duplication if necessary.
  #
  # @example Evaluate the default value.
  #   field.eval_default(document)
  # @param doc [Document] The document the field belongs to.
  # @return [Object] The serialized default value.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#43
  def eval_default(doc); end

  # source://mongoid//lib/mongoid/fields/standard.rb#17
  def evolve(*_arg0, **_arg1, &_arg2); end

  # Is this field a foreign key?
  #
  # @example Is the field a foreign key?
  #   field.foreign_key?
  # @return [true | false] If the field is a foreign key.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#57
  def foreign_key?; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def label; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def label=(_arg0); end

  # Does this field do lazy default evaluation?
  #
  # @example Is the field lazy?
  #   field.lazy?
  # @return [true | false] If the field is lazy.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#91
  def lazy?; end

  # Is the localized field enforcing values to be present?
  #
  # @example Is the localized field enforcing values to be present?
  #   field.localize_present?
  # @return [true | false] If the field enforces present.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#111
  def localize_present?; end

  # Is the field localized or not?
  #
  # @example Is the field localized?
  #   field.localized?
  # @return [true | false] If the field is localized.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#101
  def localized?; end

  # source://mongoid//lib/mongoid/fields/standard.rb#17
  def mongoize(*_arg0, **_arg1, &_arg2); end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def name; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def name=(_arg0); end

  # Is the field a BSON::ObjectId?
  #
  # @example Is the field a BSON::ObjectId?
  #   field.object_id_field?
  # @return [true | false] If the field is a BSON::ObjectId.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#131
  def object_id_field?; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def options; end

  # Defines the behavior for defined fields in the document.
  # Set readers for the instance variables.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#15
  def options=(_arg0); end

  # Does the field pre-process its default value?
  #
  # @example Does the field pre-process the default?
  #   field.pre_processed?
  # @return [true | false] If the field's default is pre-processed.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#141
  def pre_processed?; end

  # Get the type of this field - inferred from the class name.
  #
  # @example Get the type.
  #   field.type
  # @return [Class] The name of the class.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#152
  def type; end

  private

  # Get the name of the default method for this field.
  #
  # @api private
  # @example Get the default name.
  #   field.default_name
  # @return [String] The method name.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#166
  def default_name; end

  # Define the method for getting the default on the document.
  #
  # @api private
  # @example Define the method.
  #   field.define_default_method(doc)
  # @note Ruby's instance_exec was just too slow.
  # @param object [Class | Module] The class or module the field is
  #   defined on.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#181
  def define_default_method(object); end

  # Evaluate the default proc. In some cases we need to instance exec,
  # in others we don't.
  #
  # @example Eval the default proc.
  #   field.evaluate_default_proc(band)
  # @param doc [Document] The document.
  # @return [Object] The called proc.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#226
  def evaluate_default_proc(doc); end

  # Get the evaluated default.
  #
  # @example Get the evaluated default.
  #   field.evaluated_default.
  # @param doc [Document] The doc being applied to.
  # @return [Object] The default value.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#209
  def evaluated_default(doc); end

  # Is the field included in the fields that were returned from the
  # database? We can apply the default if:
  #   1. The field is included in an only limitation (field: 1)
  #   2. The field is not excluded in a without limitation (field: 0)
  #
  # @example Is the field included?
  #   field.included?(fields)
  # @param fields [Hash] The field limitations.
  # @return [true | false] If the field was included.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#196
  def included?(fields); end

  # This is used when default values need to be serialized. Most of the
  # time just return the object.
  #
  # @api private
  # @example Serialize the default value.
  #   field.serialize_default(obj)
  # @param object [Object] The default.
  # @return [Object] The serialized default.
  #
  # source://mongoid//lib/mongoid/fields/standard.rb#241
  def serialize_default(object); end
end

# source://mongoid//lib/mongoid/fields.rb#16
Mongoid::Fields::StringifiedSymbol = Mongoid::StringifiedSymbol

# The suffix for generated translated fields.
#
# @api private
#
# source://mongoid//lib/mongoid/fields.rb#55
Mongoid::Fields::TRANSLATIONS_SFX = T.let(T.unsafe(nil), String)

# For fields defined with symbols use the correct class.
#
# source://mongoid//lib/mongoid/fields.rb#20
Mongoid::Fields::TYPE_MAPPINGS = T.let(T.unsafe(nil), ActiveSupport::HashWithIndifferentAccess)

# source://mongoid//lib/mongoid/fields/validators/macro.rb#6
module Mongoid::Fields::Validators; end

# Validates the params passed to the field macro.
#
# source://mongoid//lib/mongoid/fields/validators/macro.rb#9
module Mongoid::Fields::Validators::Macro
  extend ::Mongoid::Fields::Validators::Macro

  # Validate the field definition.
  #
  # @example Validate the field definition.
  #   Macro.validate(Model, :name, { localized: true })
  # @param klass [Class] The model class.
  # @param name [Symbol] The field name.
  # @param options [Hash] The provided options.
  #
  # source://mongoid//lib/mongoid/fields/validators/macro.rb#35
  def validate(klass, name, options); end

  # Determine if the field name is valid, if not raise an error.
  #
  # @api private
  # @example Check the field name.
  #   Macro.validate_field_name(Model, :name)
  # @param klass [Class] The model class.
  # @param name [Symbol] The field name.
  # @raise [Errors::InvalidField] If the name is not allowed.
  #
  # source://mongoid//lib/mongoid/fields/validators/macro.rb#68
  def validate_field_name(klass, name); end

  # Validate the association definition.
  #
  # @example Validate the association definition.
  #   Macro.validate(Model, :name)
  # @param klass [Class] The model class.
  # @param name [Symbol] The field name.
  # @param options [Hash] The provided options.
  #
  # source://mongoid//lib/mongoid/fields/validators/macro.rb#49
  def validate_relation(klass, name, options = T.unsafe(nil)); end

  private

  # Determine if the field name is unique, if not raise an error.
  #
  # @api private
  # @example Check the field name.
  #   Macro.validate_name_uniqueness(Model, :name, {})
  # @param klass [Class] The model class.
  # @param name [Symbol] The field name.
  # @param options [Hash] The provided options.
  # @raise [Errors::InvalidField] If the name is not allowed.
  #
  # source://mongoid//lib/mongoid/fields/validators/macro.rb#90
  def validate_name_uniqueness(klass, name, options); end

  # Validate that the field options are allowed.
  #
  # @api private
  # @example Validate the field options.
  #   Macro.validate_options(Model, :name, { localized: true })
  # @param klass [Class] The model class.
  # @param name [Symbol] The field name.
  # @param options [Hash] The provided options.
  # @raise [Errors::InvalidFieldOption] If an option is invalid.
  #
  # source://mongoid//lib/mongoid/fields/validators/macro.rb#112
  def validate_options(klass, name, options); end
end

# source://mongoid//lib/mongoid/fields/validators/macro.rb#12
Mongoid::Fields::Validators::Macro::OPTIONS = T.let(T.unsafe(nil), Array)

# This module defines the finder methods that hang off the document at the
# class level.
#
# source://mongoid//lib/mongoid/findable.rb#8
module Mongoid::Findable
  extend ::Forwardable

  # source://mongoid//lib/mongoid/findable.rb#18
  def aggregates(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def all_in(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def all_of(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def and(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def any_in(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def any_of(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def asc(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def ascending(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def avg(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def batch_size(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def between(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def collation(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def comment(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#74
  def count(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def create_with(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def cursor_type(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def desc(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def descending(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def distinct(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def each(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def each_with_index(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def elem_match(*_arg0, **_arg1, &_arg2); end

  # Returns true if count is zero
  #
  # @example Are there no saved documents for this model?
  #   Person.empty?
  # @return [true | false] If the collection is empty.
  #
  # source://mongoid//lib/mongoid/findable.rb#94
  def empty?; end

  # source://mongoid//lib/mongoid/findable.rb#11
  def eq(*_arg0, **_arg1, &_arg2); end

  # Returns an estimated count of records in the database.
  #
  # @example Get the count of matching documents.
  #   Person.estimated_count
  # @return [Integer] The number of matching documents.
  #
  # source://mongoid//lib/mongoid/findable.rb#84
  def estimated_count; end

  # source://mongoid//lib/mongoid/findable.rb#11
  def excludes(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def exists(*_arg0, **_arg1, &_arg2); end

  # Returns true if there are on document in database based on the
  # provided arguments.
  #
  # @example Do any documents exist for given _id.
  #   Person.exists?(BSON::ObjectId(...))
  # @example Do any documents exist for given conditions.
  #   Person.exists?(name: "...")
  # @example Do any documents exist for the conditions?
  #   Person.exists?
  # @param id_or_conditions [Hash | Object | false] an _id to
  #   search for, a hash of conditions, nil or false.
  # @return [true | false] If any documents exist for the conditions.
  #   Always false if passed nil or false.
  #
  # source://mongoid//lib/mongoid/findable.rb#115
  def exists?(id_or_conditions = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def extras(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def fifth(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def fifth!(*_arg0, **_arg1, &_arg2); end

  # Finds a +Document+ or multiple documents by their _id values.
  #
  # If a single non-Array argument is given, this argument is interpreted
  # as the _id value of a document to find. If there is a matching document
  # in the database, this document is returned; otherwise, if the
  # +raise_not_found_error+ Mongoid configuration option is truthy
  # (which is the default), +Errors::DocumentNotFound+ is raised, and if
  # +raise_not_found_error+ is falsy, +find+ returns +nil+.
  #
  # If multiple arguments are given, or an Array argument is given, the
  # array is flattened and each array element is interpreted as the _id
  # value of the document to find. Mongoid then attempts to retrieve all
  # documents with the provided _id values. The return value is an array
  # of found documents. Each document appears one time in the returned array,
  # even if its _id is given multiple times in the argument to +find+.
  # If the +raise_not_found_error+ Mongoid configuration option is truthy,
  # +Errors::DocumentNotFound+ exception is raised if any of the specified
  # _ids were not found in the database. If the +raise_not_found_error+
  # Mongoid configuration option is falsy, only those documents which are
  # found are returned; if no documents are found, the return value is an
  # empty array.
  #
  # Note that MongoDB does not allow the _id field to be an array.
  #
  # The argument undergoes customary Mongoid type conversions based on
  # the type declared for the _id field. By default the _id field is a
  # +BSON::ObjectId+; this allows strings to be passed to +find+ and the
  # strings will be transparently converted to +BSON::ObjectId+ instances
  # during query construction.
  #
  # If this method is given a block, it delegates to +Enumerable#find+ and
  # returns the first document of those found by the current Crieria object
  # for which the block returns a truthy value. If both a block and ids are
  # given, the block is ignored and the documents for the given ids are
  # returned. If a block and a Proc are given, the method delegates to
  # +Enumerable#find+ and uses the proc as the default.
  #
  # The +find+ method takes into account the default scope defined on the
  # model class, if any.
  #
  # @note Each argument can be an individual id, an array of ids or
  #   a nested array. Each array will be flattened.
  # @param *args [[ Object | Array<Object> ]...] The id(s) to find.
  # @raise Errors::DocumentNotFound If not all documents are found and
  #   the +raise_not_found_error+ Mongoid configuration option is truthy.
  # @return [Document | Array<Document> | nil] A document or matching documents.
  #
  # source://mongoid//lib/mongoid/findable.rb#168
  def find(*args, &block); end

  # Find the first +Document+ given the conditions.
  # If a matching Document is not found and
  # Mongoid.raise_not_found_error is true it raises
  # Mongoid::Errors::DocumentNotFound, return null nil elsewise.
  #
  # and Mongoid.raise_not_found_error is true.
  #
  # @example Find the document by attribute other than id
  #   Person.find_by(:username => "superuser")
  # @param attrs [Hash] The attributes to check.
  # @raise [Errors::DocumentNotFound] If no document found
  # @return [Document | nil] A matching document.
  # @yield [result]
  #
  # source://mongoid//lib/mongoid/findable.rb#191
  def find_by(attrs = T.unsafe(nil)); end

  # Find the first +Document+ given the conditions, or raises
  # Mongoid::Errors::DocumentNotFound
  #
  # @example Find the document by attribute other than id
  #   Person.find_by(:username => "superuser")
  # @param attrs [Hash] The attributes to check.
  # @raise [Errors::DocumentNotFound] If no document found.
  # @return [Document] A matching document.
  # @yield [result]
  #
  # source://mongoid//lib/mongoid/findable.rb#211
  def find_by!(attrs = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_one_and_delete(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_one_and_replace(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_one_and_update(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_or_create_by(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_or_create_by!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def find_or_initialize_by(*_arg0, **_arg1, &_arg2); end

  # Find the first +Document+ given the conditions.
  #
  # @example Find the first document.
  #   Person.first
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first matching document.
  #
  # source://mongoid//lib/mongoid/findable.rb#226
  def first(limit = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def first!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def first_or_create(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def first_or_create!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def first_or_initialize(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def for_js(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def fourth(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def fourth!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def geo_spatial(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def gt(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def gte(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def hint(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def in(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def includes(*_arg0, **_arg1, &_arg2); end

  # Find the last +Document+ given the conditions.
  #
  # @example Find the last document.
  #   Person.last
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The last matching document.
  #
  # source://mongoid//lib/mongoid/findable.rb#239
  def last(limit = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def limit(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def lt(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def lte(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def map_reduce(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def max(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def max_distance(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def max_scan(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def max_time_ms(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def min(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def mod(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def ne(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def near(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def near_sphere(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def nin(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def no_timeout(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def none(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def none_of(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def nor(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def not(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def not_in(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def offset(*_arg0, **_arg1, &_arg2); end

  # Find the first +Document+ given the conditions.
  #
  # @example Find the first document.
  #   Person.first
  # @param limit [Integer] The number of documents to return.
  # @return [Document] The first matching document.
  #
  # source://mongoid//lib/mongoid/findable.rb#229
  def one(limit = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def only(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def or(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def order(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def order_by(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def pick(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def pluck(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def read(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def reorder(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def second(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def second!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def second_to_last(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def second_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def skip(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def slice(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def snapshot(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def sum(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def take(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def take!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def tally(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def text_search(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def third(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def third!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def third_to_last(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def third_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def update(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#18
  def update_all(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def where(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def with_size(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def with_type(*_arg0, **_arg1, &_arg2); end

  # source://mongoid//lib/mongoid/findable.rb#11
  def without(*_arg0, **_arg1, &_arg2); end
end

# Module used to prepend the discriminator key assignment function to change
# the value assigned to the discriminator key to a string.
#
# @api private
#
# source://mongoid//lib/mongoid.rb#150
module Mongoid::GlobalDiscriminatorKeyAssignment
  # Sets the global discriminator key name.
  #
  # @api private
  # @param value [String | Symbol] The new discriminator key name.
  #
  # source://mongoid//lib/mongoid.rb#161
  def discriminator_key=(value); end
end

# This class is used for obtaining the method definition location for
# Mongoid methods.
#
# @api private
#
# source://mongoid//lib/mongoid.rb#154
class Mongoid::GlobalDiscriminatorKeyAssignment::InvalidFieldHost
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Access
  include ::ActiveModel::Model
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::Mongoid::Atomic
  include ::Mongoid::Changeable
  include ::Mongoid::Clients::StorageOptions
  include ::Mongoid::Clients::Options
  include ::Mongoid::Clients::Sessions
  include ::Mongoid::Clients::Sessions::ClassMethods
  include ::Mongoid::Clients
  include ::Mongoid::CollectionConfigurable
  include ::Mongoid::Attributes::Nested
  include ::Mongoid::Attributes::Readonly
  include ::Mongoid::Attributes::Processing
  include ::Mongoid::Attributes
  include ::Mongoid::Fields
  include ::Mongoid::Identifiable
  include ::Mongoid::Indexable
  include ::Mongoid::Matchable
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable
  include ::Mongoid::Positional
  include ::Mongoid::Persistable::Savable
  include ::Mongoid::Persistable::Updatable
  include ::Mongoid::Persistable::Upsertable
  include ::Mongoid::Persistable
  include ::Mongoid::Association::Embedded::Cyclic
  include ::Mongoid::Association::Referenced::AutoSave
  include ::Mongoid::Association::Referenced::CounterCache
  include ::Mongoid::Association::Accessors
  include ::Mongoid::Association::Depending
  include ::Mongoid::Association::Builders
  include ::Mongoid::Association::Macros
  include ::Mongoid::Association::Reflections
  include ::Mongoid::Association::Referenced::Syncable
  include ::Mongoid::Association
  include ::Mongoid::Scopable
  include ::Mongoid::SearchIndexable
  include ::Mongoid::Selectable
  include ::Mongoid::Serializable
  include ::Mongoid::Shardable
  include ::Mongoid::Cacheable
  include ::Mongoid::Threaded::Lifecycle
  include ::Mongoid::Traversable
  include ::Mongoid::Validatable
  include ::Mongoid::Validatable::Macros
  include ::Mongoid::Interceptable
  include ::ActiveModel::Validations::Callbacks
  include ::Mongoid::Copyable
  include ::Mongoid::Equality
  include ::Mongoid::Encryptable
  include ::Mongoid::Evolvable
  include ::Mongoid::Inspectable
  include ::Mongoid::Reloadable
  include ::Mongoid::Stateful
  include ::Mongoid::Composable
  include ::Mongoid::Touchable::InstanceMethods
  include ::Mongoid::Document
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::Mongoid::Changeable::ClassMethods
  extend ::Mongoid::Clients::StorageOptions::ClassMethods
  extend ::Mongoid::Clients::Options::ClassMethods
  extend ::Mongoid::Clients::Sessions::ClassMethods
  extend ::Mongoid::CollectionConfigurable::ClassMethods
  extend ::Mongoid::Attributes::Nested::ClassMethods
  extend ::Mongoid::Attributes::Readonly::ClassMethods
  extend ::Mongoid::Attributes::ClassMethods
  extend ::Mongoid::Fields::ClassMethods
  extend ::Mongoid::Identifiable::ClassMethods
  extend ::Mongoid::Indexable::ClassMethods
  extend ::Mongoid::Persistable::Creatable::ClassMethods
  extend ::Mongoid::Persistable::Deletable::ClassMethods
  extend ::Mongoid::Persistable::Destroyable::ClassMethods
  extend ::Mongoid::Association::Embedded::Cyclic::ClassMethods
  extend ::Mongoid::Association::Referenced::CounterCache::ClassMethods
  extend ::Mongoid::Association::Depending::ClassMethods
  extend ::Mongoid::Association::Macros::ClassMethods
  extend ::Mongoid::Association::Reflections::ClassMethods
  extend ::Mongoid::Association::Referenced::Syncable::ClassMethods
  extend ::Mongoid::Scopable::ClassMethods
  extend ::Mongoid::SearchIndexable::ClassMethods
  extend ::Mongoid::Shardable::ClassMethods
  extend ::Mongoid::Threaded::Lifecycle::ClassMethods
  extend ::Mongoid::Traversable::ClassMethods
  extend ::Mongoid::Traversable::DiscriminatorRetrieval
  extend ::Mongoid::Validatable::ClassMethods
  extend ::Mongoid::Validatable::Macros
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::Mongoid::Equality::ClassMethods
  extend ::Mongoid::Encryptable::ClassMethods
  extend ::Mongoid::Findable
  extend ::OrmAdapter::ToAdapter
  extend ::Devise::Models
  extend ::Mongoid::Document::ClassMethods
  extend ::Mongoid::Traversable::DiscriminatorAssignment

  # source://mongoid//lib/mongoid.rb#155
  def ___id_default__; end

  # source://mongoid//lib/mongoid.rb#155
  def __callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _build_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _commit_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _create_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _declared_scopes; end

  # source://mongoid//lib/mongoid.rb#155
  def _declared_scopes=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def _declared_scopes?; end

  # source://mongoid//lib/mongoid.rb#155
  def _destroy_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _find_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _index; end

  # source://mongoid//lib/mongoid.rb#155
  def _index=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def _initialize_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _persist_parent_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _rollback_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_build_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_build_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_commit_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_commit_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_create_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_create_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_destroy_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_destroy_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_find_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_find_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_initialize_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_initialize_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_persist_parent_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_persist_parent_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_rollback_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_rollback_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_save_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_save_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_touch_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_touch_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_update_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_update_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_upsert_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_upsert_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_validate_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_validate_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _run_validation_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _run_validation_callbacks!(&block); end

  # source://mongoid//lib/mongoid.rb#155
  def _save_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _touch_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _update_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _upsert_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _validate_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _validation_callbacks; end

  # source://mongoid//lib/mongoid.rb#155
  def _validators; end

  # source://mongoid//lib/mongoid.rb#155
  def _validators?; end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_associations; end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_associations=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_associations?; end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_fields; end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_fields=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def aliased_fields?; end

  # source://mongoid//lib/mongoid.rb#155
  def before_callback_halted; end

  # source://mongoid//lib/mongoid.rb#155
  def before_callback_halted=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def cache_timestamp_format; end

  # source://mongoid//lib/mongoid.rb#155
  def cyclic; end

  # source://mongoid//lib/mongoid.rb#155
  def cyclic=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def cyclic?; end

  # source://mongoid//lib/mongoid.rb#155
  def default_scoping; end

  # source://mongoid//lib/mongoid.rb#155
  def default_scoping=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def default_scoping?; end

  # source://mongoid//lib/mongoid.rb#155
  def dependents; end

  # source://mongoid//lib/mongoid.rb#155
  def dependents=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def dependents?; end

  # source://mongoid//lib/mongoid.rb#155
  def dependents_owner; end

  # source://mongoid//lib/mongoid.rb#155
  def dependents_owner=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def dependents_owner?; end

  # source://mongoid//lib/mongoid.rb#155
  def embedded=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def embedded_relations; end

  # source://mongoid//lib/mongoid.rb#155
  def embedded_relations=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def embedded_relations?; end

  # source://mongoid//lib/mongoid.rb#155
  def encrypt_metadata; end

  # source://mongoid//lib/mongoid.rb#155
  def encrypt_metadata=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def encrypt_metadata?; end

  # source://mongoid//lib/mongoid.rb#155
  def fields; end

  # source://mongoid//lib/mongoid.rb#155
  def fields=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def fields?; end

  # source://mongoid//lib/mongoid.rb#155
  def id; end

  # source://mongoid//lib/mongoid.rb#155
  def id=(value); end

  # source://mongoid//lib/mongoid.rb#155
  def id?; end

  # source://mongoid//lib/mongoid.rb#155
  def id_before_type_cast; end

  # source://mongoid//lib/mongoid.rb#155
  def id_change; end

  # source://mongoid//lib/mongoid.rb#155
  def id_changed?(**kwargs); end

  # source://mongoid//lib/mongoid.rb#155
  def id_was; end

  # source://mongoid//lib/mongoid.rb#155
  def id_will_change!; end

  # source://mongoid//lib/mongoid.rb#155
  def include_root_in_json; end

  # source://mongoid//lib/mongoid.rb#155
  def include_root_in_json?; end

  # source://mongoid//lib/mongoid.rb#155
  def index_specifications; end

  # source://mongoid//lib/mongoid.rb#155
  def index_specifications=(val); end

  # source://mongoid//lib/mongoid.rb#155
  def localized_fields; end

  # source://mongoid//lib/mongoid.rb#155
  def localized_fields=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def localized_fields?; end

  # source://mongoid//lib/mongoid.rb#155
  def model_name(&_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def nested_attributes; end

  # source://mongoid//lib/mongoid.rb#155
  def nested_attributes=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def nested_attributes?; end

  # source://mongoid//lib/mongoid.rb#155
  def param_delimiter=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def polymorphic; end

  # source://mongoid//lib/mongoid.rb#155
  def polymorphic=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def polymorphic?; end

  # source://mongoid//lib/mongoid.rb#155
  def post_processed_defaults; end

  # source://mongoid//lib/mongoid.rb#155
  def post_processed_defaults=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def post_processed_defaults?; end

  # source://mongoid//lib/mongoid.rb#155
  def pre_processed_defaults; end

  # source://mongoid//lib/mongoid.rb#155
  def pre_processed_defaults=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def pre_processed_defaults?; end

  # source://mongoid//lib/mongoid.rb#155
  def readonly_attributes; end

  # source://mongoid//lib/mongoid.rb#155
  def readonly_attributes=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def readonly_attributes?; end

  # source://mongoid//lib/mongoid.rb#155
  def relations; end

  # source://mongoid//lib/mongoid.rb#155
  def relations=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def relations?; end

  # source://mongoid//lib/mongoid.rb#155
  def reset_id!; end

  # source://mongoid//lib/mongoid.rb#155
  def reset_id_to_default!; end

  # source://mongoid//lib/mongoid.rb#155
  def search_index_specs; end

  # source://mongoid//lib/mongoid.rb#155
  def search_index_specs=(val); end

  # source://mongoid//lib/mongoid.rb#155
  def shard_config; end

  # source://mongoid//lib/mongoid.rb#155
  def shard_config=(val); end

  # source://mongoid//lib/mongoid.rb#155
  def shard_key_fields; end

  # source://mongoid//lib/mongoid.rb#155
  def shard_key_fields=(val); end

  # source://mongoid//lib/mongoid.rb#155
  def stored_as_associations; end

  # source://mongoid//lib/mongoid.rb#155
  def stored_as_associations=(_arg0); end

  # source://mongoid//lib/mongoid.rb#155
  def stored_as_associations?; end

  class << self
    # source://mongoid//lib/mongoid.rb#155
    def __callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def __callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _build_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _build_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _commit_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _commit_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _create_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _create_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _declared_scopes; end

    # source://mongoid//lib/mongoid.rb#155
    def _declared_scopes=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _declared_scopes?; end

    # source://mongoid//lib/mongoid.rb#155
    def _destroy_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _destroy_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _find_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _find_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _initialize_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _initialize_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _persist_parent_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _persist_parent_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _rollback_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _rollback_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _save_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _save_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _touch_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _touch_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _update_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _update_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _upsert_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _upsert_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _validate_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _validate_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _validation_callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def _validation_callbacks=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _validators; end

    # source://mongoid//lib/mongoid.rb#155
    def _validators=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def _validators?; end

    # source://mongoid//lib/mongoid.rb#155
    def add_discriminator_mapping(value, klass = T.unsafe(nil)); end

    # source://mongoid//lib/mongoid.rb#155
    def after_build(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_create(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_destroy(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_find(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_initialize(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_persist_parent(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_save(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_touch(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_update(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def after_upsert(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_associations; end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_associations=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_associations?; end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_fields=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def aliased_fields?; end

    # source://mongoid//lib/mongoid.rb#155
    def around_create(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def around_destroy(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def around_persist_parent(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def around_save(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def around_update(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def around_upsert(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_create(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_destroy(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_persist_parent(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_save(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_update(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def before_upsert(*args, **options, &block); end

    # source://mongoid//lib/mongoid.rb#155
    def cache_timestamp_format; end

    # source://mongoid//lib/mongoid.rb#155
    def cache_timestamp_format=(val); end

    # source://mongoid//lib/mongoid.rb#155
    def cyclic; end

    # source://mongoid//lib/mongoid.rb#155
    def cyclic=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def cyclic?; end

    # source://mongoid//lib/mongoid.rb#155
    def default_scoping; end

    # source://mongoid//lib/mongoid.rb#155
    def default_scoping=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def default_scoping?; end

    # source://mongoid//lib/mongoid.rb#155
    def dependents; end

    # source://mongoid//lib/mongoid.rb#155
    def dependents=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def dependents?; end

    # source://mongoid//lib/mongoid.rb#155
    def dependents_owner; end

    # source://mongoid//lib/mongoid.rb#155
    def dependents_owner=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def dependents_owner?; end

    # source://mongoid//lib/mongoid.rb#155
    def discriminator_key(*_arg0, **_arg1, &_arg2); end

    # source://mongoid//lib/mongoid.rb#155
    def discriminator_key=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def discriminator_key?; end

    # source://mongoid//lib/mongoid.rb#155
    def discriminator_mapping; end

    # source://mongoid//lib/mongoid.rb#155
    def discriminator_mapping=(_arg0); end

    # source://mongoid//lib/mongoid.rb#155
    def embedded; end

    # source://mongoid//lib/mongoid.rb#155
    def embedded=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def embedded?; end

    # source://mongoid//lib/mongoid.rb#155
    def embedded_relations; end

    # source://mongoid//lib/mongoid.rb#155
    def embedded_relations=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def embedded_relations?; end

    # source://mongoid//lib/mongoid.rb#155
    def encrypt_metadata; end

    # source://mongoid//lib/mongoid.rb#155
    def encrypt_metadata=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def encrypt_metadata?; end

    # source://mongoid//lib/mongoid.rb#155
    def fields; end

    # source://mongoid//lib/mongoid.rb#155
    def fields=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def fields?; end

    # source://mongoid//lib/mongoid.rb#155
    def get_discriminator_mapping(value); end

    # source://mongoid//lib/mongoid.rb#155
    def include_root_in_json; end

    # source://mongoid//lib/mongoid.rb#155
    def include_root_in_json=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def include_root_in_json?; end

    # source://mongoid//lib/mongoid.rb#155
    def index_specifications; end

    # source://mongoid//lib/mongoid.rb#155
    def index_specifications=(val); end

    # source://mongoid//lib/mongoid.rb#155
    def localized_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def localized_fields=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def localized_fields?; end

    # source://mongoid//lib/mongoid.rb#155
    def nested_attributes; end

    # source://mongoid//lib/mongoid.rb#155
    def nested_attributes=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def nested_attributes?; end

    # source://mongoid//lib/mongoid.rb#155
    def param_delimiter; end

    # source://mongoid//lib/mongoid.rb#155
    def param_delimiter=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def param_delimiter?; end

    # source://mongoid//lib/mongoid.rb#155
    def polymorphic; end

    # source://mongoid//lib/mongoid.rb#155
    def polymorphic=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def polymorphic?; end

    # source://mongoid//lib/mongoid.rb#155
    def post_processed_defaults; end

    # source://mongoid//lib/mongoid.rb#155
    def post_processed_defaults=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def post_processed_defaults?; end

    # source://mongoid//lib/mongoid.rb#155
    def pre_processed_defaults; end

    # source://mongoid//lib/mongoid.rb#155
    def pre_processed_defaults=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def pre_processed_defaults?; end

    # source://mongoid//lib/mongoid.rb#155
    def readonly_attributes; end

    # source://mongoid//lib/mongoid.rb#155
    def readonly_attributes=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def readonly_attributes?; end

    # source://mongoid//lib/mongoid.rb#155
    def relations; end

    # source://mongoid//lib/mongoid.rb#155
    def relations=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def relations?; end

    # source://mongoid//lib/mongoid.rb#155
    def search_index_specs; end

    # source://mongoid//lib/mongoid.rb#155
    def search_index_specs=(val); end

    # source://mongoid//lib/mongoid.rb#155
    def shard_config; end

    # source://mongoid//lib/mongoid.rb#155
    def shard_config=(val); end

    # source://mongoid//lib/mongoid.rb#155
    def shard_key_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def shard_key_fields=(val); end

    # source://mongoid//lib/mongoid.rb#155
    def storage_options; end

    # source://mongoid//lib/mongoid.rb#155
    def storage_options=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def storage_options?; end

    # source://mongoid//lib/mongoid.rb#155
    def stored_as_associations; end

    # source://mongoid//lib/mongoid.rb#155
    def stored_as_associations=(value); end

    # source://mongoid//lib/mongoid.rb#155
    def stored_as_associations?; end

    private

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr___callbacks; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr___callbacks=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr__declared_scopes; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr__declared_scopes=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr__validators; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr__validators=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_aliased_associations; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_aliased_associations=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_aliased_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_aliased_fields=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_cyclic; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_cyclic=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_default_scoping; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_default_scoping=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_dependents; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_dependents=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_dependents_owner; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_dependents_owner=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_discriminator_key; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_discriminator_key=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_embedded; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_embedded=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_embedded_relations; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_embedded_relations=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_encrypt_metadata; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_encrypt_metadata=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_fields=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_include_root_in_json; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_include_root_in_json=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_localized_fields; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_localized_fields=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_nested_attributes; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_nested_attributes=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_param_delimiter; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_param_delimiter=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_polymorphic; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_polymorphic=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_post_processed_defaults; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_post_processed_defaults=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_pre_processed_defaults; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_pre_processed_defaults=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_readonly_attributes; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_readonly_attributes=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_relations; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_relations=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_storage_options; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_storage_options=(new_value); end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_stored_as_associations; end

    # source://mongoid//lib/mongoid.rb#155
    def __class_attr_stored_as_associations=(new_value); end
  end
end

# Implements the "identify_as" interface (for specifying type aliases
# for document classes).
#
# source://mongoid//lib/mongoid/identifiable.rb#8
module Mongoid::Identifiable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Identifiable::ClassMethods
end

module Mongoid::Identifiable::ClassMethods
  # source://mongoid//lib/mongoid/identifiable.rb#23
  def identify_as(*aliases, resolver: T.unsafe(nil)); end
end

# Encapsulates behavior around defining indexes.
#
# source://mongoid//lib/mongoid/indexable/specification.rb#5
module Mongoid::Indexable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Indexable::ClassMethods
end

# source://mongoid//lib/mongoid/indexable.rb#19
module Mongoid::Indexable::ClassMethods
  # Add the default indexes to the root document if they do not already
  # exist. Currently this is only _type.
  #
  # @example Add Mongoid internal indexes.
  #   Person.add_indexes
  # @return [true] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/indexable.rb#76
  def add_indexes; end

  # Send the actual index creation comments to the MongoDB driver
  #
  # @example Create the indexes for the class.
  #   Person.create_indexes
  # @return [true] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/indexable.rb#27
  def create_indexes; end

  # Adds an index definition for the provided single or compound keys.
  #
  # @example Create a basic index.
  #   class Person
  #   include Mongoid::Document
  #   field :name, type: String
  #   index({ name: 1 }, { background: true })
  #   end
  # @param options [Hash] The index options.
  # @param spec [Hash] The index spec.
  # @return [Hash] The index options.
  #
  # source://mongoid//lib/mongoid/indexable.rb#96
  def index(spec, options = T.unsafe(nil)); end

  # Get an index specification for the provided key.
  #
  # @example Get the index specification.
  #   Model.index_specification(name: 1)
  # @param index_hash [Hash] The index key/direction pair.
  # @param index_name [String] The index name.
  # @return [Specification] The found specification.
  #
  # source://mongoid//lib/mongoid/indexable.rb#112
  def index_specification(index_hash, index_name = T.unsafe(nil)); end

  # Send the actual index removal comments to the MongoDB driver,
  # but lets _id untouched.
  #
  # @example Remove the indexes for the class.
  #   Person.remove_indexes
  # @return [true] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/indexable.rb#51
  def remove_indexes; end

  private

  # Gets a list of index specification keys.
  #
  # @api private
  # @example Get the specification key list.
  #   Model.index_keys
  # @return [Array<Hash>] The specification keys.
  #
  # source://mongoid//lib/mongoid/indexable.rb#144
  def index_keys; end

  # Get the names of all databases for this model that have index
  # definitions.
  #
  # @api private
  # @example Get the indexed database names.
  #   Model.indexed_database_names
  # @return [Array<String>] The names.
  #
  # source://mongoid//lib/mongoid/indexable.rb#130
  def indexed_database_names; end
end

# Encapsulates behavior around an index specification.
#
# source://mongoid//lib/mongoid/indexable/specification.rb#8
class Mongoid::Indexable::Specification
  # Instantiate a new index specification.
  #
  # @example Create the new specification.
  #   Specification.new(Band, { name: 1 }, background: true)
  # @param key [Hash] The hash of name/direction pairs.
  # @param klass [Class] The class the index is defined on.
  # @param opts [Hash] the index options.
  # @return [Specification] a new instance of Specification
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#44
  def initialize(klass, key, opts = T.unsafe(nil)); end

  # Is this index specification equal to another?
  #
  # @example Check equality of the specifications.
  #   specification == other
  # @param other [Specification] The spec to compare against.
  # @return [true | false] If the specs are equal.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#32
  def ==(other); end

  # Returns the value of attribute fields.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#22
  def fields; end

  # @return [Hash] The index key.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#22
  def key; end

  # @return [Class] The class the index is defined on.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#22
  def klass; end

  # Get the index name, generated using the index key.
  #
  # @example Get the index name.
  #   specification.name
  # @return [String] name The index name.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#59
  def name; end

  # Returns the value of attribute options.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#22
  def options; end

  private

  # Normalize the spec in-place, in case aliased fields are provided.
  #
  # @api private
  # @example Normalize the spec in-place.
  #   specification.normalize_aliases!(name: 1)
  # @param spec [Hash] The index specification.
  # @return [Hash] The normalized specification.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#77
  def normalize_aliases!(spec); end

  # Normalize the index options in-place. Performs deep normalization
  # on options which have a fields hash value.
  #
  # @api private
  # @example Normalize the index options in-place.
  #   specification.normalize_options!(unique: true)
  # @param options [Hash] The index options.
  # @return [Hash] The normalized options.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#96
  def normalize_options!(options); end

  # Recursively normalizes the nested elements of an options hash in-place,
  # to account for $and operator (and other potential $-prefixed operators
  # which may be supported by MongoDB in the future.)
  #
  # @api private
  # @example Recursively normalize the index options in-place.
  #   opts = { '$and' => [{ name: { '$eq' => 'Bob' } },
  #   { age: { '$gte' => 20 } }] }
  #   specification.recursive_normalize_conditionals!(opts)
  # @param options [Hash | Array | Object] The index options.
  # @return [Hash | Array | Object] The normalized options.
  #
  # source://mongoid//lib/mongoid/indexable/specification.rb#124
  def recursive_normalize_conditionals!(options); end
end

# The mappings of nice Ruby-style names to the corresponding driver
# option name.
#
# source://mongoid//lib/mongoid/indexable/specification.rb#12
Mongoid::Indexable::Specification::MAPPINGS = T.let(T.unsafe(nil), Hash)

# source://mongoid//lib/mongoid/indexable/validators/options.rb#6
module Mongoid::Indexable::Validators; end

# Validates the options passed to the index macro.
#
# source://mongoid//lib/mongoid/indexable/validators/options.rb#9
module Mongoid::Indexable::Validators::Options
  extend ::Mongoid::Indexable::Validators::Options

  # Validate the index specification.
  #
  # @example Validate the index spec.
  #   Options.validate(Band, name: 1)
  # @param klass [Class] The model class.
  # @param options [Hash] The index options.
  # @param spec [Hash] The index specification.
  # @raise [Errors::InvalidIndex] If validation failed.
  #
  # source://mongoid//lib/mongoid/indexable/validators/options.rb#56
  def validate(klass, spec, options); end

  private

  # Validates the options of the index spec.
  #
  # @api private
  # @example Validate the options.
  #   Options.validate_options(Band, name: 1)
  # @param klass [Class] The model class.
  # @param options [Hash] The index options.
  # @param spec [Hash] The index specification.
  # @raise [Errors::InvalidIndex] If validation failed.
  #
  # source://mongoid//lib/mongoid/indexable/validators/options.rb#75
  def validate_options(klass, spec, options); end

  # Validates the index spec.
  #
  # @api private
  # @example Validate the spec.
  #   Options.validate_spec(Band, name: 1)
  # @param klass [Class] The model class.
  # @param options [Hash] The index options.
  # @param spec [Hash] The index specification.
  # @raise [Errors::InvalidIndex] If validation failed.
  #
  # source://mongoid//lib/mongoid/indexable/validators/options.rb#95
  def validate_spec(klass, spec, options); end
end

# source://mongoid//lib/mongoid/indexable/validators/options.rb#12
Mongoid::Indexable::Validators::Options::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# source://mongoid//lib/mongoid/indexable/validators/options.rb#36
Mongoid::Indexable::Validators::Options::VALID_TYPES = T.let(T.unsafe(nil), Array)

# Contains the behavior around inspecting documents via inspect.
#
# source://mongoid//lib/mongoid/inspectable.rb#7
module Mongoid::Inspectable
  # Returns the class name plus its attributes. If using dynamic fields will
  # include those as well.
  #
  # @example Inspect the document.
  #   person.inspect
  # @return [String] A nice pretty string to look at.
  #
  # source://mongoid//lib/mongoid/inspectable.rb#16
  def inspect; end

  # This pretty prints the same information as the inspect method. This is
  # meant to be called by the standard 'pp' library.
  #
  # @api private
  # @example Pretty print the document.
  #   person.pretty_inspect
  # @param pretty_printer [PP] The pretty printer.
  #
  # source://mongoid//lib/mongoid/inspectable.rb#31
  def pretty_print(pretty_printer); end

  private

  # Get an array of inspected dynamic fields for the document.
  #
  # @api private
  # @example Inspect the dynamic fields.
  #   document.inspect_dynamic_fields
  # @return [String] An array of pretty printed dynamic field values.
  #
  # source://mongoid//lib/mongoid/inspectable.rb#80
  def inspect_dynamic_fields; end

  # Get an array of inspected fields for the document.
  #
  # @api private
  # @example Inspect the defined fields.
  #   document.inspect_fields
  # @return [String] An array of pretty printed field values.
  #
  # source://mongoid//lib/mongoid/inspectable.rb#63
  def inspect_fields; end
end

# This module contains all the callback hooks for Mongoid.
#
# source://mongoid//lib/mongoid/interceptable.rb#7
module Mongoid::Interceptable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods

  # Execute the after callbacks.
  #
  # @param callback_list [Array<ActiveSupport::Callbacks::CallbackSequence, ActiveSupport::Callbacks::Filters::Environment>] List of
  #   pairs of callback sequence and environment.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#250
  def _mongoid_run_child_after_callbacks(callback_list: T.unsafe(nil)); end

  # Execute the before callbacks of given kind for embedded documents.
  #
  # @api private
  # @param callback_list [Array<ActiveSupport::Callbacks::CallbackSequence, ActiveSupport::Callbacks::Filters::Environment>] List of
  #   pairs of callback sequence and environment. This list will be later used
  #   to execute after callbacks in reverse order.
  # @param children [Array<Document>] Children to execute callbacks on.
  # @param kind [Symbol] The type of callback to execute.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#229
  def _mongoid_run_child_before_callbacks(kind, children: T.unsafe(nil), callback_list: T.unsafe(nil)); end

  # Run the callbacks for embedded documents.
  #
  # @api private
  # @param children [Array<Document>] Children to execute callbacks on. If
  #   nil, callbacks will be executed on all cascadable children of
  #   the document.
  # @param kind [Symbol] The type of callback to execute.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#153
  def _mongoid_run_child_callbacks(kind, children: T.unsafe(nil), &block); end

  # Execute the callbacks of given kind for embedded documents including
  # around callbacks.
  #
  # @param children [Array<Document>] Children to execute callbacks on. If
  #   nil, callbacks will be executed on all cascadable children of
  #   the document.
  #
  #   @api private
  # @param kind [Symbol] The type of callback to execute.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#174
  def _mongoid_run_child_callbacks_with_around(kind, children: T.unsafe(nil), &block); end

  # Execute the callbacks of given kind for embedded documents without
  # around callbacks.
  #
  # @api private
  # @param children [Array<Document>] Children to execute callbacks on. If
  #   nil, callbacks will be executed on all cascadable children of
  #   the document.
  # @param kind [Symbol] The type of callback to execute.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#207
  def _mongoid_run_child_callbacks_without_around(kind, children: T.unsafe(nil), &block); end

  # Is the provided type of callback executable by this document?
  #
  # @example Is the callback executable?
  #   document.callback_executable?(:save)
  # @param kind [Symbol] The type of callback.
  # @return [true | false] If the callback can be executed.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#62
  def callback_executable?(kind); end

  # Is the document currently in a state that could potentially require
  # callbacks to be executed?
  #
  # @example Is the document in a callback state?
  #   document.in_callback_state?(:update)
  # @param kind [Symbol] The callback kind.
  # @return [true | false] If the document is in a callback state.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#75
  def in_callback_state?(kind); end

  # Returns the stored callbacks to be executed later.
  #
  # @api private
  # @return [Array<Symbol>] Method symbols of the stored pending callbacks.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#262
  def pending_callbacks; end

  # Stores callbacks to be executed later. A good use case for
  # this is delaying the after_find and after_initialize callbacks until the
  # associations are set on the document. This can also be used to delay
  # applying the defaults on a document.
  #
  # @api private
  # @param value [Array<Symbol>] Method symbols of the pending callbacks to store.
  # @return [Array<Symbol>] Method symbols of the stored pending callbacks.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#276
  def pending_callbacks=(value); end

  # Run only the after callbacks for the specific event.
  #
  # @example Run only the after save callbacks.
  #   model.run_after_callbacks(:save)
  # @note ActiveSupport does not allow this type of behavior by default, so
  #   Mongoid has to get around it and implement itself.
  # @param *kinds [Symbol...] The events that are occurring.
  # @return [Object] The result of the chain executing.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#90
  def run_after_callbacks(*kinds); end

  # Run only the before callbacks for the specific event.
  #
  # @example Run only the before save callbacks.
  #   model.run_before_callbacks(:save, :create)
  # @note ActiveSupport does not allow this type of behavior by default, so
  #   Mongoid has to get around it and implement itself.
  # @param *kinds [Symbol...] The events that are occurring.
  # @return [Object] The result of the chain executing.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#107
  def run_before_callbacks(*kinds); end

  # Run the callbacks for the document. This overrides active support's
  # functionality to cascade callbacks to embedded documents that have been
  # flagged as such.
  #
  # @example Run the callbacks.
  #   run_callbacks :save do
  #   save!
  #   end
  # @param kind [Symbol] The type of callback to execute.
  # @param skip_if [Proc | nil] If this proc returns true, the callbacks
  #   will not be triggered, while the given block will be still called.
  # @param with_children [true | false] Flag specifies whether callbacks
  #   of embedded document should be run.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#127
  def run_callbacks(kind, with_children: T.unsafe(nil), skip_if: T.unsafe(nil), &block); end

  # Run the pending callbacks. If the callback is :apply_defaults, we will apply
  # the defaults for this document. Otherwise, the callback is passed to the
  # run_callbacks function.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/interceptable.rb#285
  def run_pending_callbacks; end

  private

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # @api private
  # @example Was a before callback halted?
  #   document.before_callback_halted?
  # @return [true | false] If a before callback was halted.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#307
  def before_callback_halted?; end

  # Determine if the child should fire the callback.
  #
  # @example Should the child fire the callback?
  #   document.cascadable_child?(:update, doc)
  # @param child [Document] The child document.
  # @param kind [Symbol] The type of callback.
  # @return [true | false] If the child should fire the callback.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#347
  def cascadable_child?(kind, child, association); end

  # Get all the child embedded documents that are flagged as cascadable.
  #
  # @example Get all the cascading children.
  #   document.cascadable_children(:update)
  # @param kind [Symbol] The type of callback.
  # @return [Array<Document>] The children.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#319
  def cascadable_children(kind, children = T.unsafe(nil)); end

  # Get the name of the callback that the child should fire. This changes
  # depending on whether or not the child is new. A persisted parent with a
  # new child would fire :update from the parent, but needs to fire :create
  # on the child.
  #
  # @example Get the callback type.
  #   document.child_callback_type(:update, doc)
  # @param child [Document] The child document
  # @param kind [Symbol] The type of callback.
  # @return [Symbol] The name of the callback.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#365
  def child_callback_type(kind, child); end

  # Compile the callback chain.
  #
  # This method hides the differences between ActiveSupport implementations
  # before and after 7.1.
  #
  # @param chain [ActiveSupport::Callbacks::CallbackChain] The callback chain.
  # @param type [Symbol | nil] The type of callback chain to compile.
  # @return [ActiveSupport::Callbacks::CallbackSequence] The compiled callback sequence.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#429
  def compile_callbacks(chain, type = T.unsafe(nil)); end

  # We need to hook into this for autosave, since we don't want it firing if
  # the before callbacks were halted.
  #
  # @api private
  # @example Hook into the halt.
  #   document.halted_callback_hook(filter)
  # @param filter [Symbol] The callback that halted.
  # @param name [Symbol] The name of the callback that was halted
  #   (requires Rails 6.1+)
  #
  # source://mongoid//lib/mongoid/interceptable.rb#386
  def halted_callback_hook(filter, name = T.unsafe(nil)); end

  # Run only the callbacks for the target location (before, after, around)
  # and kind (save, update, create).
  #
  # @example Run the targeted callbacks.
  #   model.run_targeted_callbacks(:before, :save)
  # @param kind [Symbol] The type of callback, :save, :create, :update.
  # @param place [Symbol] The time to run, :before, :after, :around.
  # @return [Object] The result of the chain execution.
  #
  # source://mongoid//lib/mongoid/interceptable.rb#400
  def run_targeted_callbacks(place, kind); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
  end
end

# source://mongoid//lib/mongoid/interceptable.rb#10
Mongoid::Interceptable::CALLBACKS = T.let(T.unsafe(nil), Array)

# Defines how Mongoid can autoload all defined models.
#
# source://mongoid//lib/mongoid/loadable.rb#7
module Mongoid::Loadable
  # Given a single path, returns all ruby files under that path (or, if
  # `preload_models` is a list of model names, returns only the files for
  # those named models).
  #
  # @param path [String] the path to search
  # @return [Array<String>] the normalized file names, suitable for loading
  #   via `require_dependency` or `require`.
  #
  # source://mongoid//lib/mongoid/loadable.rb#63
  def files_under_path(path); end

  # Given a list of paths, return all ruby files under that path (or, if
  # `preload_models` is a list of model names, returns only the files for
  # those named models).
  #
  # @param paths [Array<String>] the list of paths to search
  # @return [Array<String>] the normalized file names, suitable for loading
  #   via `require_dependency` or `require`.
  #
  # source://mongoid//lib/mongoid/loadable.rb#51
  def files_under_paths(paths); end

  # Returns the array of glob patterns that determine whether a given
  # path should be ignored by the model loader.
  #
  # @return [Array<String>] the array of ignore patterns
  #
  # source://mongoid//lib/mongoid/loadable.rb#115
  def ignore_patterns; end

  # Sets the ignore patterns to the given array of patterns. These are glob
  # patterns that determine whether a given path should be ignored by the
  # model loader or not.
  #
  # @param patterns [Array<String>] The list of glob patterns
  #
  # source://mongoid//lib/mongoid/loadable.rb#132
  def ignore_patterns=(patterns); end

  # Returns true if the given file path matches any of the ignore patterns.
  #
  # @param file_path [String] The file path to consider
  # @return [true | false] whether or not the given file path should be
  #   ignored.
  #
  # source://mongoid//lib/mongoid/loadable.rb#142
  def ignored?(file_path); end

  # A convenience method for loading a model's file. If Rails'
  # `require_dependency` method exists, it will be used; otherwise
  # `require` will be used.
  #
  # @api private
  # @example Load the model.
  #   Mongoid.load_model("/mongoid/behavior")
  # @param file [String] The base filename.
  #
  # source://mongoid//lib/mongoid/loadable.rb#87
  def load_model(file); end

  # Search a list of model paths to get every model and require it, so
  # that indexing and inheritance work in both development and production
  # with the same results.
  #
  # @example Load all application models from a non-standard set of paths.
  #   Mongoid.load_models(%w( ./models ./admin/models ))
  # @example Load all the application models from default model paths.
  #   Mongoid.load_models
  # @param paths [Array] The list of paths that should be looked in
  #   for model files. These must either be absolute paths, or relative to
  #   the current working directory.
  #
  # source://mongoid//lib/mongoid/loadable.rb#33
  def load_models(paths = T.unsafe(nil)); end

  # Returns the array of paths where the application's model definitions
  # are located. If Rails is loaded, this defaults to the configured
  # "app/models" paths (e.g. `config.paths["app/models"]`); otherwise, it
  # defaults to `%w(./app/models ./lib/models)`.
  #
  # Note that these paths are the *roots* of the directory hierarchies where
  # the models are located; it is not necessary to indicate every subdirectory,
  # as long as these root paths are located in `$LOAD_PATH`.
  #
  # @return [Array<String>] the array of model paths
  #
  # source://mongoid//lib/mongoid/loadable.rb#105
  def model_paths; end

  # Sets the model paths to the given array of paths. These are the paths
  # where the application's model definitions are located.
  #
  # @param paths [Array<String>] The list of model paths
  #
  # source://mongoid//lib/mongoid/loadable.rb#123
  def model_paths=(paths); end
end

# The default list of glob patterns that match paths to ignore when loading
# models. Defaults to '*/models/concerns/*', which Rails uses for extensions
# to models (and which cause errors when loaded out of order).
#
# See #ignore_patterns.
#
# source://mongoid//lib/mongoid/loadable.rb#18
Mongoid::Loadable::DEFAULT_IGNORE_PATTERNS = T.let(T.unsafe(nil), Array)

# The default list of paths where model classes should be looked for. If
# Rails is present, the "app/models" paths will be used instead.
# (See #model_paths.)
#
# source://mongoid//lib/mongoid/loadable.rb#11
Mongoid::Loadable::DEFAULT_MODEL_PATHS = T.let(T.unsafe(nil), Array)

# Contains logging behavior.
#
# source://mongoid//lib/mongoid/loggable.rb#7
module Mongoid::Loggable
  # Get the logger.
  #
  # @example Get the logger.
  #   Loggable.logger
  # @note Will try to grab Rails' logger first before creating a new logger
  #   with stderr.
  # @return [Logger] The logger.
  #
  # source://mongoid//lib/mongoid/loggable.rb#18
  def logger; end

  # Set the logger.
  #
  # @example Set the logger.
  #   Loggable.logger = Logger.new(STDERR)
  # @param logger [Logger] The logger to set.
  # @return [Logger] The new logger.
  #
  # source://mongoid//lib/mongoid/loggable.rb#31
  def logger=(logger); end

  private

  # Gets the default Mongoid logger - stderr.
  #
  # @api private
  # @example Get the default logger.
  #   Loggable.default_logger
  # @return [Logger] The default logger.
  #
  # source://mongoid//lib/mongoid/loggable.rb#45
  def default_logger; end

  # Get the Rails logger if loaded in a Rails application, otherwise nil.
  #
  # @api private
  # @example Get Rails' logger.
  #   Loggable.rails_logger
  # @return [Logger] The Rails logger.
  #
  # source://mongoid//lib/mongoid/loggable.rb#59
  def rails_logger; end
end

# The minimum MongoDB version supported.
#
# source://mongoid//lib/mongoid.rb#54
Mongoid::MONGODB_VERSION = T.let(T.unsafe(nil), String)

# This module contains all the behavior for Ruby implementations of MongoDB
# selectors.
#
# source://mongoid//lib/mongoid/matchable.rb#8
module Mongoid::Matchable
  extend ::ActiveSupport::Concern

  # Determines if this document has the attributes to match the supplied
  # MongoDB selector. Used for matching on embedded associations.
  #
  # @example Does the document match?
  #   document._matches?(:title => { "$in" => [ "test" ] })
  # @param selector [Hash] The MongoDB selector.
  # @return [true | false] True if matches, false if not.
  #
  # source://mongoid//lib/mongoid/matchable.rb#20
  def _matches?(selector); end
end

# Utility module containing methods which assist in performing
# in-memory matching of documents with MQL query expressions.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher.rb#8
module Mongoid::Matcher
  private

  # Extracts field values in the document at the specified key.
  #
  # The document can be a Hash or a model instance.
  #
  # The key is a valid MongoDB dot notation key. The following use cases are
  # supported:
  #
  # - Simple field traversal (`foo`) - retrieves the field `foo` in the
  #   current document.
  # - Hash/embedded document field traversal (`foo.bar`) - retrieves the
  #   field `foo` in the current document, then retrieves the field `bar`
  #   from the value of `foo`. Each path segment could descend into an
  #   embedded document or a hash field.
  # - Array element retrieval (`foo.N`) - retrieves the Nth array element
  #   from the field `foo` which must be an array. N must be a non-negative
  #   integer.
  # - Array traversal (`foo.bar`) - if `foo` is an array field, and
  #   the elements of `foo` are hashes or embedded documents, this returns
  #   an array of values of the `bar` field in each of the hashes in the
  #   `foo` array.
  #
  # This method can return an individual field value in some document
  # or an array of values from multiple documents. The array can be returned
  # because a field value in the specified path is an array of primitive
  # values (e.g. integers) or because a field value in the specified path
  # is an array of documents (e.g. a one-to-many embedded association),
  # in which case the leaf value may be a scalar for each individual document.
  # If the leaf value is an array and a one-to-many association was traversed,
  # the return value will be an array of arrays. Note that an individual
  # field value can also be an array and this case is indistinguishable
  # from and behaves identically to association traversal for the purposes
  # of, for example, subsequent array element retrieval.
  #
  # @api private
  # @param document [Document | Hash | String] The document to extract from.
  # @param key [String] The key path to extract.
  # @return [Object | Array] Field value or values.
  #
  # source://mongoid//lib/mongoid/matcher.rb#46
  def extract_attribute(document, key); end

  # Indifferent string or symbol key lookup, returning the exact key.
  #
  # @api private
  # @param hash [Hash] The input hash.
  # @param key [String | Symbol] The key to perform indifferent lookups with.
  # @return [String | Symbol | nil] The exact key (with the correct type) that exists in the hash, or nil if the key does not exist.
  #
  # source://mongoid//lib/mongoid/matcher.rb#108
  def find_exact_key(hash, key); end

  class << self
    # Extracts field values in the document at the specified key.
    #
    # The document can be a Hash or a model instance.
    #
    # The key is a valid MongoDB dot notation key. The following use cases are
    # supported:
    #
    # - Simple field traversal (`foo`) - retrieves the field `foo` in the
    #   current document.
    # - Hash/embedded document field traversal (`foo.bar`) - retrieves the
    #   field `foo` in the current document, then retrieves the field `bar`
    #   from the value of `foo`. Each path segment could descend into an
    #   embedded document or a hash field.
    # - Array element retrieval (`foo.N`) - retrieves the Nth array element
    #   from the field `foo` which must be an array. N must be a non-negative
    #   integer.
    # - Array traversal (`foo.bar`) - if `foo` is an array field, and
    #   the elements of `foo` are hashes or embedded documents, this returns
    #   an array of values of the `bar` field in each of the hashes in the
    #   `foo` array.
    #
    # This method can return an individual field value in some document
    # or an array of values from multiple documents. The array can be returned
    # because a field value in the specified path is an array of primitive
    # values (e.g. integers) or because a field value in the specified path
    # is an array of documents (e.g. a one-to-many embedded association),
    # in which case the leaf value may be a scalar for each individual document.
    # If the leaf value is an array and a one-to-many association was traversed,
    # the return value will be an array of arrays. Note that an individual
    # field value can also be an array and this case is indistinguishable
    # from and behaves identically to association traversal for the purposes
    # of, for example, subsequent array element retrieval.
    #
    # @api private
    # @param document [Document | Hash | String] The document to extract from.
    # @param key [String] The key path to extract.
    # @return [Object | Array] Field value or values.
    #
    # source://mongoid//lib/mongoid/matcher.rb#46
    def extract_attribute(document, key); end

    # Indifferent string or symbol key lookup, returning the exact key.
    #
    # @api private
    # @param hash [Hash] The input hash.
    # @param key [String | Symbol] The key to perform indifferent lookups with.
    # @return [String | Symbol | nil] The exact key (with the correct type) that exists in the hash, or nil if the key does not exist.
    #
    # source://mongoid//lib/mongoid/matcher.rb#108
    def find_exact_key(hash, key); end
  end
end

# In-memory matcher for $all expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/all/
#
# source://mongoid//lib/mongoid/matcher/all.rb#10
module Mongoid::Matcher::All
  private

  # Returns whether a value satisfies an $all expression.
  #
  # @api private
  # @api private
  # @param condition [Array<Object>] The $all condition predicate.
  # @param exists [true | false] Not used.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/all.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $all expression.
    #
    # @api private
    # @api private
    # @param condition [Array<Object>] The $all condition predicate.
    # @param exists [true | false] Not used.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/all.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $and expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/and/
#
# source://mongoid//lib/mongoid/matcher/and.rb#10
module Mongoid::Matcher::And
  private

  # Returns whether a document satisfies an $and expression.
  #
  # @api private
  # @api private
  # @param document [Mongoid::Document] The document.
  # @param expr [Array<Hash>] The $and conditions.
  # @return [true | false] Whether the document matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/and.rb#20
  def matches?(document, expr); end

  class << self
    # Returns whether a document satisfies an $and expression.
    #
    # @api private
    # @api private
    # @param document [Mongoid::Document] The document.
    # @param expr [Array<Hash>] The $and conditions.
    # @return [true | false] Whether the document matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/and.rb#20
    def matches?(document, expr); end
  end
end

# Mixin module included in bitwise expression matchers.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/bits.rb#8
module Mongoid::Matcher::Bits
  # Returns whether a value satisfies a bitwise expression.
  #
  # @api private
  # @param condition [Numeric | Array<Numeric>] The expression
  #   predicate as a bitmask or position list.
  # @param exists [true | false] Not used.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits.rb#20
  def matches?(exists, value, condition); end

  private

  # Returns the name of the expression operator.
  #
  # @api private
  # @api private
  # @return [String] The operator name.
  #
  # source://mongoid//lib/mongoid/matcher/bits.rb#55
  def operator_name; end

  class << self
    # Returns the name of the expression operator.
    #
    # @api private
    # @api private
    # @return [String] The operator name.
    #
    # source://mongoid//lib/mongoid/matcher/bits.rb#55
    def operator_name; end
  end
end

# In-memory matcher for $bitsAllClear expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/bitsAllClear/
#
# source://mongoid//lib/mongoid/matcher/bits_all_clear.rb#10
module Mongoid::Matcher::BitsAllClear
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAllClear

  # Returns whether a position list condition matches a value.
  #
  # @api private
  # @param condition [Array<Numeric>] The position list condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_all_clear.rb#22
  def array_matches?(value, condition); end

  # Returns whether a bitmask condition matches a value.
  #
  # @api private
  # @param condition [Numeric] The bitmask condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_all_clear.rb#36
  def int_matches?(value, condition); end
end

# In-memory matcher for $bitsAllSet expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/bitsAllSet/
#
# source://mongoid//lib/mongoid/matcher/bits_all_set.rb#10
module Mongoid::Matcher::BitsAllSet
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAllSet

  # Returns whether a position list condition matches a value.
  #
  # @api private
  # @param condition [Array<Numeric>] The position list condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_all_set.rb#22
  def array_matches?(value, condition); end

  # Returns whether a bitmask condition matches a value.
  #
  # @api private
  # @param condition [Numeric] The bitmask condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_all_set.rb#36
  def int_matches?(value, condition); end
end

# In-memory matcher for $bitsAnyClear expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/bitsAnyClear/
#
# source://mongoid//lib/mongoid/matcher/bits_any_clear.rb#10
module Mongoid::Matcher::BitsAnyClear
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAnyClear

  # Returns whether a position list condition matches a value.
  #
  # @api private
  # @param condition [Array<Numeric>] The position list condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_any_clear.rb#22
  def array_matches?(value, condition); end

  # Returns whether a bitmask condition matches a value.
  #
  # @api private
  # @param condition [Numeric] The bitmask condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_any_clear.rb#36
  def int_matches?(value, condition); end
end

# In-memory matcher for $bitsAnySet expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/bitsAnySet/
#
# source://mongoid//lib/mongoid/matcher/bits_any_set.rb#10
module Mongoid::Matcher::BitsAnySet
  include ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::Bits
  extend ::Mongoid::Matcher::BitsAnySet

  # Returns whether a position list condition matches a value.
  #
  # @api private
  # @param condition [Array<Numeric>] The position list condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_any_set.rb#22
  def array_matches?(value, condition); end

  # Returns whether a bitmask condition matches a value.
  #
  # @api private
  # @param condition [Numeric] The bitmask condition.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  #
  # source://mongoid//lib/mongoid/matcher/bits_any_set.rb#36
  def int_matches?(value, condition); end
end

# In-memory matcher for $elemMatch expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/elemMatch/
#
# source://mongoid//lib/mongoid/matcher/elem_match.rb#10
module Mongoid::Matcher::ElemMatch
  private

  # Returns whether a value satisfies an $elemMatch expression.
  #
  # @api private
  # @api private
  # @param exists [true | false] Not used.
  # @param expr [Hash] The $elemMatch condition predicate.
  # @param value [Object | Array<Object>] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/elem_match.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $elemMatch expression.
    #
    # @api private
    # @api private
    # @param exists [true | false] Not used.
    # @param expr [Hash] The $elemMatch condition predicate.
    # @param value [Object | Array<Object>] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/elem_match.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher used to evaluate whether an $elemMatch predicate
# matches and individual document. The $elemMatch predicate can be a
# logical expressions including $and, $or, $nor, and $not. $not can
# also have a regular expression predicate.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/elem_match_expression.rb#11
module Mongoid::Matcher::ElemMatchExpression
  private

  # Returns whether a document satisfies an $elemMatch expression.
  #
  # @api private
  # @api private
  # @param document [Mongoid::Document] The document.
  # @param expr [Hash] The $elemMatch condition predicate.
  # @return [true | false] Whether the document matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/elem_match_expression.rb#21
  def matches?(document, expr); end

  class << self
    # Returns whether a document satisfies an $elemMatch expression.
    #
    # @api private
    # @api private
    # @param document [Mongoid::Document] The document.
    # @param expr [Hash] The $elemMatch condition predicate.
    # @return [true | false] Whether the document matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/elem_match_expression.rb#21
    def matches?(document, expr); end
  end
end

# In-memory matcher for $eq expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/eq/
#
# source://mongoid//lib/mongoid/matcher/eq.rb#10
module Mongoid::Matcher::Eq
  private

  # Returns whether a value satisfies an $eq expression.
  #
  # @api private
  # @api private
  # @param exists [true | false] Whether the value exists.
  # @param expr [Hash] The $eq condition predicate.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/eq.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $eq expression.
    #
    # @api private
    # @api private
    # @param exists [true | false] Whether the value exists.
    # @param expr [Hash] The $eq condition predicate.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/eq.rb#21
    def matches?(exists, value, condition); end
  end
end

# This module is used by $eq and other operators that need to perform
# the matching that $eq performs (for example, $ne which negates the result
# of $eq). Unlike $eq this module takes an original operator as an
# additional argument to +matches?+ to provide the correct exception
# messages reflecting the operator that was first invoked.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/eq_impl.rb#12
module Mongoid::Matcher::EqImpl
  private

  # Returns whether a value satisfies an $eq (or similar) expression.
  #
  # @api private
  # @api private
  # @param condition [Object | Range] The equality condition predicate.
  # @param exists [true | false] Not used.
  # @param original_operator [String] Operator to use in exception messages.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/eq_impl.rb#24
  def matches?(exists, value, condition, original_operator); end

  # Per https://www.mongodb.com/docs/ruby-driver/current/tutorials/bson-v4/#time-instances,
  # > Times in BSON (and MongoDB) can only have millisecond precision. When Ruby Time instances
  # are serialized to BSON or Extended JSON, the times are floored to the nearest millisecond.
  #
  # > Because of this flooring, applications are strongly recommended to perform all time
  # calculations using integer math, as inexactness of floating point calculations may produce
  # unexpected results.
  #
  # As such, perform a similar operation to what the bson-ruby gem does.
  #
  # @api private
  # @param time_a [Time] The first time value.
  # @param time_b [Time] The second time value.
  # @return [true | false] Whether the two times are equal to the millisecond.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/eq_impl.rb#70
  def time_eq?(time_a, time_b); end

  # Rounds a time value to nearest millisecond.
  #
  # @api private
  # @param time [Time] The time value.
  # @return [true | false] The time rounded to the millisecond.
  #
  # source://mongoid//lib/mongoid/matcher/eq_impl.rb#79
  def time_rounded_to_millis(time); end

  class << self
    # Returns whether a value satisfies an $eq (or similar) expression.
    #
    # @api private
    # @api private
    # @param condition [Object | Range] The equality condition predicate.
    # @param exists [true | false] Not used.
    # @param original_operator [String] Operator to use in exception messages.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/eq_impl.rb#24
    def matches?(exists, value, condition, original_operator); end

    # Per https://www.mongodb.com/docs/ruby-driver/current/tutorials/bson-v4/#time-instances,
    # > Times in BSON (and MongoDB) can only have millisecond precision. When Ruby Time instances
    # are serialized to BSON or Extended JSON, the times are floored to the nearest millisecond.
    #
    # > Because of this flooring, applications are strongly recommended to perform all time
    # calculations using integer math, as inexactness of floating point calculations may produce
    # unexpected results.
    #
    # As such, perform a similar operation to what the bson-ruby gem does.
    #
    # @api private
    # @param time_a [Time] The first time value.
    # @param time_b [Time] The second time value.
    # @return [true | false] Whether the two times are equal to the millisecond.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/eq_impl.rb#70
    def time_eq?(time_a, time_b); end

    # Rounds a time value to nearest millisecond.
    #
    # @api private
    # @param time [Time] The time value.
    # @return [true | false] The time rounded to the millisecond.
    #
    # source://mongoid//lib/mongoid/matcher/eq_impl.rb#79
    def time_rounded_to_millis(time); end
  end
end

# This is an internal equality implementation that performs exact
# comparisons and regular expression matches.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/eq_impl_with_regexp.rb#9
module Mongoid::Matcher::EqImplWithRegexp
  private

  # Returns whether a value satisfies an $eq (or similar) expression,
  # performing a regular expression match if the condition is a regular
  # expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The equality condition predicate.
  # @param original_operator [String] Not used.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/eq_impl_with_regexp.rb#22
  def matches?(original_operator, value, condition); end

  class << self
    # Returns whether a value satisfies an $eq (or similar) expression,
    # performing a regular expression match if the condition is a regular
    # expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The equality condition predicate.
    # @param original_operator [String] Not used.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/eq_impl_with_regexp.rb#22
    def matches?(original_operator, value, condition); end
  end
end

# In-memory matcher for $exists expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/exists/
#
# source://mongoid//lib/mongoid/matcher/exists.rb#10
module Mongoid::Matcher::Exists
  private

  # Returns whether an $exists expression is satisfied.
  #
  # @api private
  # @api private
  # @param condition [true | false] The $exists condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] Not used.
  # @return [true | false] Whether the existence condition is met.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/exists.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether an $exists expression is satisfied.
    #
    # @api private
    # @api private
    # @param condition [true | false] The $exists condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] Not used.
    # @return [true | false] Whether the existence condition is met.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/exists.rb#21
    def matches?(exists, value, condition); end
  end
end

# Base singleton module used for evaluating whether a given
# document in-memory matches an MSQL query expression.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/expression.rb#9
module Mongoid::Matcher::Expression
  private

  # Returns whether a document satisfies a query expression.
  #
  # @api private
  # @api private
  # @param document [Mongoid::Document] The document.
  # @param expr [Hash] The expression.
  # @return [true | false] Whether the document matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/expression.rb#19
  def matches?(document, expr); end

  class << self
    # Returns whether a document satisfies a query expression.
    #
    # @api private
    # @api private
    # @param document [Mongoid::Document] The document.
    # @param expr [Hash] The expression.
    # @return [true | false] Whether the document matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/expression.rb#19
    def matches?(document, expr); end
  end
end

# Singleton module provides lookup of logical query operator
# matchers.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/expression_operator.rb#9
module Mongoid::Matcher::ExpressionOperator
  private

  # Returns the matcher module for a given operator.
  #
  # @api private
  # @api private
  # @param op [String] The operator name.
  # @return [Module] The matcher module.
  #
  # source://mongoid//lib/mongoid/matcher/expression_operator.rb#26
  def get(op); end

  class << self
    # Returns the matcher module for a given operator.
    #
    # @api private
    # @api private
    # @param op [String] The operator name.
    # @return [Module] The matcher module.
    #
    # source://mongoid//lib/mongoid/matcher/expression_operator.rb#26
    def get(op); end
  end
end

# @api private
#
# source://mongoid//lib/mongoid/matcher/expression_operator.rb#10
Mongoid::Matcher::ExpressionOperator::MAP = T.let(T.unsafe(nil), Hash)

# Singleton module used for evaluating whether a given
# value in-memory matches an MSQL query expression related
# to a specific field.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/field_expression.rb#10
module Mongoid::Matcher::FieldExpression
  private

  # Returns whether a value satisfies a condition.
  #
  # @api private
  # @api private
  # @param condition [Hash | Object] The condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/field_expression.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a condition.
    #
    # @api private
    # @api private
    # @param condition [Hash | Object] The condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/field_expression.rb#21
    def matches?(exists, value, condition); end
  end
end

# Singleton module provides lookup of query operator matchers
# related to field values.
#
# @api private
#
# source://mongoid//lib/mongoid/matcher/field_operator.rb#9
module Mongoid::Matcher::FieldOperator
  private

  # Used for evaluating $lt, $lte, $gt, $gte comparison operators.
  #
  # @api private
  # @api private
  # @todo Refactor this as it is only relevant to $lt, $lte, $gt, $gte.
  #
  # source://mongoid//lib/mongoid/matcher/field_operator.rb#54
  def apply_array_field_operator(exists, value, condition); end

  # Used for evaluating $lt, $lte, $gt, $gte comparison operators.
  #
  # @api private
  # @api private
  # @todo Refactor this as it is only relevant to $lt, $lte, $gt, $gte.
  #
  # source://mongoid//lib/mongoid/matcher/field_operator.rb#67
  def apply_comparison_operator(operator, left, right); end

  # Returns the matcher module for a given operator.
  #
  # @api private
  # @api private
  # @param op [String] The operator name.
  # @return [Module] The matcher module.
  #
  # source://mongoid//lib/mongoid/matcher/field_operator.rb#43
  def get(op); end

  class << self
    # Used for evaluating $lt, $lte, $gt, $gte comparison operators.
    #
    # @api private
    # @api private
    # @todo Refactor this as it is only relevant to $lt, $lte, $gt, $gte.
    #
    # source://mongoid//lib/mongoid/matcher/field_operator.rb#54
    def apply_array_field_operator(exists, value, condition); end

    # Used for evaluating $lt, $lte, $gt, $gte comparison operators.
    #
    # @api private
    # @api private
    # @todo Refactor this as it is only relevant to $lt, $lte, $gt, $gte.
    #
    # source://mongoid//lib/mongoid/matcher/field_operator.rb#67
    def apply_comparison_operator(operator, left, right); end

    # Returns the matcher module for a given operator.
    #
    # @api private
    # @api private
    # @param op [String] The operator name.
    # @return [Module] The matcher module.
    #
    # source://mongoid//lib/mongoid/matcher/field_operator.rb#43
    def get(op); end
  end
end

# @api private
#
# source://mongoid//lib/mongoid/matcher/field_operator.rb#10
Mongoid::Matcher::FieldOperator::MAP = T.let(T.unsafe(nil), Hash)

# In-memory matcher for $gt expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/gt/
#
# source://mongoid//lib/mongoid/matcher/gt.rb#10
module Mongoid::Matcher::Gt
  private

  # Returns whether a value satisfies a $gt expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The $gt condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/gt.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $gt expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The $gt condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/gt.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $gte expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/gte/
#
# source://mongoid//lib/mongoid/matcher/gte.rb#10
module Mongoid::Matcher::Gte
  private

  # Returns whether a value satisfies a $gte expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The $gte condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/gte.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $gte expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The $gte condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/gte.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $in expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/in/
#
# source://mongoid//lib/mongoid/matcher/in.rb#10
module Mongoid::Matcher::In
  private

  # Returns whether a value satisfies an $in expression.
  #
  # @api private
  # @api private
  # @param condition [Array<Object>] The $in condition predicate.
  # @param exists [true | false] Not used.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/in.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $in expression.
    #
    # @api private
    # @api private
    # @param condition [Array<Object>] The $in condition predicate.
    # @param exists [true | false] Not used.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/in.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $lt expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/lt/
#
# source://mongoid//lib/mongoid/matcher/lt.rb#10
module Mongoid::Matcher::Lt
  private

  # Returns whether a value satisfies a $lt expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The $lt condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/lt.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $lt expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The $lt condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/lt.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $lte expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/lte/
#
# source://mongoid//lib/mongoid/matcher/lte.rb#10
module Mongoid::Matcher::Lte
  private

  # Returns whether a value satisfies a $lte expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The $lte condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/lte.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $lte expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The $lte condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/lte.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $mod expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/mod/
#
# source://mongoid//lib/mongoid/matcher/mod.rb#10
module Mongoid::Matcher::Mod
  private

  # Returns whether a value satisfies a $mod expression.
  #
  # @api private
  # @api private
  # @param condition [Array<Numeric>] The $mod condition predicate,
  #   which is a 2-tuple containing the divisor and remainder.
  # @param exists [true | false] Not used.
  # @param value [Numeric] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/mod.rb#22
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $mod expression.
    #
    # @api private
    # @api private
    # @param condition [Array<Numeric>] The $mod condition predicate,
    #   which is a 2-tuple containing the divisor and remainder.
    # @param exists [true | false] Not used.
    # @param value [Numeric] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/mod.rb#22
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $ne expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/ne/
#
# source://mongoid//lib/mongoid/matcher/ne.rb#10
module Mongoid::Matcher::Ne
  private

  # Returns whether a value satisfies an $ne expression.
  #
  # @api private
  # @api private
  # @param condition [Object] The $ne condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/ne.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $ne expression.
    #
    # @api private
    # @api private
    # @param condition [Object] The $ne condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/ne.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $nin expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/nin/
#
# source://mongoid//lib/mongoid/matcher/nin.rb#10
module Mongoid::Matcher::Nin
  private

  # Returns whether a value satisfies a $nin expression.
  #
  # @api private
  # @api private
  # @param condition [Array<Object>] The $nin condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/nin.rb#21
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $nin expression.
    #
    # @api private
    # @api private
    # @param condition [Array<Object>] The $nin condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/nin.rb#21
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $nor expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/nor/
#
# source://mongoid//lib/mongoid/matcher/nor.rb#10
module Mongoid::Matcher::Nor
  private

  # Returns whether a document satisfies a $nor expression.
  #
  # @api private
  # @api private
  # @param document [Mongoid::Document] The document.
  # @param expr [Array<Hash>] The $nor conditions.
  # @return [true | false] Whether the document matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/nor.rb#20
  def matches?(document, expr); end

  class << self
    # Returns whether a document satisfies a $nor expression.
    #
    # @api private
    # @api private
    # @param document [Mongoid::Document] The document.
    # @param expr [Array<Hash>] The $nor conditions.
    # @return [true | false] Whether the document matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/nor.rb#20
    def matches?(document, expr); end
  end
end

# In-memory matcher for $not expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/not/
#
# source://mongoid//lib/mongoid/matcher/not.rb#10
module Mongoid::Matcher::Not
  private

  # Returns whether a value satisfies an $not expression.
  #
  # @api private
  # @api private
  # @param condition [Hash | Regexp | BSON::Regexp::Raw] The $not condition predicate.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/not.rb#22
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies an $not expression.
    #
    # @api private
    # @api private
    # @param condition [Hash | Regexp | BSON::Regexp::Raw] The $not condition predicate.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/not.rb#22
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $or expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/or/
#
# source://mongoid//lib/mongoid/matcher/or.rb#10
module Mongoid::Matcher::Or
  private

  # Returns whether a document satisfies an $or expression.
  #
  # @api private
  # @api private
  # @param document [Mongoid::Document] The document.
  # @param expr [Array<Hash>] The $or conditions.
  # @return [true | false] Whether the document matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/or.rb#20
  def matches?(document, expr); end

  class << self
    # Returns whether a document satisfies an $or expression.
    #
    # @api private
    # @api private
    # @param document [Mongoid::Document] The document.
    # @param expr [Array<Hash>] The $or conditions.
    # @return [true | false] Whether the document matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/or.rb#20
    def matches?(document, expr); end
  end
end

# In-memory matcher for $regex expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/regex/
#
# source://mongoid//lib/mongoid/matcher/regex.rb#10
module Mongoid::Matcher::Regex
  private

  # Returns whether a value satisfies a $regex expression.
  #
  # @api private
  # @api private
  # @param condition [Regexp | BSON::Regexp::Raw] The $regex condition.
  # @param exists [true | false] Not used.
  # @param value [String | Array<String>] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/regex.rb#21
  def matches?(exists, value, condition); end

  # Returns whether an scalar or array value matches a Regexp.
  #
  # @api private
  # @api private
  # @param condition [Regexp] The Regexp condition.
  # @param exists [true | false] Not used.
  # @param value [String | Array<String>] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/regex.rb#54
  def matches_array_or_scalar?(value, condition); end

  class << self
    # Returns whether a value satisfies a $regex expression.
    #
    # @api private
    # @api private
    # @param condition [Regexp | BSON::Regexp::Raw] The $regex condition.
    # @param exists [true | false] Not used.
    # @param value [String | Array<String>] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/regex.rb#21
    def matches?(exists, value, condition); end

    # Returns whether an scalar or array value matches a Regexp.
    #
    # @api private
    # @api private
    # @param condition [Regexp] The Regexp condition.
    # @param exists [true | false] Not used.
    # @param value [String | Array<String>] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/regex.rb#54
    def matches_array_or_scalar?(value, condition); end
  end
end

# In-memory matcher for $size expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/size/
#
# source://mongoid//lib/mongoid/matcher/size.rb#10
module Mongoid::Matcher::Size
  private

  # Returns whether a value satisfies a $size expression.
  #
  # @api private
  # @api private
  # @param condition [Integer | Array<Object>] The $size condition
  #   predicate, either a non-negative Integer or an Array to match size.
  # @param exists [true | false] Not used.
  # @param value [Numeric] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/size.rb#22
  def matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $size expression.
    #
    # @api private
    # @api private
    # @param condition [Integer | Array<Object>] The $size condition
    #   predicate, either a non-negative Integer or an Array to match size.
    # @param exists [true | false] Not used.
    # @param value [Numeric] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/size.rb#22
    def matches?(exists, value, condition); end
  end
end

# In-memory matcher for $type expression.
#
# @api private
# @see https://www.mongodb.com/docs/manual/reference/operator/query/type/
#
# source://mongoid//lib/mongoid/matcher/type.rb#10
module Mongoid::Matcher::Type
  private

  # Returns whether a value satisfies a $type expression.
  #
  # @api private
  # @api private
  # @param condition [Integer | Array<Integer>] The $type condition
  #   predicate which corresponds to the BSON type enumeration.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/type.rb#22
  def matches?(exists, value, condition); end

  # Returns whether a value satisfies a single $type expression
  # value.
  #
  # @api private
  # @api private
  # @param condition [Integer] The $type condition predicate
  #   which corresponds to the BSON type enumeration.
  # @param exists [true | false] Whether the value exists.
  # @param value [Object] The value to check.
  # @return [true | false] Whether the value matches.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/matcher/type.rb#50
  def one_matches?(exists, value, condition); end

  class << self
    # Returns whether a value satisfies a $type expression.
    #
    # @api private
    # @api private
    # @param condition [Integer | Array<Integer>] The $type condition
    #   predicate which corresponds to the BSON type enumeration.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/type.rb#22
    def matches?(exists, value, condition); end

    # Returns whether a value satisfies a single $type expression
    # value.
    #
    # @api private
    # @api private
    # @param condition [Integer] The $type condition predicate
    #   which corresponds to the BSON type enumeration.
    # @param exists [true | false] Whether the value exists.
    # @param value [Object] The value to check.
    # @return [true | false] Whether the value matches.
    # @return [Boolean]
    #
    # source://mongoid//lib/mongoid/matcher/type.rb#50
    def one_matches?(exists, value, condition); end
  end
end

# The default class for resolving model classes based on discriminant keys.
# Given a key, it will return the corresponding model class, if any. By
# default, it looks for classes with names that match the given keys, but
# additional mappings may be provided.
#
# It is also possible to instantiate multiple resolvers---and even implement
# your own---so that different sets of classes can use independent resolution
# mechanics.
#
# source://mongoid//lib/mongoid/model_resolver.rb#14
class Mongoid::ModelResolver
  include ::Mongoid::ModelResolver::Interface

  # Instantiates a new ModelResolver instance.
  #
  # @return [ModelResolver] a new instance of ModelResolver
  #
  # source://mongoid//lib/mongoid/model_resolver.rb#75
  def initialize; end

  # Registers the given model class with the given keys. In addition to the given keys, the
  # class name itself will be included as a key to identify the class. Keys are given in priority
  # order, with highest priority keys first and lowest last. The class name, if not given explicitly,
  # is always given lowest priority.
  #
  # If called more than once, newer keys have higher priority than older keys. All duplicate keys will
  # be removed.
  #
  # @param *keys [Array<String>] the list of keys to use as an alias (optional)
  # @param klass [Mongoid::Document] the document class to register
  #
  # source://mongoid//lib/mongoid/model_resolver.rb#90
  def register(klass, *keys); end

  class << self
    # Returns the default instance of the ModelResolver.
    #
    # @return [Mongoid::ModelResolver] the default ModelResolver instance.
    #
    # source://mongoid//lib/mongoid/model_resolver.rb#27
    def instance; end

    # source://mongoid//lib/mongoid/model_resolver.rb#22
    def register(*_arg0, **_arg1, &_arg2); end

    # Register the given resolver under the given name.
    #
    # @param name [String | Symbol] the identifier to use to register the resolver.
    # @param resolver [Mongoid::ModelResolver::Interface] the resolver to register.
    #
    # source://mongoid//lib/mongoid/model_resolver.rb#68
    def register_resolver(resolver, name); end

    # Returns the resolver instance that corresponds to the argument.
    #
    # @param identifier_or_object [nil | true | false Symbol | String | Mongoid::ModelResolver::Interface] When nil or false, returns nil. When true or :default, corresponds to the default resolver.
    #   When any other symbol or string, corresponds to the registered resolver with that identifier.
    #   Otherwise, it must be a resolver instance itself.
    # @raise Mongoid::Errors::UnrecognizedResolver if the given identifier is a
    #   symbol or string and it does not match any registered resolver.
    # @return [Mongoid::ModelResolver::Interface] the resolver instance corresponding to the
    #   given argument.
    #
    # source://mongoid//lib/mongoid/model_resolver.rb#52
    def resolver(identifier_or_object = T.unsafe(nil)); end

    # Returns the map of registered resolvers. The default resolver is not
    # included here.
    #
    # @return [Hash<Symbol => Mongoid::ModelResolver::Interface>] the hash of
    #   resolver instances, mapped by symbol identifier.
    #
    # source://mongoid//lib/mongoid/model_resolver.rb#36
    def resolvers; end
  end
end

# The mutex instance used to make the `.instance` method thread-safe.
#
# @api private
#
# source://mongoid//lib/mongoid/model_resolver.rb#18
Mongoid::ModelResolver::INSTANCE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://mongoid//lib/mongoid/model_resolver.rb#105
module Mongoid::ModelResolver::Interface
  extend ::ActiveSupport::Concern

  # source://mongoid//lib/mongoid/model_resolver.rb#114
  def default_key_for(record); end

  # source://mongoid//lib/mongoid/model_resolver.rb#126
  def keys_for(record); end

  # source://mongoid//lib/mongoid/model_resolver.rb#147
  def model_for(key); end
end

# A string added to the platform details of Ruby driver client handshake documents.
#
# source://mongoid//lib/mongoid.rb#51
Mongoid::PLATFORM_DETAILS = T.let(T.unsafe(nil), String)

# Contains general behavior for persistence operations.
#
# source://mongoid//lib/mongoid/persistable/creatable.rb#5
module Mongoid::Persistable
  include ::Mongoid::Positional
  include ::Mongoid::Persistable::Savable
  include ::Mongoid::Persistable::Updatable
  include ::Mongoid::Persistable::Upsertable
  extend ::ActiveSupport::Concern
  include ::Mongoid::Persistable::Creatable
  include ::Mongoid::Persistable::Deletable
  include ::Mongoid::Persistable::Destroyable
  include ::Mongoid::Persistable::Incrementable
  include ::Mongoid::Persistable::Logical
  include ::Mongoid::Persistable::Maxable
  include ::Mongoid::Persistable::Minable
  include ::Mongoid::Persistable::Multipliable
  include ::Mongoid::Persistable::Poppable
  include ::Mongoid::Persistable::Pullable
  include ::Mongoid::Persistable::Pushable
  include ::Mongoid::Persistable::Renamable
  include ::Mongoid::Persistable::Settable
  include ::Mongoid::Persistable::Unsettable

  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods
  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods

  # Execute operations atomically (in a single database call) for everything
  # that would happen inside the block. This method supports nesting further
  # calls to atomically, which will behave according to the options described
  # below.
  #
  # An option join_context can be given which, when true, will merge the
  # operations declared by the given block with the atomically block wrapping
  # the current invocation for the same document, if one exists. If this
  # block or any other block sharing the same context raises before
  # persisting, then all the operations of that context will not be
  # persisted, and will also be reset in memory.
  #
  # When join_context is false, the given block of operations will be
  # persisted independently of other contexts. Failures in other contexts will
  # not affect this one, so long as this block was able to run and persist
  # changes.
  #
  # The default value of join_context is set by the global configuration
  # option join_contexts, whose own default is false.
  #
  # @example Execute some inner operations atomically, but independently from the outer operations.
  #
  #   document.atomically do
  #   document.inc likes: 10
  #   document.atomically join_context: false do
  #   # The following is persisted to the database independently.
  #   document.unset :origin
  #   end
  #   document.atomically join_context: true do
  #   # The following is persisted along with the other outer operations.
  #   document.inc member_count: 3
  #   end
  #   document.set name: "Tool"
  #   end
  # @example Execute the operations atomically.
  #   document.atomically do
  #   document.set(name: "Tool").inc(likes: 10)
  #   end
  # @param join_context [true | false] Join the context (i.e. merge
  #   declared atomic operations) of the atomically block wrapping this one
  #   for the same document, if one exists.
  # @return [true | false] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/persistable.rb#94
  def atomically(join_context: T.unsafe(nil)); end

  # Raise an error if a callback failed.
  #
  # @example Raise the callback error.
  #   Person.fail_due_to_callback!(person, :create!)
  # @param method [Symbol] The method being called.
  # @raise [Errors::Callback] The callback error.
  #
  # source://mongoid//lib/mongoid/persistable.rb#143
  def fail_due_to_callback!(method); end

  # Raise an error if validation failed.
  #
  # @example Raise the validation error.
  #   Person.fail_due_to_validation!(person)
  # @raise [Errors::Validations] The validation error.
  #
  # source://mongoid//lib/mongoid/persistable.rb#131
  def fail_due_to_validation!; end

  private

  # Return the current atomic context's changed fields.
  #
  # @api private
  # @example Return the current atomic context's changed fields.
  #   document._mongoid_atomic_context_changed_fields
  # @return [Array] The changed fields.
  #
  # source://mongoid//lib/mongoid/persistable.rb#279
  def _mongoid_atomic_context_changed_fields; end

  # Pop an atomic context off the stack.
  #
  # @api private
  # @example Pop an atomic context off the stack.
  #   document._mongoid_pop_atomic_context
  #
  # source://mongoid//lib/mongoid/persistable.rb#265
  def _mongoid_pop_atomic_context; end

  # Push a new atomic context onto the stack.
  #
  # @api private
  # @example Push a new atomic context onto the stack.
  #   document._mongoid_push_atomic_context
  #
  # source://mongoid//lib/mongoid/persistable.rb#253
  def _mongoid_push_atomic_context; end

  # Remove the dirty changes for all fields changed in the current atomic
  # context.
  #
  # @api private
  # @example Remove the current atomic context's dirty changes.
  #   document._mongoid_remove_atomic_context_changes
  #
  # source://mongoid//lib/mongoid/persistable.rb#230
  def _mongoid_remove_atomic_context_changes; end

  # Reset the attributes for all fields changed in the current atomic
  # context.
  #
  # @api private
  # @example Reset the current atomic context's changed attributes.
  #   document._mongoid_reset_atomic_context_changes!
  #
  # source://mongoid//lib/mongoid/persistable.rb#242
  def _mongoid_reset_atomic_context_changes!; end

  # Are we executing an atomically block on the current document?
  #
  # @api private
  # @example Are we executing atomically?
  #   document.executing_atomically?
  # @return [true | false] If we are current executing atomically.
  #
  # source://mongoid//lib/mongoid/persistable.rb#157
  def executing_atomically?; end

  # Persist the atomic operations.
  #
  # @api private
  # @example Persist the atomic operations.
  #   persist_atomic_operations(ops)
  # @param operations [Hash] The atomic operations.
  #
  # source://mongoid//lib/mongoid/persistable.rb#311
  def persist_atomic_operations(operations); end

  # If we are in an atomically block, add the operations to the delayed group,
  # otherwise persist immediately.
  #
  # @api private
  # @example Persist immediately or delay the operations.
  #   document.persist_or_delay_atomic_operation(ops)
  # @param operation [Hash] The operation.
  #
  # source://mongoid//lib/mongoid/persistable.rb#292
  def persist_or_delay_atomic_operation(operation); end

  # Post process the persistence operation.
  #
  # @api private
  # @example Post process the persistence operation.
  #   document.post_process_persist(true)
  # @option options
  # @param options [Hash] The options.
  # @param result [Object] The result of the operation.
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/persistable.rb#174
  def post_process_persist(result, options = T.unsafe(nil)); end

  # Prepare an atomic persistence operation. Yields an empty hash to be sent
  # to the update.
  #
  # @api private
  # @example Prepare the atomic operation.
  #   document.prepare_atomic_operation do |coll, selector, opts|
  #   ...
  #   end
  # @raise [Errors::ReadonlyDocument]
  # @return [Object] The result of the operation.
  #
  # source://mongoid//lib/mongoid/persistable.rb#194
  def prepare_atomic_operation; end

  # Process the atomic operations - this handles the common behavior of
  # iterating through each op, getting the aliased field name, and removing
  # appropriate dirty changes.
  #
  # @api private
  # @example Process the atomic operations.
  #   document.process_atomic_operations(pulls) do |field, value|
  #   ...
  #   end
  # @param operations [Hash] The atomic operations.
  # @return [Hash] The operations.
  #
  # source://mongoid//lib/mongoid/persistable.rb#215
  def process_atomic_operations(operations); end
end

# Defines behavior for persistence operations that create new documents.
#
# source://mongoid//lib/mongoid/persistable/creatable.rb#8
module Mongoid::Persistable::Creatable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Creatable::ClassMethods

  # Insert a new document into the database. Will return the document
  # itself whether or not the save was successful.
  #
  # @example Insert a document.
  #   document.insert
  # @param options [Hash] Options to pass to insert.
  # @return [Document] The persisted document.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#20
  def insert(options = T.unsafe(nil)); end

  private

  # Get the atomic insert for embedded documents, either a push or set.
  #
  # @api private
  # @example Get the inserts.
  #   document.inserts
  # @return [Hash] The insert ops.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#40
  def atomic_inserts; end

  # Insert the embedded document.
  #
  # @api private
  # @example Insert the document as embedded.
  #   document.insert_as_embedded
  # @raise [Errors::NoParent]
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#52
  def insert_as_embedded; end

  # Insert the root document.
  #
  # @api private
  # @example Insert the document as root.
  #   document.insert_as_root
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#72
  def insert_as_root; end

  # Post process an insert, which sets the new record attribute to false
  # and flags all the children as persisted.
  #
  # @api private
  # @example Post process the insert.
  #   document.post_process_insert
  # @return [true] true.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#85
  def post_process_insert; end

  # Prepare the insert for execution. Validates and runs callbacks, etc.
  #
  # @api private
  # @example Prepare for insertion.
  #   document.prepare_insert do
  #   collection.insert(as_document)
  #   end
  # @param options [Hash] The options.
  # @raise [Errors::ReadonlyDocument]
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#104
  def prepare_insert(options = T.unsafe(nil)); end
end

# source://mongoid//lib/mongoid/persistable/creatable.rb#129
module Mongoid::Persistable::Creatable::ClassMethods
  # Create a new document. This will instantiate a new document and
  # insert it in a single call. Will always return the document
  # whether save passed or not.
  #
  # @example Create a new document.
  #   Person.create(:title => "Mr")
  # @example Create multiple new documents.
  #   Person.create({ title: "Mr" }, { title: "Mrs" })
  # @param attributes [Hash | Array] The attributes to create with, or an
  #   Array of multiple attributes for multiple documents.
  # @return [Document | Array<Document>] The newly created document(s).
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#145
  def create(attributes = T.unsafe(nil), &block); end

  # Create a new document. This will instantiate a new document and
  # insert it in a single call. Will always return the document
  # whether save passed or not, and if validation fails an error will be
  # raise.
  #
  # @example Create a new document.
  #   Person.create!(:title => "Mr")
  # @example Create multiple new documents.
  #   Person.create!({ title: "Mr" }, { title: "Mrs" })
  # @param attributes [Hash | Array] The attributes to create with, or an
  #   Array of multiple attributes for multiple documents.
  # @return [Document | Array<Document>] The newly created document(s).
  #
  # source://mongoid//lib/mongoid/persistable/creatable.rb#172
  def create!(attributes = T.unsafe(nil), &block); end
end

# Defines behavior for persistence operations that delete documents.
#
# source://mongoid//lib/mongoid/persistable/deletable.rb#8
module Mongoid::Persistable::Deletable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Deletable::ClassMethods

  # Remove the document from the database.
  #
  # @example Remove the document.
  #   document.remove
  # @option options
  # @option options
  # @param options [Hash] The options.
  # @return [TrueClass] True.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#23
  def delete(options = T.unsafe(nil)); end

  # Remove the document from the database.
  #
  # @example Remove the document.
  #   document.remove
  # @option options
  # @option options
  # @param options [Hash] The options.
  # @return [TrueClass] True.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#34
  def remove(options = T.unsafe(nil)); end

  private

  # Get the atomic deletes for the operation.
  #
  # @api private
  # @example Get the atomic deletes.
  #   document.atomic_deletes
  # @return [Hash] The atomic deletes.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#46
  def atomic_deletes; end

  # Delete the embedded document.
  #
  # @api private
  # @example Delete the embedded document.
  #   document.delete_as_embedded
  # @param options [Hash] The deletion options.
  # @return [true] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#60
  def delete_as_embedded(options = T.unsafe(nil)); end

  # Delete the root document.
  #
  # @api private
  # @example Delete the root document.
  #   document.delete_as_root
  # @return [true] If the document was removed.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#79
  def delete_as_root; end

  # Are we needing to notify the parent document of the deletion.
  #
  # @api private
  # @example Are we notifying the parent.
  #   document.notifying_parent?(suppress: true)
  # @param options [Hash] The delete options.
  # @return [true | false] If the parent should be notified.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#94
  def notifying_parent?(options = T.unsafe(nil)); end

  # Prepare the delete operation.
  #
  # @api private
  # @example Prepare the delete operation.
  #   document.prepare_delete do
  #   collection.find(atomic_selector).remove
  #   end
  # @raise [Errors::ReadonlyDocument]
  # @return [true] If the object was deleted successfully.
  # @yield [_self]
  # @yieldparam _self [Mongoid::Persistable::Deletable] the object that the method was called on
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#108
  def prepare_delete; end
end

# source://mongoid//lib/mongoid/persistable/deletable.rb#115
module Mongoid::Persistable::Deletable::ClassMethods
  # Delete all documents given the supplied conditions. If no conditions
  # are passed, the entire collection will be dropped for performance
  # benefits. Does not fire any callbacks.
  #
  # @example Delete all documents from the collection.
  #   Person.delete_all
  # @example Delete matching documents from the collection.
  #   Person.delete_all({ :title => "Sir" })
  # @param conditions [Hash] Optional conditions to delete by.
  # @return [Integer] The number of documents deleted.
  #
  # source://mongoid//lib/mongoid/persistable/deletable.rb#130
  def delete_all(conditions = T.unsafe(nil)); end
end

# Defines behavior for persistence operations that destroy documents.
#
# source://mongoid//lib/mongoid/persistable/destroyable.rb#8
module Mongoid::Persistable::Destroyable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Persistable::Destroyable::ClassMethods

  # Remove the document from the database with callbacks.
  #
  # @example Destroy a document.
  #   document.destroy
  # @option options
  # @option options
  # @param options [Hash] The options.
  # @raise [Errors::ReadonlyDocument]
  # @return [true | false] True if successful, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/destroyable.rb#23
  def destroy(options = T.unsafe(nil)); end

  # Remove the document from the database with callbacks. Raises
  # an error if the document is not destroyed.
  #
  # @example Destroy a document.
  #   document.destroy!
  # @option options
  # @option options
  # @param options [Hash] The options.
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/persistable/destroyable.rb#59
  def destroy!(options = T.unsafe(nil)); end
end

# source://mongoid//lib/mongoid/persistable/destroyable.rb#63
module Mongoid::Persistable::Destroyable::ClassMethods
  # Delete all documents given the supplied conditions. If no conditions
  # are passed, the entire collection will be dropped for performance
  # benefits. Fires the destroy callbacks if conditions were passed.
  #
  # @example Destroy all documents from the collection.
  #   Person.destroy_all
  # @example Destroy matching documents from the collection.
  #   Person.destroy_all({ :title => "Sir" })
  # @param conditions [Hash] Optional conditions to destroy by.
  # @return [Integer] The number of documents destroyed.
  #
  # source://mongoid//lib/mongoid/persistable/destroyable.rb#78
  def destroy_all(conditions = T.unsafe(nil)); end
end

# Defines behavior for $inc operations.
#
# source://mongoid//lib/mongoid/persistable/incrementable.rb#8
module Mongoid::Persistable::Incrementable
  extend ::ActiveSupport::Concern

  # Increment the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set with the provided value.
  #
  # @example Increment the fields.
  #   document.inc(score: 10, place: 1, lives: -10)
  # @param increments [Hash] The field/inc increment pairs.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/incrementable.rb#21
  def inc(increments); end
end

# The atomic operations that deal with arrays or sets in the db.
#
# source://mongoid//lib/mongoid/persistable.rb#47
Mongoid::Persistable::LIST_OPERATIONS = T.let(T.unsafe(nil), Array)

# Defines behavior for logical bitwise operations.
#
# source://mongoid//lib/mongoid/persistable/logical.rb#8
module Mongoid::Persistable::Logical
  extend ::ActiveSupport::Concern

  # Performs an atomic $bit operation on the field with the provided hash
  # of bitwise ops to execute in order.
  #
  # @example Execute the bitwise operations.
  #   person.bit(age: { :and => 12 }, val: { and: 10, or: 12 })
  # @param operations [Hash] The bitwise operations.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/logical.rb#20
  def bit(operations); end
end

# Defines behavior for setting a field (or fields) to the larger of
# either it's current value, or a given value.
#
# source://mongoid//lib/mongoid/persistable/maxable.rb#9
module Mongoid::Persistable::Maxable
  extend ::ActiveSupport::Concern

  # Set the given field or fields to the larger of either it's current
  # value, or a given value.
  #
  # @example Set a field to be no less than 100.
  #   document.set_max(field: 100)
  # @param fields [Hash<Symbol | String, Comparable>] The fields to
  #   set, with corresponding minimum values.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/maxable.rb#34
  def clamp_lower_bound(fields); end

  # Set the given field or fields to the larger of either it's current
  # value, or a given value.
  #
  # @example Set a field to be no less than 100.
  #   document.set_max(field: 100)
  # @param fields [Hash<Symbol | String, Comparable>] The fields to
  #   set, with corresponding minimum values.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/maxable.rb#22
  def set_max(fields); end
end

# Defines behavior for setting a field (or fields) to the smaller of
# either it's current value, or a given value.
#
# source://mongoid//lib/mongoid/persistable/minable.rb#9
module Mongoid::Persistable::Minable
  extend ::ActiveSupport::Concern

  # Set the given field or fields to the smaller of either it's current
  # value, or a given value.
  #
  # @example Set a field to be no more than 100.
  #   document.min(field: 100)
  # @param fields [Hash<Symbol | String, Comparable>] The fields to
  #   set, with corresponding maximum values.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/minable.rb#34
  def clamp_upper_bound(fields); end

  # Set the given field or fields to the smaller of either it's current
  # value, or a given value.
  #
  # @example Set a field to be no more than 100.
  #   document.min(field: 100)
  # @param fields [Hash<Symbol | String, Comparable>] The fields to
  #   set, with corresponding maximum values.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/minable.rb#22
  def set_min(fields); end
end

# Defines behavior for $mul operations.
#
# source://mongoid//lib/mongoid/persistable/multipliable.rb#8
module Mongoid::Persistable::Multipliable
  extend ::ActiveSupport::Concern

  # Multiply the provided fields by the corresponding values. Values can
  # be positive or negative, and if no value exists for the field it will
  # be set to zero.
  #
  # @example Multiply the fields.
  #   document.mul(score: 10, place: 1, lives: -10)
  # @param factors [Hash] The field/factor multiplier pairs.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/multipliable.rb#21
  def mul(factors); end
end

# Defines behavior for $pop operations.
#
# source://mongoid//lib/mongoid/persistable/poppable.rb#8
module Mongoid::Persistable::Poppable
  extend ::ActiveSupport::Concern

  # Pop or shift items from arrays using the $pop operator.
  #
  # @example Multiple pops in one call.
  #   document.pop(names: 1, aliases: 1)
  # @example Pop items from an array.
  #   document.pop(aliases: 1)
  # @example Shift items in the array.
  #   document.pop(aliases: -1)
  # @param pops [Hash] The field/value pop operations.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/poppable.rb#25
  def pop(pops); end
end

# Defines behavior for $pull and $pullAll operations.
#
# source://mongoid//lib/mongoid/persistable/pullable.rb#8
module Mongoid::Persistable::Pullable
  extend ::ActiveSupport::Concern

  # Pull single values from the provided arrays.
  #
  # @example Pull a value from the array.
  #   document.pull(names: "Jeff", levels: 5)
  # @note If duplicate values are found they will all be pulled.
  # @param pulls [Hash] The field/value pull pairs.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/pullable.rb#21
  def pull(pulls); end

  # Pull multiple values from the provided array fields.
  #
  # @example Pull values from the arrays.
  #   document.pull_all(names: [ "Jeff", "Bob" ], levels: [ 5, 6 ])
  # @param pulls [Hash] The pull all operations.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/pullable.rb#39
  def pull_all(pulls); end
end

# Defines behavior for $push and $addToSet operations.
#
# source://mongoid//lib/mongoid/persistable/pushable.rb#8
module Mongoid::Persistable::Pushable
  extend ::ActiveSupport::Concern

  # Add the single values to the arrays only if the value does not already
  # exist in the array.
  #
  # @example Add the values to the sets.
  #   document.add_to_set(names: "James", aliases: "Bond")
  # @param adds [Hash] The field/value pairs to add.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/pushable.rb#20
  def add_to_set(adds); end

  # Push a single value or multiple values onto arrays.
  #
  # @example Push a single value onto arrays.
  #   document.push(names: "James", aliases: "007")
  # @example Push multiple values onto arrays.
  #   document.push(names: [ "James", "Bond" ])
  # @param pushes [Hash] The $push operations.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/pushable.rb#51
  def push(pushes); end
end

# Defines behavior for $rename operations.
#
# source://mongoid//lib/mongoid/persistable/renamable.rb#8
module Mongoid::Persistable::Renamable
  extend ::ActiveSupport::Concern

  # Rename fields from one value to another via $rename.
  #
  # @example Rename the fields.
  #   document.rename(title: "salutation", name: "nombre")
  # @note This does not work for fields in embeds many associations.
  # @param renames [Hash] The rename pairs of old name/new name.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/renamable.rb#21
  def rename(renames); end
end

# Defines behavior for persistence operations that save documents.
#
# source://mongoid//lib/mongoid/persistable/savable.rb#8
module Mongoid::Persistable::Savable
  # Save the document - will perform an insert if the document is new, and
  # update if not.
  #
  # @example Save the document.
  #   document.save
  # @option options
  # @param options [Hash] Options to pass to the save.
  # @return [true | false] True if success, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/savable.rb#25
  def save(options = T.unsafe(nil)); end

  # Save the document - will perform an insert if the document is new, and
  # update if not. If a validation error occurs an error will get raised.
  #
  # @example Save the document.
  #   document.save!
  # @option options
  # @param options [Hash] Options to pass to the save.
  # @raise [Errors::Validations] If validation failed.
  # @raise [Errors::Callback] If a callback returns false.
  # @return [true | false] True if validation passed.
  #
  # source://mongoid//lib/mongoid/persistable/savable.rb#51
  def save!(options = T.unsafe(nil)); end
end

# Defines behavior for $set operations.
#
# source://mongoid//lib/mongoid/persistable/settable.rb#8
module Mongoid::Persistable::Settable
  extend ::ActiveSupport::Concern

  # Perform a $set operation on the provided field/value pairs and set the
  # values in the document in memory.
  #
  # The key can be a dotted sequence of keys, in which case the
  # top level field is treated as a nested hash and any missing keys
  # are created automatically:
  #
  # Performing a nested set like this merges values of intermediate keys:
  #
  # If the top level field was not a hash, its original value is discarded
  # and the field is replaced with a hash.
  #
  # Note that unlike MongoDB's $set, Mongoid's set writes out the entire
  # field even when setting a subset of the field via the nested hash
  # semantics. This means performing a $set with nested hash semantics
  # can overwrite other hash keys within the top level field in the database.
  #
  # @example Nested hash overwriting a non-hash value.
  #   document.set('author' => 'John Doe')
  #   document.set('author.title' => 'Sir')
  #   # => document.author == {'title' => 'Sir'}
  # @example Nested hash value merging.
  #   document.set('author.title' => 'Sir')
  #   document.set('author.name' => 'Linus Torvalds')
  #   # => document.author == {'title' => 'Sir', 'name' => 'Linus Torvalds'}
  # @example Set the values using nested hash semantics.
  #   document.set('author.title' => 'Sir')
  #   # => document.author == {'title' => 'Sir'}
  # @example Set the values.
  #   document.set(title: "sir", dob: Date.new(1970, 1, 1))
  # @param setters [Hash] The field/value pairs to set.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/settable.rb#48
  def set(setters); end
end

# Defines behavior for $unset operations.
#
# source://mongoid//lib/mongoid/persistable/unsettable.rb#8
module Mongoid::Persistable::Unsettable
  extend ::ActiveSupport::Concern

  # Perform an $unset operation on the provided fields and in the
  # values in the document in memory.
  #
  # @example Unset the values.
  #   document.unset(:first_name, :last_name, :middle)
  # @param *fields [[ String | Symbol | Array<String | Symbol>]...] The names of the field(s) to unset.
  # @return [Document] The document.
  #
  # source://mongoid//lib/mongoid/persistable/unsettable.rb#21
  def unset(*fields); end
end

# Defines behavior for persistence operations that update existing
# documents.
#
# source://mongoid//lib/mongoid/persistable/updatable.rb#9
module Mongoid::Persistable::Updatable
  # Update the document attributes in the database.
  #
  # @example Update the document's attributes
  #   document.update(:title => "Sir")
  # @param attributes [Hash] The attributes to update.
  # @return [true | false] True if validation passed, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#40
  def update(attributes = T.unsafe(nil)); end

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # @example Update the document's attributes.
  #   document.update!(:title => "Sir")
  # @param attributes [Hash] The attributes to update.
  # @raise [Errors::Validations] If validation failed.
  # @raise [Errors::Callbacks] If a callback returns false.
  # @return [true | false] True if validation passed.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#58
  def update!(attributes = T.unsafe(nil)); end

  # Update a single attribute and persist the entire document.
  # This skips validation but fires the callbacks.
  #
  # @example Update the attribute.
  #   person.update_attribute(:title, "Sir")
  # @param name [Symbol | String] The name of the attribute.
  # @param value [Object] The new value of the attribute.a
  # @raise [Errors::ReadonlyAttribute] If the field cannot be changed due
  #   to being flagged as read-only.
  # @return [true | false] True if save was successful, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#24
  def update_attribute(name, value); end

  # Update the document attributes in the database.
  #
  # @example Update the document's attributes
  #   document.update(:title => "Sir")
  # @param attributes [Hash] The attributes to update.
  # @return [true | false] True if validation passed, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#44
  def update_attributes(attributes = T.unsafe(nil)); end

  # Update the document attributes in the database and raise an error if
  # validation failed.
  #
  # @example Update the document's attributes.
  #   document.update!(:title => "Sir")
  # @param attributes [Hash] The attributes to update.
  # @raise [Errors::Validations] If validation failed.
  # @raise [Errors::Callbacks] If a callback returns false.
  # @return [true | false] True if validation passed.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#66
  def update_attributes!(attributes = T.unsafe(nil)); end

  private

  # Checks to see if the _id field has been modified. If it has, and if
  # the document has already been persisted, this is an error. Otherwise,
  # returns without side-effects.
  #
  # Note that if `Mongoid::Config.immutable_ids` is false, this will do
  # nothing.
  #
  # @raise [Errors::ImmutableAttribute] if _id has changed, and document
  #   has been persisted.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#195
  def enforce_immutability_of_id_field!; end

  # Initialize the atomic updates.
  #
  # @api private
  # @example Initialize the atomic updates.
  #   document.init_atomic_updates
  # @return [Array<Hash>] The updates and conflicts.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#78
  def init_atomic_updates; end

  # Prepare the update for execution. Validates and runs callbacks, etc.
  #
  # @api private
  # @example Prepare for update.
  #   document.prepare_update do
  #   collection.update(atomic_selector)
  #   end
  # @option options
  # @param options [Hash] The options.
  # @raise [Errors::ReadonlyDocument]
  # @return [true | false] The result of the update.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#99
  def prepare_update(options = T.unsafe(nil)); end

  # If there is a touch option and it is false, this method will call the
  # timeless method so that the updated_at attribute is not updated. It
  # will call the timeless method on all of the cascadable children as
  # well. Note that timeless is cleared in the before_update callback.
  #
  # @option options
  # @param children [Array<Document>] The children that the :update
  #   callbacks will be executed on.
  # @param options [Hash] The options.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#176
  def process_touch_option(options, children); end

  # Consolidates all the callback invocations into a single place, to
  # avoid cluttering the logic in #prepare_update.
  #
  # @param update_children [Array<Document>] The children that the
  #   :update callbacks will be executed on.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#216
  def run_all_callbacks_for_update(update_children); end

  # Update the document in the database.
  #
  # @example Update an existing document.
  #   document.update
  # @option options
  # @param options [Hash] Options to pass to update.
  # @return [true | false] True if succeeded, false if not.
  #
  # source://mongoid//lib/mongoid/persistable/updatable.rb#127
  def update_document(options = T.unsafe(nil)); end
end

# Defines behavior for persistence operations that upsert documents.
#
# source://mongoid//lib/mongoid/persistable/upsertable.rb#8
module Mongoid::Persistable::Upsertable
  # Perform an upsert of the document. If the document does not exist in the
  # database, then Mongo will insert a new one, otherwise the fields will get
  # overwritten with new values on the existing document.
  #
  # If the replace option is true, unspecified attributes will be dropped,
  # and if it is false, unspecified attributes will be maintained. The
  # replace option defaults to false in Mongoid 9.
  #
  # @example Upsert the document with replace.
  #   document.upsert(replace: true)
  # @example Upsert the document.
  #   document.upsert
  # @example Upsert with extra attributes to use when inserting.
  #   document.upsert(set_on_insert: { created_at: DateTime.now })
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The validation options.
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid/persistable/upsertable.rb#36
  def upsert(options = T.unsafe(nil)); end

  private

  # Prepare the upsert for execution.
  #
  # @api private
  # @example Prepare the upsert
  #   document.prepare_upsert do
  #   collection.find(selector).update(as_document)
  #   end
  # @option options
  # @param options [Hash] The options hash.
  # @raise [Errors::ReadonlyDocument]
  # @return [true | false] If the operation succeeded.
  #
  # source://mongoid//lib/mongoid/persistable/upsertable.rb#71
  def prepare_upsert(options = T.unsafe(nil)); end
end

# Object encapsulating logic for setting/getting a collection and database name
# and a client with particular options to use when persisting models.
#
# source://mongoid//lib/mongoid/persistence_context.rb#8
class Mongoid::PersistenceContext
  extend ::Forwardable

  # Initialize the persistence context object.
  #
  # @example Create a new persistence context.
  #   PersistenceContext.new(model, collection: 'other')
  # @param object [Object] The class or model instance for which a persistence context
  #   should be created.
  # @param opts [Hash] The persistence context options.
  # @return [PersistenceContext] a new instance of PersistenceContext
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#46
  def initialize(object, opts = T.unsafe(nil)); end

  # Determine if this persistence context is equal to another.
  #
  # @example Compare two persistence contexts.
  #   context == other_context
  # @param other [Object] The object to be compared with this one.
  # @return [true | false] Whether the two persistence contexts are equal.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#154
  def ==(other); end

  # Get the client for this persistence context.
  #
  # @example Get the client for this persistence context.
  #   context.client
  # @return [Mongo::Client] The client for this persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#117
  def client; end

  # Get the client name for this persistence context.
  #
  # @example Get the client name for this persistence context.
  #   context.client_name
  # @return [Symbol] The client name for this persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#140
  def client_name; end

  # source://mongoid//lib/mongoid/persistence_context.rb#12
  def cluster(*_arg0, **_arg1, &_arg2); end

  # Get the collection for this persistence context.
  #
  # @example Get the collection for this persistence context.
  #   context.collection
  # @param parent [Object] The parent object whose collection name is used
  #   instead of this persistence context's collection name.
  # @return [Mongo::Collection] The collection for this persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#81
  def collection(parent = T.unsafe(nil)); end

  # Get the collection name for this persistence context.
  #
  # @example Get the collection name for this persistence context.
  #   context.collection_name
  # @return [String] The collection name for this persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#94
  def collection_name; end

  # Get the database name for this persistence context.
  #
  # @example Get the database name for this persistence context.
  #   context.database_name
  # @return [String] The database name for this persistence
  #   context.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#106
  def database_name; end

  # Returns a new persistence context that is consistent with the given
  # child document, inheriting most appropriate settings.
  #
  # @api private
  # @param document [Mongoid::Document | Class] the child document
  # @return [PersistenceContext] the new persistence context
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#59
  def for_child(document); end

  # The options defining this persistence context.
  #
  # @return [Hash] The persistence context options.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#20
  def options; end

  # The subset of provided options that may be used as storage
  # options.
  #
  # @api private
  # @return [Hash | nil] the requested storage options, or nil if
  #   none were specified.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#181
  def requested_storage_options; end

  # Whether the client of the context can be reused later, and therefore should
  # not be closed.
  #
  # If the persistence context is requested with :client option only, it means
  # that the context should use a client configured in mongoid.yml.
  # Such clients should not be closed when the context is cleared since they
  # will be reused later.
  #
  # @api private
  # @return [true | false] True if client can be reused, otherwise false.
  #
  # source://mongoid//lib/mongoid/persistence_context.rb#170
  def reusable_client?; end

  # source://mongoid//lib/mongoid/persistence_context.rb#15
  def storage_options(*_arg0, **_arg1, &_arg2); end

  private

  # source://mongoid//lib/mongoid/persistence_context.rb#197
  def __evaluate__(name); end

  # source://mongoid//lib/mongoid/persistence_context.rb#202
  def client_options; end

  # source://mongoid//lib/mongoid/persistence_context.rb#214
  def database_name_option; end

  # source://mongoid//lib/mongoid/persistence_context.rb#188
  def set_options!(opts); end

  class << self
    # Clear the persistence context for a particular class or model instance.
    #
    # @example Clear the persistence context for a class or model instance.
    #   PersistenceContext.clear(model)
    # @param cluster [Mongo::Cluster] The original cluster before this context was used.
    # @param object [Class | Object] The class or model instance.
    # @param original_context [Mongoid::PersistenceContext] The original persistence
    #   context that was set before this context was used.
    #
    # source://mongoid//lib/mongoid/persistence_context.rb#271
    def clear(object, cluster = T.unsafe(nil), original_context = T.unsafe(nil)); end

    # Get the persistence context for a particular class or model instance.
    #
    # @example Get the persistence context for a class or model instance.
    #   PersistenceContext.get(model)
    # @param object [Object] The class or model instance.
    # @return [Mongoid::PersistenceContext] The persistence context for the object.
    #
    # source://mongoid//lib/mongoid/persistence_context.rb#258
    def get(object); end

    # Set the persistence context for a particular class or model instance.
    #
    # If there already is a persistence context set, options in the existing
    # context are combined with options given to the set call.
    #
    # @example Set the persistence context for a class or model instance.
    #   PersistenceContext.set(model)
    # @param object [Object] The class or model instance.
    # @param options_or_context [Hash | Mongoid::PersistenceContext] The persistence
    #   options or a persistence context object.
    # @return [Mongoid::PersistenceContext] The persistence context for the object.
    #
    # source://mongoid//lib/mongoid/persistence_context.rb#235
    def set(object, options_or_context); end

    private

    # source://mongoid//lib/mongoid/persistence_context.rb#288
    def context_store; end

    # Get the persistence context for a given object from the thread local
    #   storage.
    #
    # @api private
    # @param object [Object] Object to get the persistance context for.
    # @return [Mongoid::PersistenceContext | nil] The persistence context
    #   for the object if previously stored, otherwise nil.
    #
    # source://mongoid//lib/mongoid/persistence_context.rb#301
    def get_context(object); end

    # Store persistence context for a given object in the thread local
    #   storage.
    #
    # @api private
    # @param context [Mongoid::PersistenceContext] Context to store
    # @param object [Object] Object to store the persistance context for.
    #
    # source://mongoid//lib/mongoid/persistence_context.rb#312
    def store_context(object, context); end
  end
end

# Extra options in addition to driver client options that determine the
# persistence context.
#
# @return [Array<Symbol>] The list of extra options besides client options
#   that determine the persistence context.
#
# source://mongoid//lib/mongoid/persistence_context.rb#27
Mongoid::PersistenceContext::EXTRA_OPTIONS = T.let(T.unsafe(nil), Array)

# The full list of valid persistence context options.
#
# @return [Array<Symbol>] The full list of options defining the persistence
#   context.
#
# source://mongoid//lib/mongoid/persistence_context.rb#36
Mongoid::PersistenceContext::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# Provides shared behavior for any document with "pluck" functionality.
#
# @api private
#
# source://mongoid//lib/mongoid/pluckable.rb#7
module Mongoid::Pluckable
  extend ::ActiveSupport::Concern

  private

  # Descend one level in the attribute hash.
  #
  #
  # @api private
  # @param current [Hash | Array<Hash>] The current level in the attribute hash.
  # @param field [Field|nil] The field to use for demongoization.
  # @param is_translation [Boolean] Whether the method is an _translations field.
  # @param method_name [String] The method name to descend to.
  # @param part [Integer] The current part index.
  # @param part_count [Integer] The total number of parts in the field name.
  # @return [Object] The value at the next level.
  #
  # source://mongoid//lib/mongoid/pluckable.rb#104
  def descend(part, current, method_name, field, part_count, is_translation); end

  # Extracts the value for the given field name from the given attribute
  # hash.
  #
  # @api private
  # @param attrs [Hash] The attributes hash.
  # @param field_name [String] The name of the field to extract.
  # @return [Object] The value for the given field name
  #
  # source://mongoid//lib/mongoid/pluckable.rb#65
  def extract_value(attrs, field_name, document_class); end

  # Fetch the element from the given hash and demongoize it using the
  # given field. If the obj is an array, map over it and call this method
  # on all of its elements.
  #
  # @api private
  # @param field [Field] The field to use for demongoization.
  # @param key [String] The key to fetch from the hash.
  # @param obj [Hash | Array<Hash>] The hash or array of hashes to fetch from.
  # @return [Object] The demongoized value.
  #
  # source://mongoid//lib/mongoid/pluckable.rb#49
  def fetch_and_demongoize(obj, key, field); end

  # Plucks the given field names from the given documents.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/pluckable.rb#33
  def pluck_from_documents(documents, field_names, document_class: T.unsafe(nil)); end

  # Prepares the field names for plucking by normalizing them to their
  # database field names. Also prepares a projection hash if requested.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/pluckable.rb#14
  def prepare_pluck(field_names, document_class: T.unsafe(nil), prepare_projection: T.unsafe(nil)); end
end

# This module is responsible for taking update selectors and switching out
# the indexes for the $ positional operator where appropriate.
#
# source://mongoid//lib/mongoid/positional.rb#8
module Mongoid::Positional
  # Takes the provided selector and atomic operations and replaces the
  # indexes of the embedded documents with the positional operator when
  # needed.
  #
  # @example Process the operations.
  #   positionally(
  #   { "_id" => 1, "addresses._id" => 2 },
  #   { "$set" => { "addresses.0.street" => "hobrecht" }}
  #   )
  # @note The only time we can accurately know when to use the positional
  #   operator is at the exact time we are going to persist something. So
  #   we can tell by the selector that we are sending if it is actually
  #   possible to use the positional operator at all. For example, if the
  #   selector is: { "_id" => 1 }, then we could not use the positional
  #   operator for updating embedded documents since there would never be a
  #   match - we base whether we can based on the number of levels deep the
  #   selector goes, and if the id values are not nil.
  # @param operations [Hash] The update operations.
  # @param processed [Hash] The processed update operations.
  # @param selector [Hash] The selector.
  # @return [Hash] The new operations.
  #
  # source://mongoid//lib/mongoid/positional.rb#34
  def positionally(selector, operations, processed = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/positional.rb#45
  def process_operations(keys, operations, processed); end

  # source://mongoid//lib/mongoid/positional.rb#52
  def process_updates(keys, update, updates = T.unsafe(nil)); end

  # source://mongoid//lib/mongoid/positional.rb#59
  def replace_index(keys, position); end
end

# Represents a value which cannot be type-casted between Ruby and MongoDB.
#
# source://mongoid//lib/mongoid/extensions/raw_value.rb#18
class Mongoid::RawValue
  # @return [RawValue] a new instance of RawValue
  #
  # source://mongoid//lib/mongoid/extensions/raw_value.rb#22
  def initialize(raw_value); end

  # Returns a string containing a human-readable representation of
  # the object, including the inspection of the underlying value.
  #
  # @return [String] The object inspection.
  #
  # source://mongoid//lib/mongoid/extensions/raw_value.rb#30
  def inspect; end

  # Returns the value of attribute raw_value.
  #
  # source://mongoid//lib/mongoid/extensions/raw_value.rb#20
  def raw_value; end
end

# This module handles reloading behavior of documents.
#
# source://mongoid//lib/mongoid/reloadable.rb#5
module Mongoid::Reloadable
  # Reloads the +Document+ attributes from the database. If the document has
  # not been saved then an error will get raised if the configuration option
  # was set. This can reload root documents or embedded documents.
  #
  # @example Reload the document.
  #   person.reload
  # @raise [Errors::DocumentNotFound] If the document was deleted.
  # @return [Document] The document, reloaded.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#16
  def reload; end

  private

  # Reload the document, determining if it's embedded or not and what
  # behavior to use.
  #
  # @example Reload the document.
  #   document._reload
  # @return [Hash] The reloaded attributes.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#79
  def _reload; end

  # Checks to see if the given attributes argument indicates that the object
  # has been deleted. If the attributes are nil or an empty Hash, then
  # we assume it has been deleted.
  #
  # If Mongoid.raise_not_found_error is false, this will do nothing.
  #
  # @param attributes [Hash | nil] The attributes hash retrieved from
  #   the database
  # @raise [Errors::DocumentNotFound] If the document was deleted.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#64
  def check_for_deleted_document!(attributes); end

  # Reload the embedded document.
  #
  # @example Reload the document.
  #   document.reload_embedded_document
  # @return [Hash] The reloaded attributes.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#99
  def reload_embedded_document; end

  # Reload the root document.
  #
  # @example Reload the document.
  #   document.reload_root_document
  # @return [Hash] The reloaded attributes.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#89
  def reload_root_document; end

  # Resets the current object using the given attributes.
  #
  # @param attributes [Hash] The attributes to use to replace the current
  #   attributes hash.
  #
  # source://mongoid//lib/mongoid/reloadable.rb#39
  def reset_object!(attributes); end
end

# This module contains behavior for all Mongoid scoping - named scopes,
# default scopes, and criteria accessors via scoped and unscoped.
#
# source://mongoid//lib/mongoid/scopable.rb#8
module Mongoid::Scopable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Scopable::ClassMethods

  private

  # Apply the default scoping to the attributes of the document, as long as
  # they are not complex queries.
  #
  # @api private
  # @example Apply the default scoping.
  #   document.apply_default_scoping
  # @return [true | false] If default scoping was applied.
  #
  # source://mongoid//lib/mongoid/scopable.rb#28
  def apply_default_scoping; end

  module GeneratedClassMethods
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
  end

  module GeneratedInstanceMethods
    def _declared_scopes; end
    def _declared_scopes=(value); end
    def _declared_scopes?; end
    def default_scoping; end
    def default_scoping=(value); end
    def default_scoping?; end
  end
end

# source://mongoid//lib/mongoid/scopable.rb#36
module Mongoid::Scopable::ClassMethods
  # Get a criteria with the default scope applied, if possible.
  #
  # @example Get a criteria with the default scope.
  #   Model.with_default_scope
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/scopable.rb#198
  def criteria; end

  # Is the class able to have the default scope applied?
  #
  # @example Can the default scope be applied?
  #   Band.default_scopable?
  # @return [true | false] If the default scope can be applied.
  #
  # source://mongoid//lib/mongoid/scopable.rb#95
  def default_scopable?; end

  # Add a default scope to the model. This scope will be applied to all
  # criteria unless #unscoped is specified.
  #
  # @example Define a default scope with a criteria.
  #   class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   default_scope where(active: true)
  #   end
  # @example Define a default scope with a proc.
  #   class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   default_scope ->{ where(active: true) }
  #   end
  # @param value [Proc | Criteria] The default scope.
  # @raise [Errors::InvalidScope] If the scope is not a proc or criteria.
  # @return [Proc] The default scope.
  #
  # source://mongoid//lib/mongoid/scopable.rb#83
  def default_scope(value = T.unsafe(nil)); end

  # Get a queryable, either the last one on the scope stack or a fresh one.
  #
  # @api private
  # @example Get a queryable.
  #   Model.queryable
  # @return [Criteria] The queryable.
  #
  # source://mongoid//lib/mongoid/scopable.rb#107
  def queryable; end

  # Create a scope that can be accessed from the class level or chained to
  # criteria by the provided name.
  #
  # @example Create named scopes.
  #
  #   class Person
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #   field :count, type: Integer
  #
  #   scope :active, -> { where(active: true) }
  #   scope :at_least, ->(count){ where(:count.gt => count) }
  #   end
  # @param name [Symbol] The name of the scope.
  # @param value [Proc] The conditions of the scope.
  # @raise [Errors::InvalidScope] If the scope is not a proc.
  # @raise [Errors::ScopeOverwrite] If the scope name already exists.
  #
  # source://mongoid//lib/mongoid/scopable.rb#132
  def scope(name, value, &block); end

  # Get a criteria for the document with normal scoping.
  #
  # @example Get the criteria.
  #   Band.scoped(skip: 10)
  # @note This will force the default scope to be applied.
  # @option options
  # @option options
  # @option options
  # @param options [Hash] Query options for the criteria.
  # @return [Criteria] A scoped criteria.
  #
  # source://mongoid//lib/mongoid/scopable.rb#158
  def scoped(options = T.unsafe(nil)); end

  # Returns a hash of all the scopes defined for this class, including
  # scopes defined on ancestor classes.
  #
  # @example Get the defined scopes for a class
  #   class Band
  #   include Mongoid::Document
  #   field :active, type: Boolean
  #
  #   scope :active, -> { where(active: true) }
  #   end
  #   Band.scopes
  # @return [Hash] The scopes defined for this class
  #
  # source://mongoid//lib/mongoid/scopable.rb#51
  def scopes; end

  # Get the criteria without any scoping applied.
  #
  # @example Get the unscoped criteria.
  #   Band.unscoped
  # @example Yield to block with no scoping.
  #   Band.unscoped do
  #   Band.where(name: "Depeche Mode")
  #   end
  # @note This will force the default scope, as well as any scope applied
  #   using ``.with_scope``, to be removed.
  # @return [Criteria | Object] The unscoped criteria or result of the
  #   block.
  #
  # source://mongoid//lib/mongoid/scopable.rb#177
  def unscoped; end

  # Get a criteria with the default scope applied, if possible.
  #
  # @example Get a criteria with the default scope.
  #   Model.with_default_scope
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/scopable.rb#195
  def with_default_scope; end

  # Pushes the provided criteria onto the scope stack, and removes it after the
  # provided block is yielded.
  #
  # @example Yield to the criteria.
  #   Person.with_scope(criteria)
  # @param criteria [Criteria] The criteria to apply.
  # @return [Criteria] The yielded criteria.
  #
  # source://mongoid//lib/mongoid/scopable.rb#209
  def with_scope(criteria); end

  # Execute the block without applying the default scope.
  #
  # @example Execute without the default scope.
  #   Band.without_default_scope do
  #   Band.where(name: "Depeche Mode")
  #   end
  # @return [Object] The result of the block.
  #
  # source://mongoid//lib/mongoid/scopable.rb#227
  def without_default_scope; end

  private

  # Warns or raises exception if overriding another scope or method.
  #
  # @api private
  # @example Warn or raise error if name exists.
  #   Model.check_scope_name("test")
  # @param name [String | Symbol] The name of the scope.
  # @raise [Errors::ScopeOverwrite] If the name exists and configured to
  #   raise the error.
  #
  # source://mongoid//lib/mongoid/scopable.rb#247
  def check_scope_name(name); end

  # Checks if the intended scope is a valid object, either a criteria or
  # proc with a criteria.
  #
  # @api private
  # @example Check if the scope is valid.
  #   Model.check_scope_validity({})
  # @param value [Object] The intended scope.
  # @raise [Errors::InvalidScope] If the scope is not a valid object.
  #
  # source://mongoid//lib/mongoid/scopable.rb#273
  def check_scope_validity(value); end

  # Defines the actual class method that will execute the scope when
  # called.
  #
  # @api private
  # @example Define the scope class method.
  #   Model.define_scope_method(:active)
  # @param name [Symbol] The method/scope name.
  # @return [Method] The defined method.
  #
  # source://mongoid//lib/mongoid/scopable.rb#290
  def define_scope_method(name); end

  # Process the default scope value. If one already exists, we merge the
  # new one into the old one.
  #
  # @api private
  # @example Process the default scope.
  #   Model.process_default_scope(value)
  # @param value [Criteria | Proc] The default scope value.
  #
  # source://mongoid//lib/mongoid/scopable.rb#319
  def process_default_scope(value); end
end

# Encapsulates behavior around managing search indexes. This feature
# is only supported when connected to an Atlas cluster.
#
# source://mongoid//lib/mongoid/search_indexable.rb#6
module Mongoid::SearchIndexable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::SearchIndexable::ClassMethods
end

# Implementations for the feature's class-level methods.
#
# source://mongoid//lib/mongoid/search_indexable.rb#59
module Mongoid::SearchIndexable::ClassMethods
  # Request the creation of all registered search indices. Note
  # that the search indexes are created asynchronously, and may take
  # several minutes to be fully available.
  #
  # @return [Array<String>] The names of the search indexes.
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#65
  def create_search_indexes; end

  # Removes the search index specified by the given name or id. Either
  # name OR id must be given, but not both.
  #
  # @param id [String | nil] the id of the index to remove
  # @param name [String | nil] the name of the index to remove
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#107
  def remove_search_index(name: T.unsafe(nil), id: T.unsafe(nil)); end

  # Request the removal of all registered search indexes. Note
  # that the search indexes are removed asynchronously, and may take
  # several minutes to be fully deleted.
  #
  # that have been declared on the model, but because the model may not
  # name the index, we can't guarantee that we'll know the name or id of
  # the corresponding indexes. It is not unreasonable to assume, though,
  # that the intention is for the model to declare, one-to-one, all
  # desired search indexes, so removing all search indexes ought to suffice.
  # If a specific index or set of indexes needs to be removed instead,
  # consider using search_indexes.each with remove_search_index.
  #
  # @note It would be nice if this could remove ONLY the search indexes
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#128
  def remove_search_indexes; end

  # Adds an index definition for the provided single or compound keys.
  #
  # @example Create a basic index.
  #   class Person
  #   include Mongoid::Document
  #   field :name, type: String
  #   search_index({ ... })
  #   search_index :name_of_index, { ... }
  #   end
  # @param defn [Hash] The search index definition.
  # @param name_or_defn [Symbol | String | Hash] Either the name of the index to
  #   define, or the index definition.
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#147
  def search_index(name_or_defn, defn = T.unsafe(nil)); end

  # A convenience method for querying the search indexes available on the
  # current model's collection.
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the options to pass through to the search
  #   index query.
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#98
  def search_indexes(options = T.unsafe(nil)); end

  # Waits for the named search indexes to be created.
  #
  # @param interval [Integer] the number of seconds to wait before
  #   polling again (only used when a progress callback is given).
  # @param names [Array<String>] the list of index names to wait for
  # @yield [SearchIndexable::Status] the status object
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#78
  def wait_for_search_indexes(names, interval: T.unsafe(nil)); end

  private

  # Retrieves the index records for the indexes with the given names.
  #
  # @param names [Array<String>] the index names to query
  # @return [Array<Hash>] the raw index documents
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#162
  def get_indexes(names); end
end

# Represents the status of the indexes returned by a search_indexes
# call.
#
# @api private
#
# source://mongoid//lib/mongoid/search_indexable.rb#13
class Mongoid::SearchIndexable::Status
  # Create a new Status object.
  #
  # @api private
  # @param indexes [Array<Hash>] the raw index documents
  # @return [Status] a new instance of Status
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#20
  def initialize(indexes); end

  # @api private
  # @return [Array<Hash>] the raw index documents
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#15
  def indexes; end

  # Returns the subset of indexes that have status == 'PENDING'
  #
  # @api private
  # @return [Array<Hash>] index documents for "pending" indices
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#34
  def pending; end

  # Returns the subset of indexes that are marked 'queryable'
  #
  # @api private
  # @return [Array<Hash>] index documents for 'queryable' indices
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#41
  def queryable; end

  # Returns the subset of indexes that have status == 'READY'
  #
  # @api private
  # @return [Array<Hash>] index documents for "ready" indices
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#27
  def ready; end

  # Returns true if all the given indexes are 'ready' and 'queryable'.
  #
  # @api private
  # @return [true | false] ready status of all indexes
  #
  # source://mongoid//lib/mongoid/search_indexable.rb#48
  def ready?; end
end

# Provides behavior for generating the selector for a specific document.
#
# source://mongoid//lib/mongoid/selectable.rb#7
module Mongoid::Selectable
  extend ::ActiveSupport::Concern

  # Get the atomic selector for the document. This is a hash in the simplest
  # case { "_id" => id }, but can become more complex for embedded documents
  # and documents that use a shard key.
  #
  # @example Get the document's atomic selector.
  #   document.atomic_selector
  # @return [Hash] The document's selector.
  #
  # source://mongoid//lib/mongoid/selectable.rb#18
  def atomic_selector; end

  private

  # Get the atomic selector for an embedded document.
  #
  # @api private
  # @example Get the embedded atomic selector.
  #   document.embedded_atomic_selector
  # @return [Hash] The embedded document selector.
  #
  # source://mongoid//lib/mongoid/selectable.rb#32
  def embedded_atomic_selector; end

  # Get the atomic selector that would match the existing version of the
  # root document.
  #
  # @api private
  # @return [Hash] The root document selector.
  #
  # source://mongoid//lib/mongoid/selectable.rb#46
  def root_atomic_selector_in_db; end
end

# This module provides the extra behavior for including associations in JSON
# and XML serialization.
#
# source://mongoid//lib/mongoid/serializable.rb#8
module Mongoid::Serializable
  extend ::ActiveSupport::Concern

  # Gets the document as a serializable hash, used by ActiveModel's JSON
  # serializer.
  #
  # @example Get the serializable hash with options.
  #   document.serializable_hash(:include => :addresses)
  # @example Get the serializable hash.
  #   document.serializable_hash
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options to pass.
  # @return [Hash] The document, ready to be serialized.
  #
  # source://mongoid//lib/mongoid/serializable.rb#47
  def serializable_hash(options = T.unsafe(nil)); end

  private

  # Get the names of all fields that will be serialized.
  #
  # @api private
  # @example Get all the field names.
  #   document.send(:field_names)
  # @return [Array<String>] The names of the fields.
  #
  # source://mongoid//lib/mongoid/serializable.rb#76
  def field_names(options); end

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the names.
  #
  # @example Get the association names.
  #   document.relation_names(:include => [ :addresses ])
  # @param inclusions [Hash | Symbol | Array<Symbol>] The inclusions.
  # @return [Array<Symbol>] The names of the included associations.
  #
  # source://mongoid//lib/mongoid/serializable.rb#148
  def relation_names(inclusions); end

  # Since the inclusions can be a hash, symbol, or array of symbols, this is
  # provided as a convenience to parse out the options.
  #
  # @example Get the association options.
  #   document.relation_names(:include => [ :addresses ])
  # @param inclusions [Hash | Symbol | Array<Symbol>] The inclusions.
  # @param name [Symbol] The name of the association.
  # @param options [Hash] The options.
  # @return [Hash] The options for the association.
  #
  # source://mongoid//lib/mongoid/serializable.rb#163
  def relation_options(inclusions, options, name); end

  # Serialize a single attribute. Handles associations, fields, and dynamic
  # attributes.
  #
  # @api private
  # @example Serialize the attribute.
  #   document.serialize_attribute({}, "id" , [ "id" ])
  # @param attrs [Hash] The attributes.
  # @param name [String] The attribute name.
  # @param names [Array<String>] The names of all attributes.
  # @param options [Hash] The options.
  # @return [Object] The attribute.
  #
  # source://mongoid//lib/mongoid/serializable.rb#105
  def serialize_attribute(attrs, name, names, options); end

  # For each of the provided include options, get the association needed and
  # provide it in the hash.
  #
  # @example Serialize the included associations.
  #   document.serialize_relations({}, :include => :addresses)
  # @option options
  # @option options
  # @option options
  # @param attributes [Hash] The attributes to serialize.
  # @param options [Hash] The serialization options.
  #
  # source://mongoid//lib/mongoid/serializable.rb#128
  def serialize_relations(attributes = T.unsafe(nil), options = T.unsafe(nil)); end
end

# This module contains behavior for adding shard key fields to updates.
#
# source://mongoid//lib/mongoid/shardable.rb#7
module Mongoid::Shardable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Shardable::ClassMethods

  # Returns the value for the named shard key. If the field identifies
  # an embedded document, the key will be parsed and recursively evaluated.
  # If `prefer_persisted` is true, the value last persisted to the database
  # will be returned, regardless of what the current value of the attribute
  # may be.
  #
  # @api private
  # @param field [String] The name of the field to evaluate
  # @param prefer_persisted [true|false] Whether or not to prefer the
  #   persisted value over the current value.
  # @return [Object] The value of the named field.
  #
  # source://mongoid//lib/mongoid/shardable.rb#96
  def shard_key_field_value(field, prefer_persisted:); end

  # Get the shard key fields.
  #
  # @example Get the shard key fields.
  #   model.shard_key_fields
  # @note Refactored from using delegate for class load performance.
  # @return [Array<String>] The shard key field names.
  #
  # source://mongoid//lib/mongoid/shardable.rb#47
  def shard_key_fields; end

  # Returns the selector that would match the defined shard keys. If
  # `prefer_persisted` is false (the default), it uses the current values
  # of the specified shard keys, otherwise, it will try to use whatever value
  # was most recently persisted.
  #
  # @api private
  # @param prefer_persisted [true | false] Whether to use the current
  #   value of the shard key fields, or to use their most recently persisted
  #   values.
  # @return [Hash] The shard key selector.
  #
  # source://mongoid//lib/mongoid/shardable.rb#63
  def shard_key_selector(prefer_persisted: T.unsafe(nil)); end

  # Returns the selector that would match the existing version of this
  # document in the database.
  #
  # If the document is not persisted, this method uses the current values
  # of the shard key fields. If the document is persisted, this method
  # uses the values retrieved from the database.
  #
  # @api private
  # @return [Hash] The shard key selector.
  #
  # source://mongoid//lib/mongoid/shardable.rb#79
  def shard_key_selector_in_db; end
end

# source://mongoid//lib/mongoid/shardable.rb#107
module Mongoid::Shardable::ClassMethods
  # Specifies a shard key with the field(s) specified.
  #
  # @example Specify the shard key.
  #
  #   class Person
  #   include Mongoid::Document
  #   field :first_name, :type => String
  #   field :last_name, :type => String
  #
  #   shard_key first_name: 1, last_name: 1
  #   end
  #
  # source://mongoid//lib/mongoid/shardable.rb#120
  def shard_key(*args); end
end

# Mixin module included into Mongoid::Document which adds behavior for
# getting the various lifecycle states a document can transition through.
#
# source://mongoid//lib/mongoid/stateful.rb#8
module Mongoid::Stateful
  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # @example Is the document flagged?
  #   document.flagged_for_destroy?
  # @return [true | false] If the document is flagged.
  #
  # source://mongoid//lib/mongoid/stateful.rb#77
  def _destroy; end

  # Sets the attribute destroyed
  #
  # @param value the value to set the attribute destroyed to.
  #
  # source://mongoid//lib/mongoid/stateful.rb#10
  def destroyed=(_arg0); end

  # Returns true if the +Document+ has been succesfully destroyed, and false
  # if it hasn't. This is determined by the variable @destroyed and NOT
  # by checking the database.
  #
  # @example Is the document destroyed?
  #   person.destroyed?
  # @return [true | false] True if destroyed, false if not.
  #
  # source://mongoid//lib/mongoid/stateful.rb#87
  def destroyed?; end

  # Sets the attribute flagged_for_destroy
  #
  # @param value the value to set the attribute flagged_for_destroy to.
  #
  # source://mongoid//lib/mongoid/stateful.rb#10
  def flagged_for_destroy=(_arg0); end

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # @example Is the document flagged?
  #   document.flagged_for_destroy?
  # @return [true | false] If the document is flagged.
  #
  # source://mongoid//lib/mongoid/stateful.rb#73
  def flagged_for_destroy?; end

  # Returns whether or not the document has been flagged for deletion, but
  # not destroyed yet. Used for atomic pulls of child documents.
  #
  # @example Is the document flagged?
  #   document.flagged_for_destroy?
  # @return [true | false] If the document is flagged.
  #
  # source://mongoid//lib/mongoid/stateful.rb#76
  def marked_for_destruction?; end

  # Sets whether the document has been persisted to the database.
  #
  # @param new_value [true | false] The value to set.
  # @return [true | false] The set value.
  #
  # source://mongoid//lib/mongoid/stateful.rb#17
  def new_record=(new_value); end

  # Returns true if the document has not been persisted to the database,
  # false if it has. This is determined by the variable @new_record
  # and NOT if the object has an id.
  #
  # @example Is the document new?
  #   person.new_record?
  # @return [true | false] True if new, false if not.
  #
  # source://mongoid//lib/mongoid/stateful.rb#33
  def new_record?; end

  # Checks if the document has been saved to the database. Returns false
  # if the document has been destroyed.
  #
  # @example Is the document persisted?
  #   person.persisted?
  # @return [true | false] True if persisted, false if not.
  #
  # source://mongoid//lib/mongoid/stateful.rb#53
  def persisted?; end

  # Sets the attribute previously_new_record
  #
  # @param value the value to set the attribute previously_new_record to.
  #
  # source://mongoid//lib/mongoid/stateful.rb#10
  def previously_new_record=(_arg0); end

  # Returns true if this document was just created -- that is, prior to the last
  # save, the object didn't exist in the database and new_record? would have
  # returned true.
  #
  # @return [true | false] True if was just created, false if not.
  #
  # source://mongoid//lib/mongoid/stateful.rb#42
  def previously_new_record?; end

  # Checks if the document was previously saved to the database
  # but now it has been deleted.
  #
  # @return [true | false] True if was persisted but now destroyed,
  #   otherwise false.
  #
  # source://mongoid//lib/mongoid/stateful.rb#62
  def previously_persisted?; end

  # Determine if the document can be pushed.
  #
  # @example Is this pushable?
  #   person.pushable?
  # @return [true | false] Is the document new and embedded?
  #
  # source://mongoid//lib/mongoid/stateful.rb#97
  def pushable?; end

  # Flags the document as readonly. Will cause a ReadonlyDocument error to be
  # raised if the document is attempted to be saved, updated or destroyed.
  #
  # @example Flag the document as readonly.
  #   document.readonly!
  # @return [true | false] true if the document was successfully marked
  #   readonly, false otherwise.
  #
  # source://mongoid//lib/mongoid/stateful.rb#112
  def readonly!; end

  # Is the document readonly?
  #
  # @example Is the document readonly?
  #   document.readonly?
  # @return [true | false] If the document is readonly.
  #
  # source://mongoid//lib/mongoid/stateful.rb#127
  def readonly?; end

  # Determine if the document can be set.
  #
  # @example Is this settable?
  #   person.settable?
  # @return [true | false] Is this document a new embeds one?
  #
  # source://mongoid//lib/mongoid/stateful.rb#141
  def settable?; end

  # Is the document updateable?
  #
  # @example Is the document updateable?
  #   person.updateable?
  # @return [true | false] If the document is changed and persisted.
  #
  # source://mongoid//lib/mongoid/stateful.rb#151
  def updateable?; end

  private

  # source://mongoid//lib/mongoid/stateful.rb#157
  def reset_readonly; end
end

# A class which sends values to the database as Strings but returns
# them to the user as Symbols.
#
# source://mongoid//lib/mongoid/stringified_symbol.rb#8
class Mongoid::StringifiedSymbol
  class << self
    # Convert the object from its mongo friendly ruby type to this type.
    #
    # @api private
    # @example Demongoize the object.
    #   Mongoid::StringifiedSymbol.demongoize('hedgehog')
    # @param object [Object] The object to demongoize.
    # @return [Symbol] The object.
    #
    # source://mongoid//lib/mongoid/stringified_symbol.rb#22
    def demongoize(object); end

    # Turn the object from the Ruby type into the type
    # type used in MQL queries.
    #
    # @api private
    # @example Evolve the object.
    #   Mongoid::StringifiedSymbol.evolve(:hedgehog)
    # @param object [Object] The object to evolve.
    # @return [String] The object evolved.
    #
    # source://mongoid//lib/mongoid/stringified_symbol.rb#60
    def evolve(object); end

    # Turn the object from the Ruby type into the type
    # type used for MongoDB persistence.
    #
    # @api private
    # @example Mongoize the object.
    #   Mongoid::StringifiedSymbol.mongoize(:hedgehog)
    # @param object [Object] The object to mongoize.
    # @return [String] The object mongoized.
    #
    # source://mongoid//lib/mongoid/stringified_symbol.rb#41
    def mongoize(object); end
  end
end

# source://mongoid//lib/mongoid/tasks/database.rb#5
module Mongoid::Tasks; end

# Utility module to manage database collections, indexes, sharding, etc.
# Invoked from Rake tasks.
#
# source://mongoid//lib/mongoid/tasks/database.rb#9
module Mongoid::Tasks::Database
  extend ::Mongoid::Tasks::Database

  # Create collections for each model given the provided globs and the class is
  # not embedded.
  #
  # @param force [true | false] If true, the method will drop existing
  #   collections before creating new ones. If false, the method will create
  #   only new collection (that do not exist in the database).
  # @param models. [Array<Mongoid::Document>] Array of document classes for
  #   which collections should be created. Defaulted to all document classes
  #   in the application.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#21
  def create_collections(models = T.unsafe(nil), force: T.unsafe(nil)); end

  # Create indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # @example Create all the indexes.
  #   Mongoid::Tasks::Database.create_indexes
  # @return [Array<Class>] The indexed models.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#42
  def create_indexes(models = T.unsafe(nil)); end

  # Submit requests for the search indexes to be created. This will happen
  # asynchronously. If "wait" is true, the method will block while it
  # waits for the indexes to be created.
  #
  # @param models [Array<Mongoid::Document>] the models to build search
  #   indexes for.
  # @param wait [true | false] whether to wait for the indexes to be
  #   built.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#67
  def create_search_indexes(models = T.unsafe(nil), wait: T.unsafe(nil)); end

  # Remove indexes for each model given the provided globs and the class is
  # not embedded.
  #
  # @example Remove all the indexes.
  #   Mongoid::Tasks::Database.remove_indexes
  # @return [Array<Class>] The un-indexed models.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#139
  def remove_indexes(models = T.unsafe(nil)); end

  # Remove all search indexes from the given models.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#155
  def remove_search_indexes(models = T.unsafe(nil)); end

  # Remove indexes that exist in the database but aren't specified on the
  # models.
  #
  # @example Remove undefined indexes.
  #   Mongoid::Tasks::Database.remove_undefined_indexes
  # @return [Hash{Class => Array(Hash)}] The list of indexes that were removed by model.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#118
  def remove_undefined_indexes(models = T.unsafe(nil)); end

  # Shard collections for models that declare shard keys.
  #
  # Returns the model classes that have had their collections sharded,
  # including model classes whose collections had already been sharded
  # prior to the invocation of this method.
  #
  # @example Shard all collections
  #   Mongoid::Tasks::Database.shard_collections
  # @return [Array<Class>] The sharded models
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#172
  def shard_collections(models = T.unsafe(nil)); end

  # Return the list of indexes by model that exist in the database but aren't
  # specified on the models.
  #
  # @example Return the list of unused indexes.
  #   Mongoid::Tasks::Database.undefined_indexes
  # @return [Array<Hash>] The list of undefined indexes by model.
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#86
  def undefined_indexes(models = T.unsafe(nil)); end

  private

  # source://mongoid//lib/mongoid/tasks/database.rb#247
  def logger; end

  # Waits for the search indexes to be built on the given models.
  #
  # @param models [Hash<Mongoid::Document, Array<String>>] a mapping of
  #   index names for each model
  #
  # source://mongoid//lib/mongoid/tasks/database.rb#255
  def wait_for_search_indexes(models); end
end

# This module contains helper methods for data encryption.
#
# source://mongoid//lib/mongoid/tasks/encryption.rb#7
module Mongoid::Tasks::Encryption
  extend ::Mongoid::Tasks::Encryption

  # Create a data encryption key for the given kms provider using the
  # auto_encryption_options from the client's configuration.
  #
  # @param client_name [String | nil] The name of the client to take
  #   auto_encryption_options from. If not provided, the default client
  #   will be used.
  # @param key_alt_name [String | nil] The alternate name of the key.
  # @param kms_provider_name [String | nil] The name of the kms provider
  #   to use. If not provided, the first provider in the client's
  #   auto_encryption_options will be used.
  # @return [Hash] A hash containing the key id as :key_id,
  #   kms provider name as :kms_provider, and key vault namespace as
  #   :key_vault_namespace.
  #
  # source://mongoid//lib/mongoid/tasks/encryption.rb#24
  def create_data_key(client_name: T.unsafe(nil), kms_provider_name: T.unsafe(nil), key_alt_name: T.unsafe(nil)); end

  private

  # Get kms provider name to use for creating a data key.
  #
  # If kms_provider_name is provided, it will be used. Otherwise, if there
  # is only one kms provider, that provider will be used. Otherwise, an
  # error will be raised.
  #
  # @param kms_provider_name [String | nil] The name of the kms provider
  #   as provided by the user.
  # @param kms_providers [Hash] The kms providers hash from the client's
  #   auto_encryption_options.
  # @return [String] The kms provider name to use for creating a data
  #   key.
  #
  # source://mongoid//lib/mongoid/tasks/encryption.rb#97
  def get_kms_provider_name(kms_provider_name, kms_providers); end

  # Prepare arguments needed to create a data key from the client's
  # auto_encryption_options.
  #
  # @param client_name [String | nil] The name of the client.
  # @param kms_provider_name [String | nil] The name of the kms provider.
  # @return [Array<String, Hash, String>] An array containing the
  #   normalized kms provider name, the kms providers hash, and the key
  #   vault namespace.
  #
  # source://mongoid//lib/mongoid/tasks/encryption.rb#58
  def prepare_arguments(kms_provider_name, client_name); end
end

# This module contains logic for easy access to objects that have a lifecycle
# on the current thread.
#
# source://mongoid//lib/mongoid/threaded/lifecycle.rb#5
module Mongoid::Threaded
  extend ::Mongoid::Threaded

  # Store a reference to the document that was modified inside a transaction
  # associated with the session.
  #
  # @param document [Mongoid::Document] Mongoid document that was modified.
  # @param session [Mongo::Session] Session in scope of which the document
  #   was modified.
  #
  # source://mongoid//lib/mongoid/threaded.rb#435
  def add_modified_document(session, document); end

  # Is the document autosaved on the current thread?
  #
  # @example Is the document autosaved?
  #   Threaded.autosaved?(doc)
  # @param document [Document] The document to check.
  # @return [true | false] If the document is autosaved.
  #
  # source://mongoid//lib/mongoid/threaded.rb#334
  def autosaved?(document); end

  # Get all autosaves on the current thread.
  #
  # @example Get all autosaves.
  #   Threaded.autosaves
  # @return [Hash] The current autosaves.
  #
  # source://mongoid//lib/mongoid/threaded.rb#356
  def autosaves; end

  # Get all autosaves on the current thread for the class.
  #
  # @example Get all autosaves.
  #   Threaded.autosaves_for(Person)
  # @param klass [Class] The class to check.
  # @return [Array] The current autosaves.
  #
  # source://mongoid//lib/mongoid/threaded.rb#378
  def autosaves_for(klass); end

  # Begin autosaving a document on the current thread.
  #
  # @example Begin autosave.
  #   Threaded.begin_autosave(doc)
  # @param document [Document] The document to autosave.
  #
  # source://mongoid//lib/mongoid/threaded.rb#185
  def begin_autosave(document); end

  # Begin entry into a named thread local stack.
  #
  # @example Begin entry into the stack.
  #   Threaded.begin_execution(:create)
  # @param name [String] The name of the stack
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid/threaded.rb#117
  def begin_execution(name); end

  # Begin validating a document on the current thread.
  #
  # @example Begin validation.
  #   Threaded.begin_validate(doc)
  # @param document [Document] The document to validate.
  #
  # source://mongoid//lib/mongoid/threaded.rb#195
  def begin_validate(document); end

  # Begin suppressing default scopes for given model on the current thread.
  #
  # @api private
  # @example Begin without default scope stack.
  #   Threaded.begin_without_default_scope(klass)
  # @param klass [Class] The model to suppress default scoping on.
  #
  # source://mongoid//lib/mongoid/threaded.rb#227
  def begin_without_default_scope(klass); end

  # Clears the set of modified documents for the given session, and return the
  # content of the set before the clearance.
  #
  # @param session [Mongo::Session] Session for which the modified documents
  #   set should be cleared.
  # @return [Set<Mongoid::Document>] Collection of modified documents before
  #   it was cleared.
  #
  # source://mongoid//lib/mongoid/threaded.rb#448
  def clear_modified_documents(session); end

  # Clear the cached session for this thread for a client.
  #
  # specifying `client` parameter.
  #
  # @note For backward compatibility it is allowed to call this method without
  # @param client [Mongo::Client | nil] The client to clear the session for.
  # @return [nil]
  #
  # source://mongoid//lib/mongoid/threaded.rb#425
  def clear_session(client: T.unsafe(nil)); end

  # Get the global client override.
  #
  # @example Get the global client override.
  #   Threaded.client_override
  # @return [String | Symbol] The override.
  #
  # source://mongoid//lib/mongoid/threaded.rb#249
  def client_override; end

  # Set the global client override.
  #
  # @example Set the global client override.
  #   Threaded.client_override = :testing
  # @param name [String | Symbol] The global override name.
  # @return [String | Symbol] The override.
  #
  # source://mongoid//lib/mongoid/threaded.rb#261
  def client_override=(name); end

  # Get the current Mongoid scope.
  #
  # @example Get the scope.
  #   Threaded.current_scope(klass)
  #   Threaded.current_scope
  # @param klass [Klass] The class type of the scope.
  # @return [Criteria] The scope.
  #
  # source://mongoid//lib/mongoid/threaded.rb#274
  def current_scope(klass = T.unsafe(nil)); end

  # Set the current Mongoid scope.
  #
  # @example Set the scope.
  #   Threaded.current_scope = scope
  # @param scope [Criteria] The current scope.
  # @return [Criteria] The scope.
  #
  # source://mongoid//lib/mongoid/threaded.rb#292
  def current_scope=(scope); end

  # Get the global database override.
  #
  # @example Get the global database override.
  #   Threaded.database_override
  # @return [String | Symbol] The override.
  #
  # source://mongoid//lib/mongoid/threaded.rb#127
  def database_override; end

  # Set the global database override.
  #
  # @example Set the global database override.
  #   Threaded.database_override = :testing
  # @param name [String | Symbol] The global override name.
  # @return [String | Symbol] The override.
  #
  # source://mongoid//lib/mongoid/threaded.rb#139
  def database_override=(name); end

  # Removes the named variable from thread-local storage.
  #
  # @param key [String | Symbol] the name of the variable to remove.
  #
  # source://mongoid//lib/mongoid/threaded.rb#84
  def delete(key); end

  # Indicates whether document callbacks should be invoked by default for
  # the current thread. Individual documents may further override the
  # callback behavior, but this will be used for the default behavior.
  #
  # @param flag [true | false] Whether or not document callbacks should be
  #   executed by default.
  #
  # source://mongoid//lib/mongoid/threaded.rb#474
  def execute_callbacks=(flag); end

  # Queries whether document callbacks should be executed by default for the
  # current thread.
  #
  # Unless otherwise indicated (by #execute_callbacks=), this will return
  # true.
  #
  # @return [true | false] Whether or not document callbacks should be
  #   executed by default.
  #
  # source://mongoid//lib/mongoid/threaded.rb#460
  def execute_callbacks?; end

  # Are in the middle of executing the named stack
  #
  # @example Are we in the stack execution?
  #   Threaded.executing?(:create)
  # @param name [Symbol] The name of the stack
  # @return [true] If the stack is being executed.
  #
  # source://mongoid//lib/mongoid/threaded.rb#151
  def executing?(name); end

  # Exit autosaving a document on the current thread.
  #
  # @example Exit autosave.
  #   Threaded.exit_autosave(doc)
  # @param document [Document] The document to autosave.
  #
  # source://mongoid//lib/mongoid/threaded.rb#205
  def exit_autosave(document); end

  # Exit from a named thread local stack.
  #
  # @example Exit from the stack.
  #   Threaded.exit_execution(:create)
  # @param name [Symbol] The name of the stack
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid/threaded.rb#163
  def exit_execution(name); end

  # Exit validating a document on the current thread.
  #
  # @example Exit validation.
  #   Threaded.exit_validate(doc)
  # @param document [Document] The document to validate.
  #
  # source://mongoid//lib/mongoid/threaded.rb#215
  def exit_validate(document); end

  # Exit suppressing default scopes for given model on the current thread.
  #
  # @api private
  # @example Exit without default scope stack.
  #   Threaded.exit_without_default_scope(klass)
  # @param klass [Class] The model to unsuppress default scoping on.
  #
  # source://mongoid//lib/mongoid/threaded.rb#239
  def exit_without_default_scope(klass); end

  # Queries the thread-local variable with the given name. If a block is
  # given, and the variable does not already exist, the return value of the
  # block will be set as the value of the variable before returning it.
  #
  # It is very important that applications (and espcially Mongoid)
  # use this method instead of Thread#[], since Thread#[] is actually for
  # fiber-local variables, and Mongoid uses Fibers as an implementation
  # detail in some callbacks. Putting thread-local state in a fiber-local
  # store will result in the state being invisible when relevant callbacks are
  # run in a different fiber.
  #
  # Affected callbacks are cascading callbacks on embedded children.
  #
  # @param default [Proc] an optional block that must return the default
  #   (initial) value of this variable.
  # @param key [String | Symbol] the name of the variable to query
  # @return [Object | nil] the value of the queried variable, or nil if
  #   it is not set and no default was given.
  #
  # source://mongoid//lib/mongoid/threaded.rb#59
  def get(key, &default); end

  # Get the cached session for this thread for a client.
  #
  # specifying `client` parameter.
  #
  # @note For backward compatibility it is allowed to call this method without
  # @param client [Mongo::Client | nil] The client to cache the session for.
  # @return [Mongo::Session | nil] The session cached on this thread or nil.
  #
  # source://mongoid//lib/mongoid/threaded.rb#413
  def get_session(client: T.unsafe(nil)); end

  # Queries the presence of a named variable in thread-local storage.
  #
  # @param key [String | Symbol] the name of the variable to query.
  # @return [true | false] whether the given variable is present or not.
  #
  # source://mongoid//lib/mongoid/threaded.rb#93
  def has?(key); end

  # Returns the thread store of modified documents.
  #
  # @api private
  # @return [Hash<Mongo::Session, Set<Mongoid::Document>>] The modified
  #   documents indexed by session.
  #
  # source://mongoid//lib/mongoid/threaded.rb#493
  def modified_documents; end

  # Returns the thread store of sessions.
  #
  # @api private
  # @return [Hash<Integer, Set>] The sessions indexed by client object ID.
  #
  # source://mongoid//lib/mongoid/threaded.rb#483
  def sessions; end

  # Sets a thread-local variable with the given name to the given value.
  # See #get for a discussion of why this method is necessary, and why
  # Thread#[]= should be avoided in cascading callbacks on embedded children.
  #
  # @param key [String | Symbol] the name of the variable to set.
  # @param value [Object | nil] the value of the variable to set (or `nil`
  #   if you wish to unset the variable)
  #
  # source://mongoid//lib/mongoid/threaded.rb#77
  def set(key, value); end

  # Set the current Mongoid scope. Safe for multi-model scope chaining.
  #
  # @example Set the scope.
  #   Threaded.current_scope(scope, klass)
  # @param klass [Class] The current model class.
  # @param scope [Criteria] The current scope.
  # @return [Criteria] The scope.
  #
  # source://mongoid//lib/mongoid/threaded.rb#305
  def set_current_scope(scope, klass); end

  # Cache a session for this thread for a client.
  #
  # specifying `client` parameter.
  #
  # @note For backward compatibility it is allowed to call this method without
  # @param client [Mongo::Client | nil] The client to cache the session for.
  # @param session [Mongo::Session] The session to save.
  #
  # source://mongoid//lib/mongoid/threaded.rb#401
  def set_session(session, client: T.unsafe(nil)); end

  # Get the named stack.
  #
  # @example Get a stack by name
  #   Threaded.stack(:create)
  # @param name [Symbol] The name of the stack
  # @return [Array] The stack.
  #
  # source://mongoid//lib/mongoid/threaded.rb#175
  def stack(name); end

  # Is the document validated on the current thread?
  #
  # @example Is the document validated?
  #   Threaded.validated?(doc)
  # @param document [Document] The document to check.
  # @return [true | false] If the document is validated.
  #
  # source://mongoid//lib/mongoid/threaded.rb#346
  def validated?(document); end

  # Get all validations on the current thread.
  #
  # @example Get all validations.
  #   Threaded.validations
  # @return [Hash] The current validations.
  #
  # source://mongoid//lib/mongoid/threaded.rb#366
  def validations; end

  # Get all validations on the current thread for the class.
  #
  # @example Get all validations.
  #   Threaded.validations_for(Person)
  # @param klass [Class] The class to check.
  # @return [Array] The current validations.
  #
  # source://mongoid//lib/mongoid/threaded.rb#390
  def validations_for(klass); end

  # Is the given klass' default scope suppressed on the current thread?
  #
  # @api private
  # @example Is the given klass' default scope suppressed?
  #   Threaded.without_default_scope?(klass)
  # @param klass [Class] The model to check for default scope suppression.
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/threaded.rb#322
  def without_default_scope?(klass); end

  private

  # Removes the given klass from the current scope, and tidies the current
  # scope list.
  #
  # @param klass [Class] the class to remove from the current scope.
  #
  # source://mongoid//lib/mongoid/threaded.rb#503
  def unset_current_scope(klass); end
end

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#7
Mongoid::Threaded::ASSIGN = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded.rb#20
Mongoid::Threaded::AUTOSAVES_KEY = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#6
Mongoid::Threaded::BIND = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#8
Mongoid::Threaded::BUILD = T.let(T.unsafe(nil), String)

# Constant for the key to store clients.
#
# source://mongoid//lib/mongoid/threaded.rb#12
Mongoid::Threaded::CLIENTS_KEY = T.let(T.unsafe(nil), String)

# The key to override the client.
#
# source://mongoid//lib/mongoid/threaded.rb#15
Mongoid::Threaded::CLIENT_OVERRIDE_KEY = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#10
Mongoid::Threaded::CREATE = T.let(T.unsafe(nil), String)

# The key for the current thread's scope stack.
#
# source://mongoid//lib/mongoid/threaded.rb#18
Mongoid::Threaded::CURRENT_SCOPE_KEY = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded.rb#9
Mongoid::Threaded::DATABASE_OVERRIDE_KEY = T.let(T.unsafe(nil), String)

# The key storing the default value for whether or not callbacks are
# executed on documents.
#
# source://mongoid//lib/mongoid/threaded.rb#36
Mongoid::Threaded::EXECUTE_CALLBACKS = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#9
Mongoid::Threaded::LOAD = T.let(T.unsafe(nil), String)

# This module contains convenience methods for document lifecycle that
# resides on thread locals.
#
# source://mongoid//lib/mongoid/threaded/lifecycle.rb#14
module Mongoid::Threaded::Lifecycle
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Threaded::Lifecycle::ClassMethods

  private

  # Begin the assignment of attributes. While in this block embedded
  # documents will not autosave themselves in order to allow the document to
  # be in a valid state.
  #
  # @example Execute the assignment.
  #   _assigning do
  #   person.attributes = { :addresses => [ address ] }
  #   end
  # @return [Object] The yielded value.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#29
  def _assigning; end

  # Is the current thread in assigning mode?
  #
  # @example Is the current thread in assigning mode?
  #   proxy._assigning?
  # @return [true | false] If the thread is assigning.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#42
  def _assigning?; end

  # Execute a block in binding mode.
  #
  # @example Execute in binding mode.
  #   binding do
  #   relation.push(doc)
  #   end
  # @return [Object] The return value of the block.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#54
  def _binding; end

  # Is the current thread in binding mode?
  #
  # @example Is the current thread in binding mode?
  #   proxy.binding?
  # @return [true | false] If the thread is binding.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#67
  def _binding?; end

  # Execute a block in building mode.
  #
  # @example Execute in building mode.
  #   _building do
  #   relation.push(doc)
  #   end
  # @return [Object] The return value of the block.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#79
  def _building; end

  # Is the current thread in building mode?
  #
  # @example Is the current thread in building mode?
  #   proxy._building?
  # @return [true | false] If the thread is building.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#92
  def _building?; end

  # Is the current thread in creating mode?
  #
  # @example Is the current thread in creating mode?
  #   proxy.creating?
  # @return [true | false] If the thread is creating.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#102
  def _creating?; end

  # Execute a block in loading mode.
  #
  # @example Execute in loading mode.
  #   _loading do
  #   relation.push(doc)
  #   end
  # @return [Object] The return value of the block.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#114
  def _loading; end

  # Is the current thread in loading mode?
  #
  # @example Is the current thread in loading mode?
  #   proxy._loading?
  # @return [true | false] If the thread is loading.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#127
  def _loading?; end
end

# source://mongoid//lib/mongoid/threaded/lifecycle.rb#131
module Mongoid::Threaded::Lifecycle::ClassMethods
  # Execute a block in creating mode.
  #
  # @example Execute in creating mode.
  #   creating do
  #   relation.push(doc)
  #   end
  # @return [Object] The return value of the block.
  #
  # source://mongoid//lib/mongoid/threaded/lifecycle.rb#141
  def _creating; end
end

# The key for storing documents modified inside transactions.
#
# source://mongoid//lib/mongoid/threaded.rb#32
Mongoid::Threaded::MODIFIED_DOCUMENTS_KEY = T.let(T.unsafe(nil), String)

# The key for the current thread's sessions.
#
# source://mongoid//lib/mongoid/threaded.rb#29
Mongoid::Threaded::SESSIONS_KEY = T.let(T.unsafe(nil), String)

# source://mongoid//lib/mongoid/threaded.rb#24
Mongoid::Threaded::STACK_KEYS = T.let(T.unsafe(nil), Hash)

# source://mongoid//lib/mongoid/threaded.rb#22
Mongoid::Threaded::VALIDATIONS_KEY = T.let(T.unsafe(nil), String)

# This module handles the behavior for setting up document created at and
# updated at timestamps.
#
# source://mongoid//lib/mongoid/timestamps/timeless.rb#5
module Mongoid::Timestamps
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
  include ::Mongoid::Timestamps::Updated

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods
end

# This module handles the behavior for setting up document created at
# timestamp.
#
# source://mongoid//lib/mongoid/timestamps/created/short.rb#6
module Mongoid::Timestamps::Created
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  # Is the created timestamp able to be set?
  #
  # @return [true, false] If the timestamp can be set.
  #
  # source://mongoid//lib/mongoid/timestamps/created.rb#37
  def able_to_set_created_at?; end

  # Update the created_at field on the Document to the current time. This is
  # only called on create.
  #
  # @example Set the created at time.
  #   person.set_created_at
  #
  # source://mongoid//lib/mongoid/timestamps/created.rb#25
  def set_created_at; end
end

# Adds a created_at timestamp to the document, but it is stored as c_at
# with a created_at alias.
#
# source://mongoid//lib/mongoid/timestamps/created/short.rb#10
module Mongoid::Timestamps::Created::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
end

# source://mongoid//lib/mongoid/timestamps/short.rb#6
module Mongoid::Timestamps::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Created
  include ::Mongoid::Timestamps::Updated

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods
end

# This module adds behavior for turning off timestamping in single or
# multiple calls.
#
# source://mongoid//lib/mongoid/timestamps/timeless.rb#9
module Mongoid::Timestamps::Timeless
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  # Clears out the timeless option.
  #
  # @example Clear the timeless option.
  #   document.clear_timeless_option
  # @return [true] True.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#18
  def clear_timeless_option; end

  # Begin an execution that should skip timestamping.
  #
  # @example Save a document but don't timestamp.
  #   person.timeless.save
  # @return [Document] The document this was called on.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#33
  def timeless; end

  # Returns whether the document should skip timestamping.
  #
  # @return [true | false] Whether the document should
  #   skip timestamping.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#42
  def timeless?; end

  class << self
    # source://mongoid//lib/mongoid/timestamps/timeless.rb#62
    def [](*_arg0, **_arg1, &_arg2); end

    # source://mongoid//lib/mongoid/timestamps/timeless.rb#62
    def []=(*_arg0, **_arg1, &_arg2); end

    # Returns the in-memory thread cache of classes
    # for which to skip timestamping.
    #
    # @api private
    # @return [Hash] The timeless table.
    #
    # source://mongoid//lib/mongoid/timestamps/timeless.rb#58
    def timeless_table; end
  end
end

# source://mongoid//lib/mongoid/timestamps/timeless.rb#67
module Mongoid::Timestamps::Timeless::ClassMethods
  # Removes the timeless option on the current class.
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#86
  def clear_timeless_option; end

  # Sets to remove the timeless option when the next
  # instance of the current class is updated.
  #
  # @return [true] Always true.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#98
  def clear_timeless_option_on_update; end

  # Clears the timeless counter for the current class
  # if the value has reached zero.
  #
  # @param counter [Integer] The counter value.
  # @return [Integer | nil] The counter value, or nil
  #   if the counter was cleared.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#113
  def set_timeless_counter(counter); end

  # Begin an execution that should skip timestamping.
  #
  # @example Create a document but don't timestamp.
  #   Person.timeless.create(:title => "Sir")
  # @return [Class] The class this was called on.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#75
  def timeless; end

  # Returns whether the current class should skip timestamping.
  #
  # @return [true | false] Whether the current class should
  #   skip timestamping.
  #
  # source://mongoid//lib/mongoid/timestamps/timeless.rb#121
  def timeless?; end
end

# This module handles the behavior for setting up document updated at
# timestamp.
#
# source://mongoid//lib/mongoid/timestamps/updated/short.rb#6
module Mongoid::Timestamps::Updated
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless

  mixes_in_class_methods ::Mongoid::Timestamps::Timeless::ClassMethods

  # Is the updated timestamp able to be set?
  #
  # @example Can the timestamp be set?
  #   document.able_to_set_updated_at?
  # @return [true | false] If the timestamp can be set.
  #
  # source://mongoid//lib/mongoid/timestamps/updated.rb#40
  def able_to_set_updated_at?; end

  # Update the updated_at field on the Document to the current time.
  # This is only called on create and on save.
  #
  # @example Set the updated at time.
  #   person.set_updated_at
  #
  # source://mongoid//lib/mongoid/timestamps/updated.rb#26
  def set_updated_at; end
end

# Adds an updated_at timestamp to the document, but it is stored as u_at
# with an updated_at alias.
#
# source://mongoid//lib/mongoid/timestamps/updated/short.rb#10
module Mongoid::Timestamps::Updated::Short
  extend ::ActiveSupport::Concern
  include ::Mongoid::Timestamps::Timeless
  include ::Mongoid::Timestamps::Updated
end

# Mixin module which is included in Mongoid::Document to add "touch"
# functionality to update a document's timestamp(s) atomically.
#
# source://mongoid//lib/mongoid/touchable.rb#8
module Mongoid::Touchable
  extend ::Mongoid::Touchable

  # Add the association to the touchable associations if the touch option was
  # provided.
  #
  # @example Add the touchable.
  #   Model.define_touchable!(assoc)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @return [Class] The model class.
  #
  # source://mongoid//lib/mongoid/touchable.rb#153
  def define_touchable!(association); end

  # Suppresses touch callbacks for the named class, for the duration of
  # the associated block.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/touchable.rb#170
  def suppress_touch_callbacks(name); end

  # Queries whether touch callbacks are being suppressed for the named
  # class.
  #
  # @api private
  # @return [true | false] Whether touch callbacks are suppressed.
  #
  # source://mongoid//lib/mongoid/touchable.rb#183
  def touch_callbacks_suppressed?(name); end

  private

  # Define the method that will get called for touching belongs_to
  # associations.
  #
  # @api private
  # @example Define the touch association.
  #   Model.define_relation_touch_method(:band)
  #   Model.define_relation_touch_method(:band, :band_updated_at)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  # @param name [Symbol] The name of the association.
  # @return [Symbol] The method name.
  #
  # source://mongoid//lib/mongoid/touchable.rb#214
  def define_relation_touch_method(name, association); end

  # Returns a hash to be used to store and query the various touch callback
  # suppression statuses for different classes.
  #
  # @return [Hash] The hash that contains touch callback suppression
  #   statuses
  #
  # source://mongoid//lib/mongoid/touchable.rb#197
  def touch_callback_statuses; end
end

# Used to provide mixin functionality.
#
# @todo Refactor using ActiveSupport::Concern
#
# source://mongoid//lib/mongoid/touchable.rb#13
module Mongoid::Touchable::InstanceMethods
  # Clears changes for the model caused by touch operation.
  #
  # @api private
  # @param field [Symbol] The name of an additional field to update.
  #
  # source://mongoid//lib/mongoid/touchable.rb#93
  def _clear_touch_updates(field = T.unsafe(nil)); end

  # Recursively sets touchable fields on the current document and each of its
  # parents, including the root node. Returns the combined atomic $set
  # operations to be performed on the root document.
  #
  # @api private
  # @param field [Symbol] The name of an additional field to update.
  # @param now [Time] The timestamp used for synchronizing the touched time.
  # @return [Hash<String, Time>] The touch operations to perform as an atomic $set.
  #
  # source://mongoid//lib/mongoid/touchable.rb#75
  def _gather_touch_updates(now, field = T.unsafe(nil)); end

  # Recursively runs :touch callbacks for the document and its parents,
  # beginning with the root document and cascading through each successive
  # child document.
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/touchable.rb#104
  def _run_touch_callbacks_from_root; end

  # Indicates whether the parent exists and is touchable.
  #
  # @api private
  # @return [Boolean]
  #
  # source://mongoid//lib/mongoid/touchable.rb#113
  def _touchable_parent?; end

  # Suppresses the invocation of touch callbacks, for the class that
  # includes this module, for the duration of the block.
  #
  # @api private
  # @example Suppress touch callbacks on Person documents:
  #   person.suppress_touch_callbacks { ... }
  #
  # source://mongoid//lib/mongoid/touchable.rb#22
  def suppress_touch_callbacks; end

  # Touch the document, in effect updating its updated_at timestamp and
  # optionally the provided field to the current time. If any belongs_to
  # associations exist with a touch option, they will be updated as well.
  #
  # @example Update the updated_at and provided timestamps.
  #   document.touch(:audited)
  # @example Update the updated_at timestamp.
  #   document.touch
  # @note This will not autobuild associations if those options are set.
  # @param field [Symbol] The name of an additional field to update.
  # @return [true/false] false if document is new_record otherwise true.
  #
  # source://mongoid//lib/mongoid/touchable.rb#51
  def touch(field = T.unsafe(nil)); end

  # Queries whether touch callbacks are being suppressed for the class
  # that includes this module.
  #
  # @api private
  # @return [true | false] Whether touch callbacks are suppressed.
  #
  # source://mongoid//lib/mongoid/touchable.rb#32
  def touch_callbacks_suppressed?; end

  private

  # Extract and remove the atomic updates for the touch operation(s)
  # from the currently enqueued atomic $set operations.
  #
  # @api private
  # @param field [Symbol] The optional field.
  # @return [Hash] The field-value pairs to update atomically.
  #
  # source://mongoid//lib/mongoid/touchable.rb#127
  def _extract_touches_from_atomic_sets(field = T.unsafe(nil)); end
end

# The key to use to store the active touch callback suppression statuses
#
# source://mongoid//lib/mongoid/touchable.rb#190
Mongoid::Touchable::SUPPRESS_TOUCH_CALLBACKS_KEY = T.let(T.unsafe(nil), String)

# Mixin module included in Mongoid::Document to provide behavior
# around traversing the document graph.
#
# source://mongoid//lib/mongoid/traversable.rb#9
module Mongoid::Traversable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::ClassMethods
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorRetrieval
  mixes_in_class_methods ::Mongoid::Traversable::DiscriminatorAssignment

  # Get all child +Documents+ to this +Document+
  #
  # @api private
  # @return [Array<Document>] All child documents in the hierarchy.
  #
  # source://mongoid//lib/mongoid/traversable.rb#236
  def _children(reset: T.unsafe(nil)); end

  # Get all descendant +Documents+ of this +Document+ recursively.
  # This is used when calling update persistence operations from
  # the root document, where changes in the entire tree need to be
  # determined. Note that persistence from the embedded documents will
  # always be preferred, since they are optimized calls... This operation
  # can get expensive in domains with large hierarchies.
  #
  # @api private
  # @return [Array<Document>] All descendant documents in the hierarchy.
  #
  # source://mongoid//lib/mongoid/traversable.rb#259
  def _descendants(reset: T.unsafe(nil)); end

  # Retrieves the parent document of this document.
  #
  # @api private
  # @return [Mongoid::Document | nil] the parent document
  #
  # source://mongoid//lib/mongoid/traversable.rb#109
  def _parent; end

  # Sets the parent document of this document.
  #
  # @api private
  # @param document [Mongoid::Document | nil] the document to set as
  #   the parent document.
  #
  # source://mongoid//lib/mongoid/traversable.rb#121
  def _parent=(document); end

  # Resets the memoized descendants on the object. Called internally when an
  # embedded array changes size.
  #
  # @api private
  # @return [nil] nil.
  #
  # source://mongoid//lib/mongoid/traversable.rb#386
  def _reset_memoized_descendants!; end

  # Return the root document in the object graph. If the current document
  # is the root object in the graph it will return self.
  #
  # @example Get the root document in the hierarchy.
  #   document._root
  # @return [Document] The root document in the hierarchy.
  #
  # source://mongoid//lib/mongoid/traversable.rb#399
  def _root; end

  # Is this document the root document of the hierarchy?
  #
  # @example Is the document the root?
  #   document._root?
  # @return [true | false] If the document is the root.
  #
  # source://mongoid//lib/mongoid/traversable.rb#411
  def _root?; end

  # Collect all the children of this document.
  #
  # @api private
  # @return [Array<Document>] The children.
  #
  # source://mongoid//lib/mongoid/traversable.rb#277
  def collect_children; end

  # Collect all the descendants of this document.
  #
  # @api private
  # @return [Array<Document>] The descendants.
  #
  # source://mongoid//lib/mongoid/traversable.rb#293
  def collect_descendants; end

  # Marks all descendants as being persisted.
  #
  # @return [Array<Document>] The flagged descendants.
  #
  # source://mongoid//lib/mongoid/traversable.rb#319
  def flag_descendants_persisted; end

  # Determines if the document is a subclass of another document.
  #
  # @example Check if the document is a subclass
  #   Square.new.hereditary?
  # @return [true | false] True if hereditary, false if not.
  #
  # source://mongoid//lib/mongoid/traversable.rb#331
  def hereditary?; end

  # Sets up a child/parent association. This is used for newly created
  # objects so they can be properly added to the graph.
  #
  # @example Set the parent document.
  #   document.parentize(parent)
  # @param document [Document] The parent document.
  # @return [Document] The parent document.
  #
  # source://mongoid//lib/mongoid/traversable.rb#344
  def parentize(document); end

  # Remove a child document from this parent. If an embeds one then set to
  # nil, otherwise remove from the embeds many.
  #
  # This is called from the +RemoveEmbedded+ persistence command.
  #
  # @example Remove the child.
  #   document.remove_child(child)
  # @param child [Document] The child (embedded) document to remove.
  #
  # source://mongoid//lib/mongoid/traversable.rb#357
  def remove_child(child); end

  # After descendants are persisted we can call this to move all their
  # changes and flag them as persisted in one call.
  #
  # @return [Array<Document>] The descendants.
  #
  # source://mongoid//lib/mongoid/traversable.rb#372
  def reset_persisted_descendants; end

  class << self
    # @api private
    #
    # source://mongoid//lib/mongoid/traversable.rb#17
    def __redefine(owner, name, value); end
  end

  module GeneratedClassMethods
    def discriminator_key; end
    def discriminator_key=(value); end
    def discriminator_key?; end
  end

  module GeneratedInstanceMethods; end
end

# Class-level methods for the Traversable behavior.
#
# source://mongoid//lib/mongoid/traversable.rb#36
module Mongoid::Traversable::ClassMethods
  # Determines if the document is a subclass of another document.
  #
  # @example Check if the document is a subclass.
  #   Square.hereditary?
  # @return [true | false] True if hereditary, false if not.
  #
  # source://mongoid//lib/mongoid/traversable.rb#43
  def hereditary?; end

  # When inheriting, we want to copy the fields from the parent class and
  # set the on the child to start, mimicking the behavior of the old
  # class_inheritable_accessor that was deprecated in Rails edge.
  #
  #
  # @example Inherit from this class.
  #   Person.inherited(Doctor)
  # @param subclass [Class] The inheriting class.
  #
  # source://mongoid//lib/mongoid/traversable.rb#69
  def inherited(subclass); end

  # Returns the root class of the STI tree that the current
  # class participates in. If the class is not an STI subclass, this
  # returns the class itself.
  #
  # @return [Mongoid::Document] the root of the STI tree
  #
  # source://mongoid//lib/mongoid/traversable.rb#52
  def root_class; end
end

# Module used for prepending to the various discriminator_*= methods
#
# @api private
#
# source://mongoid//lib/mongoid/traversable.rb#128
module Mongoid::Traversable::DiscriminatorAssignment
  # Sets the discriminator key.
  #
  # @api private
  # @param value [String] The discriminator key to set.
  # @raise [Errors::InvalidDiscriminatorKeyTarget]
  #
  # source://mongoid//lib/mongoid/traversable.rb#134
  def discriminator_key=(value); end

  # Returns the discriminator key.
  #
  # @api private
  # @return [String] The discriminator key.
  #
  # source://mongoid//lib/mongoid/traversable.rb#167
  def discriminator_value=(value); end
end

# Module used for prepending the discriminator_value method.
#
# A separate module was needed because the subclasses of this class
# need to be manually prepended with the discriminator_value and can't
# rely on being a class_attribute because the .discriminator_value
# method is overridden by every subclass in the inherited method.
#
# @api private
#
# source://mongoid//lib/mongoid/traversable.rb#183
module Mongoid::Traversable::DiscriminatorRetrieval
  # Get the name on the reading side if the discriminator_value is nil
  #
  # @api private
  #
  # source://mongoid//lib/mongoid/traversable.rb#185
  def discriminator_value; end
end

# Utility functions for Mongoid.
#
# @api private
#
# source://mongoid//lib/mongoid/utils.rb#7
module Mongoid::Utils
  extend ::Mongoid::Utils

  # This function should be used if you need to measure time.
  #
  # @api private
  # @example Calculate elapsed time.
  #   starting = Utils.monotonic_time
  #   # do something time consuming
  #   ending = Utils.monotonic_time
  #   puts "It took #{(ending - starting).to_i} seconds"
  # @return [Float] seconds according to monotonic clock
  # @see https://blog.dnsimple.com/2018/03/elapsed-time-with-ruby-the-right-way/
  #
  # source://mongoid//lib/mongoid/utils.rb#37
  def monotonic_time; end

  # Asks if the given value is a placeholder or not.
  #
  # @api private
  # @param value [Object] the value to compare
  # @return [true | false] if the value is a placeholder or not.
  #
  # source://mongoid//lib/mongoid/utils.rb#21
  def placeholder?(value); end

  # Returns true if the string is any of the following values: "1",
  # "yes", "true", "on". Anything else is assumed to be false. Case is
  # ignored, as are leading or trailing spaces.
  #
  # @api private
  # @param string [String] the string value to consider
  # @return [true | false]
  #
  # source://mongoid//lib/mongoid/utils.rb#48
  def truthy_string?(string); end
end

# A unique placeholder value that will never accidentally collide with
# valid values. This is useful as a default keyword argument value when
# you want the argument to be optional, but you also want to be able to
# recognize that the caller did not provide a value for it.
#
# @api private
#
# source://mongoid//lib/mongoid/utils.rb#14
Mongoid::Utils::PLACEHOLDER = T.let(T.unsafe(nil), Object)

# The current version of Mongoid
#
# Note that this file is automatically updated via `rake candidate:create`.
# Manual changes to this file will be overwritten by that rake task.
#
# source://mongoid//lib/mongoid/version.rb#8
Mongoid::VERSION = T.let(T.unsafe(nil), String)

# This module provides additional validations that ActiveModel does not
# provide: validates_associated and validates_uniqueness_of.
#
# source://mongoid//lib/mongoid/validatable/macros.rb#5
module Mongoid::Validatable
  extend ::ActiveSupport::Concern
  include ::Mongoid::Validatable::Macros

  mixes_in_class_methods ::Mongoid::Validatable::ClassMethods
  mixes_in_class_methods ::Mongoid::Validatable::Macros

  # Begin the associated validation.
  #
  # @example Begin validation.
  #   document.begin_validate
  #
  # source://mongoid//lib/mongoid/validatable.rb#30
  def begin_validate; end

  # Exit the associated validation.
  #
  # @example Exit validation.
  #   document.exit_validate
  #
  # source://mongoid//lib/mongoid/validatable.rb#38
  def exit_validate; end

  # Given the provided options, are we performing validations?
  #
  # @example Are we performing validations?
  #   document.performing_validations?(validate: true)
  # @option options
  # @param options [Hash] The options to check.
  # @return [true | false] If we are validating.
  #
  # source://mongoid//lib/mongoid/validatable.rb#60
  def performing_validations?(options = T.unsafe(nil)); end

  # Overrides the default ActiveModel behavior since we need to handle
  # validations of associations slightly different than just calling the
  # getter.
  #
  # @example Read the value.
  #   person.read_attribute_for_validation(:addresses)
  # @param attr [Symbol] The name of the field or association.
  # @return [Object] The value of the field or the association.
  #
  # source://mongoid//lib/mongoid/validatable.rb#74
  def read_attribute_for_validation(attr); end

  # Determine if the document is valid.
  #
  # @example Is the document valid in a context?
  #   person.valid?(:create)
  # @example Is the document valid?
  #   person.valid?
  # @param context [Symbol] The optional validation context.
  # @return [true | false] True if valid, false if not.
  #
  # source://mongoid//lib/mongoid/validatable.rb#99
  def valid?(context = T.unsafe(nil)); end

  # Used to prevent infinite loops in associated validations.
  #
  # @example Is the document validated?
  #   document.validated?
  # @return [true | false] Has the document already been validated?
  #
  # source://mongoid//lib/mongoid/validatable.rb#109
  def validated?; end

  # Perform a validation within the associated block.
  #
  # source://mongoid//lib/mongoid/validatable.rb#43
  def validating; end

  # Are we currently performing a validation that has a query?
  #
  # @example Are we validating with a query?
  #   document.validating_with_query?
  # @return [true | false] If we are validating with a query.
  #
  # source://mongoid//lib/mongoid/validatable.rb#119
  def validating_with_query?; end
end

# Validates whether or not an association is valid or not. Will correctly
# handle has one and has many associations.
#
# @example Set up the association validations.
#
#   class Person
#   include Mongoid::Document
#   embeds_one :name
#   embeds_many :addresses
#
#   validates_associated :name, :addresses
#   end
#
# source://mongoid//lib/mongoid/validatable/associated.rb#19
class Mongoid::Validatable::AssociatedValidator < ::ActiveModel::Validator
  # Required by `validates_with` so that the validator
  # gets added to the correct attributes.
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#22
  def attributes; end

  # Checks that the named associations of the given record
  # (`attributes`) are valid. This does NOT load the associations
  # from the database, and will only validate records that are dirty
  # or unpersisted.
  #
  # If anything is not valid, appropriate errors will be added to
  # the `document` parameter.
  #
  # @param document [Mongoid::Document] the document with the
  #   associations to validate.
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#36
  def validate(document); end

  private

  # Examine the given target object and return an array of
  # documents (possibly empty) that the target represents.
  #
  # @param target [Array | Mongoid::Document | Mongoid::Association::Proxy | HasMany::Enumerable] the target object to examine.
  # @return [Array<Mongoid::Document>] the list of documents
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#97
  def get_target_documents(target); end

  # Returns the list of all currently in-memory values held by
  # the target. The target will not be loaded.
  #
  # @param target [HasMany::Enumerable] the target that will
  #   be examined for in-memory documents.
  # @return [Array<Mongoid::Document>] the in-memory documents
  #   held by the target.
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#113
  def get_target_documents_for_has_many(target); end

  # Returns the target as an array. If the target represents a single
  # value, it is wrapped in an array.
  #
  # @param target [Array | Mongoid::Document | Mongoid::Association::Proxy] the target to return.
  # @return [Array<Mongoid::Document>] the target, as an array.
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#124
  def get_target_documents_for_other(target); end

  # Validates that the given association provided is either nil,
  # persisted and unchanged, or invalid. Otherwise, the appropriate errors
  # will be added to the parent document.
  #
  # @param attribute [Symbol] The association to validate.
  # @param document [Document] The document to validate.
  #
  # source://mongoid//lib/mongoid/validatable/associated.rb#50
  def validate_association(document, attribute); end
end

# source://mongoid//lib/mongoid/validatable.rb#123
module Mongoid::Validatable::ClassMethods
  # Adds an associated validator for the association if the validate option
  # was not provided or set to true.
  #
  # @example Set up validation.
  #   Person.validates_relation(association)
  # @param association [Mongoid::Association::Relatable] The association metadata.
  #
  # source://mongoid//lib/mongoid/validatable.rb#132
  def validates_relation(association); end

  # Add validation with the supplied validators for the provided fields
  # with options.
  #
  # @example Validate with a specific validator.
  #   validates_with MyValidator, on: :create
  # @note See ActiveModel::Validations::With for full options. This is
  #   overridden to add autosave functionality when presence validation is
  #   added.
  # @param *args [ActiveModel::Validator..., Hash] The validator classes
  #   and options hash.
  #
  # source://mongoid//lib/mongoid/validatable.rb#150
  def validates_with(*args, &block); end

  # Are we currently performing a validation that has a query?
  #
  # @example Are we validating with a query?
  #   Model.validating_with_query?
  # @return [true | false] If we are validating with a query.
  #
  # source://mongoid//lib/mongoid/validatable.rb#168
  def validating_with_query?; end
end

# Validates that the specified attributes do or do not match a certain
# regular expression.
#
# @example Set up the format validator.
#
#   class Person
#   include Mongoid::Document
#   field :website
#
#   validates_format_of :website, :with => URI.regexp
#   end
#
# source://mongoid//lib/mongoid/validatable/format.rb#18
class Mongoid::Validatable::FormatValidator < ::ActiveModel::Validations::FormatValidator
  include ::Mongoid::Validatable::Localizable
end

# Validates that the specified attributes do or do not match a certain
# length.
#
# @example Set up the length validator.
#
#   class Person
#   include Mongoid::Document
#   field :website
#
#   validates_length_of :website, in: 1..10
#   end
#
# source://mongoid//lib/mongoid/validatable/length.rb#18
class Mongoid::Validatable::LengthValidator < ::ActiveModel::Validations::LengthValidator
  include ::Mongoid::Validatable::Localizable
end

# Adds localization support to validations.
#
# source://mongoid//lib/mongoid/validatable/localizable.rb#8
module Mongoid::Validatable::Localizable
  # Validates each for localized fields.
  #
  # @example Validate localized fields.
  #   validator.validate_each(model, :name, "value")
  # @param attribute [Symbol | String] The attribute to validate.
  # @param document [Document] The document.
  # @param value [Object] The attribute value.
  #
  # source://mongoid//lib/mongoid/validatable/localizable.rb#18
  def validate_each(document, attribute, value); end
end

# Mixin module included in Mongoid::Document which adds various
# validation macro methods, such as +validates_presence_of+ and
# +validates_uniqueness_of+.
#
# source://mongoid//lib/mongoid/validatable/macros.rb#10
module Mongoid::Validatable::Macros
  extend ::ActiveSupport::Concern

  # Validates whether or not an association is valid or not. Will correctly
  # handle has one and has many associations.
  #
  # @example
  #
  #   class Person
  #   include Mongoid::Document
  #   embeds_one :name
  #   embeds_many :addresses
  #
  #   validates_associated :name, :addresses
  #   end
  # @param *args [Object...] The arguments to pass to the validator.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#27
  def validates_associated(*args); end

  # Validates the format of a field.
  #
  # @example
  #   class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_format_of :title, with: /\A[a-z0-9 \-_]*\z/i
  #   end
  # @param *args [Object...] The names of the field(s) to validate.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#59
  def validates_format_of(*args); end

  # Validates the length of a field.
  #
  # @example
  #   class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_length_of :title, minimum: 100
  #   end
  # @param *args [Object...] The names of the field(s) to validate.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#74
  def validates_length_of(*args); end

  # Validates whether or not a field contains a numeric value.
  #
  # @example
  #   class Person
  #   include Mongoid::Document
  #   field :cost
  #
  #   validates_numericality_of :cost
  #   end
  # @param *args [Object...] The names of the field(s) to validate.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#104
  def validates_numericality_of(*args); end

  # Validates whether or not a field is present - meaning nil or empty.
  #
  # @example
  #   class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_presence_of :title
  #   end
  # @param *args [Object...] The names of the field(s) to validate.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#89
  def validates_presence_of(*args); end

  # Validates whether or not a field is unique against the documents in the
  # database.
  #
  # @example
  #
  #   class Person
  #   include Mongoid::Document
  #   field :title
  #
  #   validates_uniqueness_of :title
  #   end
  # @param *args [Object...] The arguments to pass to the validator.
  #
  # source://mongoid//lib/mongoid/validatable/macros.rb#44
  def validates_uniqueness_of(*args); end
end

# A specialization of the ActiveModel numericality validator, which adds
# logic to recognize and accept BSON::Decimal128 as a number.
#
# source://mongoid//lib/mongoid/validatable/numericality.rb#7
class Mongoid::Validatable::NumericalityValidator < ::ActiveModel::Validations::NumericalityValidator
  private

  # Ensure that BSON::Decimal128 is treated as a BigDecimal during the
  # validation step.
  #
  # source://mongoid//lib/mongoid/validatable/numericality.rb#12
  def prepare_value_for_validation(value, record, attr_name); end
end

# Validates that the specified attributes are not blank (as defined by
# Object#blank?).
#
# @example Define the presence validator.
#
#   class Person
#   include Mongoid::Document
#   field :title
#
#   validates_presence_of :title
#   end
#
# source://mongoid//lib/mongoid/validatable/presence.rb#18
class Mongoid::Validatable::PresenceValidator < ::ActiveModel::EachValidator
  # Validate the document for the attribute and value.
  #
  # @example Validate the document.
  #   validator.validate_each(doc, :title, "")
  # @param attribute [Symbol] The attribute name.
  # @param document [Document] The document to validate.
  # @param value [Object] The current value of the field.
  #
  # source://mongoid//lib/mongoid/validatable/presence.rb#28
  def validate_each(document, attribute, value); end

  private

  # For guarding against false values.
  #
  # @api private
  # @example Is the value not present?
  #   validator.not_present?(value)
  # @param value [Object] The value.
  # @return [true | false] If the value is not present.
  #
  # source://mongoid//lib/mongoid/validatable/presence.rb#77
  def not_present?(value); end

  # Returns true if the association is blank or the foreign key is blank.
  #
  # @api private
  # @example Check is the association or fk is blank.
  #   validator.relation_or_fk_missing(doc, :name, "")
  # @param attr [Symbol] The attribute.
  # @param doc [Document] The document.
  # @param value [Object] The value.
  # @return [true | false] If the doc is missing.
  #
  # source://mongoid//lib/mongoid/validatable/presence.rb#61
  def relation_or_fk_missing?(doc, attr, value); end
end

# Mixin module included in Mongoid::Validatable::Uniqueness class
# when ensures that the persistence context is cleared when
# executing uniqueness queries.
#
# @api private
# @todo Move this into the Mongoid::Validatable::Uniqueness class.
#
# source://mongoid//lib/mongoid/validatable/queryable.rb#14
module Mongoid::Validatable::Queryable
  # Wrap the validation inside the an execution block that alert's the
  # client not to clear its persistence options.
  #
  # @api private
  # @example Execute the validation with a query.
  #   with_query(document) do
  #   #...
  #   end
  # @param document [Document] The document being validated.
  # @return [Object] The result of the yield.
  #
  # source://mongoid//lib/mongoid/validatable/queryable.rb#27
  def with_query(document); end
end

# Validates whether or not a field is unique against the documents in the
# database.
#
# It is also possible to limit the uniqueness constraint to a set of
# documents matching certain conditions:
#   class Person
#     include Mongoid::Document
#     field :title
#     field :active, type: Boolean
#
#     validates_uniqueness_of :title, conditions: -> {where(active: true)}
#   end
#
# @example Define the uniqueness validator.
#
#   class Person
#   include Mongoid::Document
#   field :title
#
#   validates_uniqueness_of :title
#   end
#
# source://mongoid//lib/mongoid/validatable/uniqueness.rb#28
class Mongoid::Validatable::UniquenessValidator < ::ActiveModel::EachValidator
  include ::Mongoid::Validatable::Queryable

  # Validate the document for uniqueness violations.
  #
  # @example Validate the document.
  #   validate_each(person, :title, "Sir")
  # @param attribute [Symbol] The field to validate on.
  # @param document [Document] The document to validate.
  # @param value [Object] The value of the field.
  # @return [Errors] The errors.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#41
  def validate_each(document, attribute, value); end

  private

  # Add the error to the document.
  #
  # @api private
  # @example Add the error.
  #   validator.add_error(doc, :name, "test")
  # @param attribute [Symbol] The name of the attribute.
  # @param document [Document] The document to validate.
  # @param value [Object] The value of the object.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#65
  def add_error(document, attribute, value); end

  # Should the uniqueness validation be case sensitive?
  #
  # @api private
  # @example Is the validation case sensitive?
  #   validator.case_sensitive?
  # @return [true | false] If the validation is case sensitive.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#79
  def case_sensitive?; end

  # Create the validation criteria.
  #
  # @api private
  # @example Create the criteria.
  #   validator.create_criteria(User, user, :name, "syd")
  # @param attribute [Symbol] The name of the attribute.
  # @param base [Class | Proxy] The base to execute the criteria from.
  # @param document [Document] The document to validate.
  # @param value [Object] The value of the object.
  # @return [Criteria] The criteria.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#96
  def create_criteria(base, document, attribute, value); end

  # Get the default criteria for checking uniqueness.
  #
  # @api private
  # @example Get the criteria.
  #   validator.criterion(person, :title, "Sir")
  # @param attribute [Symbol] The name of the attribute.
  # @param document [Document] The document to validate.
  # @param value [Object] The value of the object.
  # @return [Criteria] The uniqueness criteria.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#128
  def criterion(document, attribute, value); end

  # Filter the value based on whether the check is case sensitive or not.
  #
  # @api private
  # @example Filter the value.
  #   validator.filter("testing")
  # @param value [Object] The value to filter.
  # @return [Object | Regexp] The value, filtered or not.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#154
  def filter(value); end

  # Is the attribute localized?
  #
  # @api private
  # @example Is the attribute localized?
  #   validator.localized?(doc, :field)
  # @param attribute [Symbol] The attribute to validate.
  # @param document [Document] The document getting validated.
  # @return [true | false] If the attribute is localized.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#300
  def localized?(document, attribute); end

  # Scope the criteria to the scope options provided.
  #
  # @api private
  # @example Scope the criteria.
  #   validator.scope(criteria, document)
  # @param criteria [Criteria] The criteria to scope.
  # @param document [Document] The document being validated.
  # @return [Criteria] The scoped criteria.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#169
  def scope(criteria, document, _attribute); end

  # Scope reference has changed?
  #
  # @api private
  # @example Has scope reference changed?
  #   validator.scope_value_changed?(doc)
  # @param document [Document] The embedded document.
  # @return [true | false] If the scope reference has changed.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#201
  def scope_value_changed?(document); end

  # Should validation be skipped?
  #
  # @api private
  # @example Should the validation be skipped?
  #   validator.skip_validation?(doc)
  # @param document [Document] The embedded document.
  # @return [true | false] If the validation should be skipped.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#187
  def skip_validation?(document); end

  # Get the name of the field and the value to validate. This is for the
  # case when we validate an association via the association name and not the key,
  # we need to send the key name and value to the db, not the association
  # object.
  #
  # @api private
  # @example Get the name and key to validate.
  #   validator.to_validate(doc, :parent, Parent.new)
  # @param attribute [Symbol] The attribute getting validated.
  # @param document [Document] The doc getting validated.
  # @param value [Object] The value of the attribute.
  # @return [Array<Object, Object>] The field and value.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#222
  def to_validate(document, attribute, value); end

  # Validate an embedded document.
  #
  # @api private
  # @example Validate the embedded document.
  #   validator.validate_embedded(doc, :name, "test")
  # @param attribute [Symbol] The attribute name.
  # @param document [Document] The document.
  # @param value [Object] The value.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#241
  def validate_embedded(document, attribute, value); end

  # Validate a root document.
  #
  # @api private
  # @example Validate the root document.
  #   validator.validate_root(doc, :name, "test")
  # @param attribute [Symbol] The attribute name.
  # @param document [Document] The document.
  # @param value [Object] The value.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#260
  def validate_root(document, attribute, value); end

  # Are we required to validate the document?
  #
  # @example Is validation needed?
  #   validator.validation_required?(doc, :field)
  # @param attribute [Symbol] The attribute to validate.
  # @param document [Document] The document getting validated.
  # @return [true | false] If we need to validate.
  #
  # source://mongoid//lib/mongoid/validatable/uniqueness.rb#283
  def validation_required?(document, attribute); end
end

# Encapsulates behavior around logging and caching warnings so they are only
# logged once.
#
# @api private
#
# source://mongoid//lib/mongoid/warnings.rb#10
module Mongoid::Warnings
  class << self
    # source://mongoid//lib/mongoid/warnings.rb#22
    def warn_geo_haystack_deprecated; end

    # source://mongoid//lib/mongoid/warnings.rb#22
    def warn_legacy_readonly; end

    # source://mongoid//lib/mongoid/warnings.rb#22
    def warn_mutable_ids; end

    # source://mongoid//lib/mongoid/warnings.rb#22
    def warn_symbol_type_deprecated; end

    # Define a warning message method for the given id.
    #
    # @api private
    # @param id [Symbol] The warning identifier.
    # @param message [String] The warning message.
    #
    # source://mongoid//lib/mongoid/warnings.rb#20
    def warning(id, message); end
  end
end

class NilClass
  include ::BSON::Specialized
  include ::Mongoid::Extensions::NilClass
  include ::Mongoid::Criteria::Queryable::Extensions::NilClass
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::Mongoid::Extensions::Object
  include ::Mongoid::Criteria::Queryable::Extensions::Object
  extend ::Mongoid::Extensions::Object::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Object::ClassMethods
end

# source://mongoid//lib/rails/mongoid.rb#4
module Rails; end

# Mongoid utilities for Rails
#
# source://mongoid//lib/rails/mongoid.rb#7
module Rails::Mongoid
  extend ::Rails::Mongoid

  # Use the application configuration to get every model and require it, so
  # that indexing and inheritance work in both development and production
  # with the same results.
  #
  # @example Load all the application models.
  #   Rails::Mongoid.load_models(app)
  # @param app [Application] The rails application.
  #
  # source://mongoid//lib/rails/mongoid.rb#18
  def load_models(app); end

  # Conditionally calls `Rails::Mongoid.load_models(app)` if the
  # `::Mongoid.preload_models` is `true`.
  #
  # @param app [Application] The rails application.
  #
  # source://mongoid//lib/rails/mongoid.rb#26
  def preload_models(app); end
end

# Hooks Mongoid into Rails 3 and higher.
#
# source://mongoid//lib/mongoid/railtie.rb#11
class Rails::Mongoid::Railtie < ::Rails::Railtie
  # Rails runs all initializers first before getting into any generator
  # code, so we have no way in the intitializer to know if we are
  # generating a mongoid.yml. So instead of failing, we catch all the
  # errors and print them out.
  #
  # source://mongoid//lib/mongoid/railtie.rb#100
  def handle_configuration_error(e); end

  class << self
    # Mapping of rescued exceptions to HTTP responses
    #
    # @ return [Hash] rescued responses
    #
    # @example
    #   railtie.rescue_responses
    #
    # source://mongoid//lib/mongoid/railtie.rb#26
    def rescue_responses; end
  end
end

class Range
  include ::Enumerable
  include ::Mongoid::Extensions::Range
  include ::Mongoid::Criteria::Queryable::Extensions::Range
  extend ::Mongoid::Extensions::Range::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Range::ClassMethods
end

class Regexp
  include ::BSON::JSON
  include ::Mongoid::Criteria::Queryable::Extensions::Regexp
  extend ::Mongoid::Extensions::Regexp::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Regexp::ClassMethods
end

class Set
  include ::Enumerable
  include ::Mongoid::Extensions::Set
  extend ::Mongoid::Extensions::Set::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Set::ClassMethods
end

class String
  include ::Comparable
  include ::Mongoid::Extensions::String
  include ::Mongoid::Criteria::Queryable::Extensions::String
  extend ::Mongoid::Extensions::String::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::String::ClassMethods
end

class Symbol
  include ::Comparable
  include ::Mongoid::Extensions::Symbol
  include ::Mongoid::Criteria::Queryable::Extensions::Symbol
  extend ::Mongoid::Extensions::Symbol::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Symbol::ClassMethods
end

class Time
  include ::Comparable
  include ::Mongoid::Extensions::Time
  include ::Mongoid::Criteria::Queryable::Extensions::Time
  extend ::Mongoid::Extensions::Time::ClassMethods
  extend ::Mongoid::Criteria::Queryable::Extensions::Time::ClassMethods
end

class TrueClass
  include ::Mongoid::Extensions::TrueClass
end
