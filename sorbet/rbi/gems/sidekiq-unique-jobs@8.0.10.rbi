# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-unique-jobs` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq-unique-jobs`.


# Monkey patches for the ruby Array
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/core_ext.rb#116
class Array
  include ::Enumerable
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#0
class Concurrent::MutableStruct::ThreadSafeConfig < ::Concurrent::Synchronization::LockableObject
  include ::Concurrent::Synchronization::AbstractStruct
  include ::Concurrent::MutableStruct

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def current_redis_version; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def current_redis_version=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def debug_lua; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def debug_lua=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def enabled; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def enabled=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def lock_info; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def lock_info=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def lock_prefix; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def lock_prefix=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def lock_timeout; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def lock_timeout=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def lock_ttl; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def lock_ttl=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def locks; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def locks=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def logger; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def logger=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def logger_enabled; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def logger_enabled=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def max_history; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def max_history=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/synchronization/abstract_struct.rb#145
  def ns_initialize(*values); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def raise_on_config_error; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def raise_on_config_error=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper_count; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper_count=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper_interval; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper_interval=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper_resurrector_enabled; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper_resurrector_enabled=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper_resurrector_interval; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper_resurrector_interval=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def reaper_timeout; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def reaper_timeout=(value); end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#226
  def strategies; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/mutable_struct.rb#229
  def strategies=(value); end

  class << self
    # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/synchronization/safe_initialization.rb#29
    def [](*args, &block); end
  end
end

# Monkey patches for the ruby Hash
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/core_ext.rb#8
class Hash
  include ::Enumerable

  private

  # support methods for deep transforming nested hashes and arrays
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/core_ext.rb#98
  def _deep_transform_keys_in_object(object, &block); end
end

# See Sidekiq gem for more details
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#8
module Sidekiq
  class << self
    # source://sidekiq/7.3.4/lib/sidekiq.rb#136
    def configure_client; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#124
    def configure_embed(&block); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#97
    def configure_server(&block); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#89
    def default_configuration; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#85
    def default_job_options; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#81
    def default_job_options=(hash); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#57
    def dump_json(object); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#65
    def ent?; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#102
    def freeze!; end

    # source://sidekiq/7.3.4/lib/sidekiq/version.rb#7
    def gem_version; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#53
    def load_json(string); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#93
    def logger; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#61
    def pro?; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#73
    def redis(&block); end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#69
    def redis_pool; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#49
    def server?; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#77
    def strict_args!(mode = T.unsafe(nil)); end

    # source://sidekiq/7.3.4/lib/sidekiq/transaction_aware_client.rb#40
    def transactional_push!; end

    # source://sidekiq/7.3.4/lib/sidekiq.rb#45
    def ❨╯°□°❩╯︵┻━┻; end
  end
end

# See Sidekiq::Api
#
# @api private
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#72
class Sidekiq::JobRecord
  include ::Sidekiq::JobRecord::UniqueExtension

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#347
  def initialize(item, queue_name = T.unsafe(nil)); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#460
  def [](name); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#412
  def args; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#420
  def bid; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#428
  def created_at; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#82
  def delete; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#390
  def display_args; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#373
  def display_class; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#424
  def enqueued_at; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#436
  def error_backtrace; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#337
  def item; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#416
  def jid; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#369
  def klass; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#446
  def latency; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#356
  def parse(item); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#343
  def queue; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#432
  def tags; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#340
  def value; end

  private

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#472
  def deserialize_argument(argument); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#488
  def serialized_global_id?(hash); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#492
  def uncompress_backtrace(backtrace); end
end

# Provides extensions for unlocking jobs that are removed and deleted
#
# @api private
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#78
module Sidekiq::JobRecord::UniqueExtension
  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#82
  def delete; end
end

# See Sidekiq::Api
#
# @api private
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#112
class Sidekiq::JobSet < ::Sidekiq::SortedSet
  include ::Sidekiq::JobSet::UniqueExtension

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#747
  def delete(score, jid); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#747
  def delete_by_jid(score, jid); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#134
  def delete_by_value(name, value); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#671
  def each; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#699
  def fetch(score, jid = T.unsafe(nil)); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#724
  def find_job(jid); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#665
  def schedule(timestamp, job); end
end

# Provides extensions for unlocking jobs that are removed and deleted
#
# @api private
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#118
module Sidekiq::JobSet::UniqueExtension
  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#122
  def clear; end

  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  # @param name [String] the name of the key
  # @param value [String] a sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#134
  def delete_by_value(name, value); end
end

# See Sidekiq::Api
#
# @api private
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#92
class Sidekiq::Queue
  include ::Sidekiq::Queue::UniqueExtension

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#241
  def initialize(name = T.unsafe(nil)); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#324
  def as_json(options = T.unsafe(nil)); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#102
  def clear; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#275
  def each; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#305
  def find_job(jid); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#264
  def latency; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#238
  def name; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#255
  def paused?; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#250
  def size; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#311
  def 💣; end

  class << self
    # source://sidekiq/7.3.4/lib/sidekiq/api.rb#234
    def all; end
  end
end

# Provides extensions for unlocking jobs that are removed and deleted
#
# @api private
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#98
module Sidekiq::Queue::UniqueExtension
  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#102
  def clear; end
end

# See Sidekiq::Api
#
# @api private
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#47
class Sidekiq::ScheduledSet < ::Sidekiq::JobSet
  include ::Sidekiq::ScheduledSet::UniqueExtension

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#775
  def initialize; end
end

# Provides extensions for unlocking jobs that are removed and deleted
#
# @api private
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#53
module Sidekiq::ScheduledSet::UniqueExtension
  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  # @param score [Integer, Float] the score in the scheduled set
  # @param job_id [String] the Sidekiq JID
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#61
  def delete(score, job_id); end
end

# See Sidekiq::Api
#
# @api private
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#10
class Sidekiq::SortedEntry < ::Sidekiq::JobRecord
  include ::Sidekiq::SortedEntry::UniqueExtension

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#509
  def initialize(parent, score, item); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#540
  def add_to_queue; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#516
  def at; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#23
  def delete; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#564
  def error?; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#558
  def kill; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#505
  def parent; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#532
  def reschedule(at); end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#549
  def retry; end

  # source://sidekiq/7.3.4/lib/sidekiq/api.rb#504
  def score; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#35
  def remove_job; end
end

# Provides extensions for unlocking jobs that are removed and deleted
#
# @api private
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#16
module Sidekiq::SortedEntry::UniqueExtension
  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  # @return [Hash] the deleted sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#23
  def delete; end

  private

  # Wraps the original method to ensure locks for the job are deleted
  #
  # @api private
  # @yieldparam message [Hash] the sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_ext.rb#35
  def remove_job; end
end

# Contains configuration and utility methods that belongs top level
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#3
module SidekiqUniqueJobs
  include ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::JSON

  private

  # The current configuration (See: {.configure} on how to configure)
  #
  # @return [SidekiqUniqueJobs::Config] the gem configuration
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#19
  def config; end

  # Configure the gem
  #
  # This is usually called once at startup of an application
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] global gem options
  # @yield control to the caller when given block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#184
  def configure(options = T.unsafe(nil)); end

  # Attempt to constantize a string worker_class argument, always
  # failing back to the original argument when the constant can't be found
  #
  # @return [Sidekiq::Job]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#254
  def constantize(str); end

  # Disable SidekiqUniuqeJobs either temporarily in a block or for good
  #
  # @return [false] when not given a block
  # @return [true, false] the previous value of enable when given a block
  # @yieldreturn [void] temporarily disable sidekiq unique jobs while executing a block of code
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#134
  def disable!(&block); end

  # Checks if the gem has been disabled
  #
  # @return [true] when config.enabled is false
  # @return [false] when config.enabled is true
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#154
  def disabled?; end

  # Enable SidekiqUniuqeJobs either temporarily in a block or for good
  #
  # @return [true] when not given a block
  # @return [true, false] the previous value of enable when given a block
  # @yieldreturn [void] temporarily enable sidekiq unique jobs while executing a block of code
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#122
  def enable!(&block); end

  # Checks if the gem has been disabled
  #
  # @return [true] when config.enabled is true
  # @return [false] when config.enabled is false
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#144
  def enabled?; end

  # Returns the current redis version
  #
  # @return [String] a string like `5.0.2`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#200
  def fetch_redis_version; end

  # The current locks
  #
  # @return [Hash<Symbol, SidekiqUniqueJobs::BaseLock>] the configured locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#39
  def locks; end

  # The current logger
  #
  # @return [Logger] the configured logger
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#49
  def logger; end

  # Set a new logger
  #
  # @param other [Logger] another logger
  # @return [Logger] the new logger
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#70
  def logger=(other); end

  # Check if logging is enabled
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#80
  def logging?; end

  # Current time
  #
  # @return [Time]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#220
  def now; end

  # Current time as float
  #
  # @return [Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#210
  def now_f; end

  # Yields notification stack for sidekiq unique jobs to configure notifications
  #
  # @return [void] <description>
  # @yieldparam x [Reflections] used to configure notifications
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#301
  def reflect; end

  # Collection with notifications
  #
  # @return [Reflections]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#290
  def reflections; end

  # Resets configuration to deafult
  #
  # @return [SidekiqUniqueJobs::Config] a default gem configuration
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#110
  def reset!; end

  # Attempt to constantize a string worker_class argument, always
  # failing back to the original argument when the constant can't be found
  #
  # @return [Sidekiq::Job, String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#273
  def safe_constantize(str); end

  # The current strategies
  #
  # @return [Hash<Symbol, SidekiqUniqueJobs::Strategy>] the configured locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#29
  def strategies; end

  # Toggles enabled on or off
  #
  #
  # @api private
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#163
  def toggle(enabled); end

  # Temporarily use another configuration and reset to the old config after yielding
  #
  # @param tmp_config [Hash] the temporary configuration to use
  # @return [void]
  # @yield control to the caller
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#92
  def use_config(tmp_config = T.unsafe(nil)); end

  # Checks that the worker is valid with the given options
  #
  # @param options [Hash] the `sidekiq_options` to validate
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#231
  def validate_worker(options); end

  # Checks that the worker is valid with the given options
  #
  # @param options [Hash] the `sidekiq_options` to validate
  # @raise [InvalidWorker] when {#validate_worker} returns false or nil
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#245
  def validate_worker!(options); end

  # The current gem version
  #
  # @return [String] the current gem version
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#59
  def version; end

  class << self
    # The current configuration (See: {.configure} on how to configure)
    #
    # @return [SidekiqUniqueJobs::Config] the gem configuration
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#19
    def config; end

    # Configure the gem
    #
    # This is usually called once at startup of an application
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param options [Hash] global gem options
    # @yield control to the caller when given block
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#184
    def configure(options = T.unsafe(nil)); end

    # Attempt to constantize a string worker_class argument, always
    # failing back to the original argument when the constant can't be found
    #
    # @return [Sidekiq::Job]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#254
    def constantize(str); end

    # Disable SidekiqUniuqeJobs either temporarily in a block or for good
    #
    # @return [false] when not given a block
    # @return [true, false] the previous value of enable when given a block
    # @yieldreturn [void] temporarily disable sidekiq unique jobs while executing a block of code
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#134
    def disable!(&block); end

    # Checks if the gem has been disabled
    #
    # @return [true] when config.enabled is false
    # @return [false] when config.enabled is true
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#154
    def disabled?; end

    # Enable SidekiqUniuqeJobs either temporarily in a block or for good
    #
    # @return [true] when not given a block
    # @return [true, false] the previous value of enable when given a block
    # @yieldreturn [void] temporarily enable sidekiq unique jobs while executing a block of code
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#122
    def enable!(&block); end

    # Checks if the gem has been disabled
    #
    # @return [true] when config.enabled is true
    # @return [false] when config.enabled is false
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#144
    def enabled?; end

    # Returns the current redis version
    #
    # @return [String] a string like `5.0.2`
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#200
    def fetch_redis_version; end

    # The current locks
    #
    # @return [Hash<Symbol, SidekiqUniqueJobs::BaseLock>] the configured locks
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#39
    def locks; end

    # The current logger
    #
    # @return [Logger] the configured logger
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#49
    def logger; end

    # Set a new logger
    #
    # @param other [Logger] another logger
    # @return [Logger] the new logger
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#70
    def logger=(other); end

    # Check if logging is enabled
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#80
    def logging?; end

    # Current time
    #
    # @return [Time]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#220
    def now; end

    # Current time as float
    #
    # @return [Float]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#210
    def now_f; end

    # Yields notification stack for sidekiq unique jobs to configure notifications
    #
    # @return [void] <description>
    # @yieldparam x [Reflections] used to configure notifications
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#301
    def reflect; end

    # Collection with notifications
    #
    # @return [Reflections]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#290
    def reflections; end

    # Resets configuration to deafult
    #
    # @return [SidekiqUniqueJobs::Config] a default gem configuration
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#110
    def reset!; end

    # Attempt to constantize a string worker_class argument, always
    # failing back to the original argument when the constant can't be found
    #
    # @return [Sidekiq::Job, String]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#273
    def safe_constantize(str); end

    # The current strategies
    #
    # @return [Hash<Symbol, SidekiqUniqueJobs::Strategy>] the configured locks
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#29
    def strategies; end

    # Toggles enabled on or off
    #
    #
    # @api private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#163
    def toggle(enabled); end

    # Temporarily use another configuration and reset to the old config after yielding
    #
    # @param tmp_config [Hash] the temporary configuration to use
    # @return [void]
    # @yield control to the caller
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#92
    def use_config(tmp_config = T.unsafe(nil)); end

    # Checks that the worker is valid with the given options
    #
    # @param options [Hash] the `sidekiq_options` to validate
    # @raise [NotUniqueWorker]
    # @return [Boolean]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#231
    def validate_worker(options); end

    # Checks that the worker is valid with the given options
    #
    # @param options [Hash] the `sidekiq_options` to validate
    # @raise [InvalidWorker] when {#validate_worker} returns false or nil
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#245
    def validate_worker!(options); end

    # The current gem version
    #
    # @return [String] the current gem version
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_unique_jobs.rb#59
    def version; end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#10
SidekiqUniqueJobs::APARTMENT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#9
SidekiqUniqueJobs::ARGS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#11
SidekiqUniqueJobs::AT = T.let(T.unsafe(nil), String)

# Class BatchDelete provides batch deletion of digests
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#9
class SidekiqUniqueJobs::BatchDelete
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging

  # Initialize a new batch delete instance
  #
  # @param digests [Array<String>] the digests to delete
  # @param conn [Redis] the connection to use for deletion
  # @return [BatchDelete] a new instance of BatchDelete
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#57
  def initialize(digests, conn); end

  # Executes a batch deletion of the provided digests
  #
  # @note Just wraps batch_delete to be able to provide no connection
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#71
  def call; end

  # Returns the value of attribute conn.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#37
  def conn; end

  # Returns the value of attribute digests.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#33
  def digests; end

  private

  # Does the actual batch deletion
  #
  # @return [Integer] the number of deleted digests
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#88
  def batch_delete(conn); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#103
  def del_digest(pipeline, digest); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#109
  def keys_for_digest(digest); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#116
  def redis_version; end

  class << self
    # Executes a batch deletion of the provided digests
    #
    # @param digests [Array<String>] the digests to delete
    # @param conn [Redis] the connection to use for deletion
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#47
    def call(digests, conn = T.unsafe(nil)); end
  end
end

# @return [Integer] the default batch size
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#12
SidekiqUniqueJobs::BatchDelete::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# @return [Array<String>] Supported key suffixes
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/batch_delete.rb#16
SidekiqUniqueJobs::BatchDelete::SUFFIXES = T.let(T.unsafe(nil), Array)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#12
SidekiqUniqueJobs::CHANGELOGS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#13
SidekiqUniqueJobs::CLASS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#14
SidekiqUniqueJobs::CREATED_AT = T.let(T.unsafe(nil), String)

# Class Changelogs provides access to the changelog entries
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/changelog.rb#9
class SidekiqUniqueJobs::Changelog < ::SidekiqUniqueJobs::Redis::SortedSet
  # @return [Changelog] a new instance of Changelog
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/changelog.rb#10
  def initialize; end

  # Adds a new changelog entry
  #
  # @param message [String] a descriptive message about the entry
  # @param digest [String] a unique digest
  # @param job_id [String] a Sidekiq JID
  # @param script [String] the name of the script adding the entry
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/changelog.rb#24
  def add(message:, digest:, job_id:, script:); end

  # The change log entries
  #
  # @param pattern [String] the pattern to match
  # @param count [Integer] the number of matches to return
  # @return [Array<Hash>] an array of entries
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/changelog.rb#37
  def entries(pattern: T.unsafe(nil), count: T.unsafe(nil)); end

  # Paginate the changelog entries
  #
  # @param cursor [Integer] the cursor for this iteration
  # @param pattern [String] "*" the pattern to match
  # @param page_size [Integer] 100 the number of matches to return
  # @return [Array<Integer, Integer, Array<Hash>] the total size, next cursor and changelog entries] Array<Integer, Integer, Array<Hash>] the total size, next cursor and changelog entries
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/changelog.rb#52
  def page(cursor: T.unsafe(nil), pattern: T.unsafe(nil), page_size: T.unsafe(nil)); end
end

# Command line interface for unique jobs
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#11
class SidekiqUniqueJobs::Cli < ::Thor
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#45
  def console; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#66
  def console_class; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#81
  def count_entries_for_del(max_count, pattern); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#34
  def del(pattern); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#88
  def del_entries(max_count, pattern); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#56
  def digests; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#61
  def expiring_digests; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#22
  def list(pattern = T.unsafe(nil)); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#75
  def list_entries(entries, pattern); end

  class << self
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/cli.rb#14
    def banner(command, _namespace = T.unsafe(nil), _subcommand = T.unsafe(nil)); end
  end
end

# Shared class for dealing with gem configuration
#
#
# @author Mauro Berlanda <mauro.berlanda@gmail.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#31
class SidekiqUniqueJobs::Config < ::Concurrent::MutableStruct::ThreadSafeConfig
  # Adds a lock type to the configuration. It will raise if the lock exists already
  #
  # @example Add a custom lock
  #   add_lock(:my_lock, CustomLocks::MyLock)
  # @param name [String, Symbol] the name of the lock
  # @param klass [Class] the class describing the lock
  # @raise DuplicateLock when the name already exists
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#280
  def add_lock(name, klass); end

  # Adds an on_conflict strategy to the configuration.
  #
  # @example Add a custom strategy
  #   add_lock(:my_strategy, CustomStrategies::MyStrategy)
  # @param name [String] the name of the custom strategy
  # @param klass [Class] the class describing the strategy
  # @raise [DuplicateStrategy] when the name already exists
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#299
  def add_strategy(name, klass); end

  # Memoized variable to get the class name
  #
  # @return [String] name of the class
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#263
  def class_name; end

  # Default Lock Timeout
  #
  # @deprecated
  # @return [nil, Integer] configured value or nil
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#251
  def default_lock_timeout; end

  # Set new value for default_lock_timeout
  #
  # @deprecated
  # @param obj [Integer] value to set (seconds)
  # @return [Integer]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#226
  def default_lock_timeout=(obj); end

  # Default lock TTL (Time To Live)
  #
  # @deprecated
  # @return [nil, Integer] configured value or nil
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#238
  def default_lock_ttl; end

  # Set the default_lock_ttl
  #
  # @deprecated
  # @param obj [Integer] value to set (seconds)
  # @return [<type>] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#212
  def default_lock_ttl=(obj); end

  # The current version of redis
  #
  # @return [String] a version string eg. `5.0.1`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#313
  def redis_version; end

  class << self
    # Returns a default configuration
    #
    # @example
    #   SidekiqUniqueJobs::Config.default => <concurrent/mutable_struct/thread_safe_config SidekiqUniqueJobs::Config {
    #   default_lock_timeout: 0,
    #   default_lock_ttl: nil,
    #   enabled: true,
    #   lock_prefix: "uniquejobs",
    #   logger: #<Sidekiq::Logger:0x00007f81e096b0e0 @level=1 ...>,
    #   locks: {
    #   around_perform: SidekiqUniqueJobs::Lock::WhileExecuting,
    #   while_busy: SidekiqUniqueJobs::Lock::WhileExecuting,
    #   while_executing: SidekiqUniqueJobs::Lock::WhileExecuting,
    #   while_working: SidekiqUniqueJobs::Lock::WhileExecuting,
    #   while_executing_reject: SidekiqUniqueJobs::Lock::WhileExecutingReject,
    #   until_executing: SidekiqUniqueJobs::Lock::UntilExecuting,
    #   while_enqueued: SidekiqUniqueJobs::Lock::UntilExecuting,
    #   until_expired: SidekiqUniqueJobs::Lock::UntilExpired,
    #   until_completed: SidekiqUniqueJobs::Lock::UntilExecuted,
    #   until_executed: SidekiqUniqueJobs::Lock::UntilExecuted,
    #   until_performed: SidekiqUniqueJobs::Lock::UntilExecuted,
    #   until_processed: SidekiqUniqueJobs::Lock::UntilExecuted,
    #   until_and_while_executing: SidekiqUniqueJobs::Lock::UntilAndWhileExecuting,
    #   until_successfully_completed: SidekiqUniqueJobs::Lock::UntilExecuted
    #   },
    #   strategies: {
    #   log: SidekiqUniqueJobs::OnConflict::Log,
    #   raise: SidekiqUniqueJobs::OnConflict::Raise,
    #   reject: SidekiqUniqueJobs::OnConflict::Reject,
    #   replace: SidekiqUniqueJobs::OnConflict::Replace,
    #   reschedule: SidekiqUniqueJobs::OnConflict::Reschedule
    #   },
    #   debug_lua: false,
    #   max_history: 1000,
    #   reaper:: ruby,
    #   reaper_count: 1000,
    #   lock_info: false,
    #   raise_on_config_error: false,
    #   }>
    # @return [SidekiqUniqueJobs::Config] a default configuration
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#180
    def default; end
  end
end

# @return [false] by default we don't debug the lua scripts because it is slow
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#102
SidekiqUniqueJobs::Config::DEBUG_LUA = T.let(T.unsafe(nil), FalseClass)

# @return [true] by default the gem is enabled
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#99
SidekiqUniqueJobs::Config::ENABLED = T.let(T.unsafe(nil), TrueClass)

# @return [Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available default locks] Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available default locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#68
SidekiqUniqueJobs::Config::LOCKS = T.let(T.unsafe(nil), Hash)

# @return [Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available fulltime locks] Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available fulltime locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#41
SidekiqUniqueJobs::Config::LOCKS_FROM_PUSH_TO_PROCESSED = T.let(T.unsafe(nil), Hash)

# @return [Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available runtime/client locks] Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available runtime/client locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#58
SidekiqUniqueJobs::Config::LOCKS_WHEN_BUSY = T.let(T.unsafe(nil), Hash)

# @return [Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available queued locks] Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available queued locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#34
SidekiqUniqueJobs::Config::LOCKS_WHILE_ENQUEUED = T.let(T.unsafe(nil), Hash)

# @return [Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available locks without unlock] Hash<Symbol, SidekiqUniqueJobs::Lock::BaseLock] all available locks without unlock
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#52
SidekiqUniqueJobs::Config::LOCKS_WITHOUT_UNLOCK = T.let(T.unsafe(nil), Hash)

# @return [0] by default don't wait for locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#90
SidekiqUniqueJobs::Config::LOCK_TIMEOUT = T.let(T.unsafe(nil), Integer)

# @return [nil]
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#93
SidekiqUniqueJobs::Config::LOCK_TTL = T.let(T.unsafe(nil), T.untyped)

# @return [true, false] by default false (don't disable logger)
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#96
SidekiqUniqueJobs::Config::LOGGER_ENABLED = T.let(T.unsafe(nil), TrueClass)

# @return [1_000] use a changelog history of 1_000 entries by default
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#105
SidekiqUniqueJobs::Config::MAX_HISTORY = T.let(T.unsafe(nil), Integer)

# @return ['uniquejobs'] by default we use this prefix
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#87
SidekiqUniqueJobs::Config::PREFIX = T.let(T.unsafe(nil), String)

# @return [false] by default we don't raise validation errors for workers
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#131
SidekiqUniqueJobs::Config::RAISE_ON_CONFIG_ERROR = T.let(T.unsafe(nil), FalseClass)

# @return [:ruby] prefer the ruby reaper by default since the lua reaper still has problems
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#108
SidekiqUniqueJobs::Config::REAPER = T.let(T.unsafe(nil), Symbol)

# @return [1_000] reap 1_000 orphaned locks at a time by default
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#111
SidekiqUniqueJobs::Config::REAPER_COUNT = T.let(T.unsafe(nil), Integer)

# @return [600] reap locks every 10 minutes
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#114
SidekiqUniqueJobs::Config::REAPER_INTERVAL = T.let(T.unsafe(nil), Integer)

# @return [false] enable reaper resurrector
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#124
SidekiqUniqueJobs::Config::REAPER_RESURRECTOR_ENABLED = T.let(T.unsafe(nil), FalseClass)

# @return [3600] check if reaper is dead each 3600 seconds
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#120
SidekiqUniqueJobs::Config::REAPER_RESURRECTOR_INTERVAL = T.let(T.unsafe(nil), Integer)

# @return [10] stop reaper after 10 seconds
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#117
SidekiqUniqueJobs::Config::REAPER_TIMEOUT = T.let(T.unsafe(nil), Integer)

# @return [0.0.0] default redis version is only to avoid NoMethodError on nil
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#134
SidekiqUniqueJobs::Config::REDIS_VERSION = T.let(T.unsafe(nil), String)

# @return [Hash<Symbol, SidekiqUniqueJobs::OnConflict::Strategy] all available default strategies] Hash<Symbol, SidekiqUniqueJobs::OnConflict::Strategy] all available default strategies
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#77
SidekiqUniqueJobs::Config::STRATEGIES = T.let(T.unsafe(nil), Hash)

# @return [false] while useful it also adds overhead so disable lock_info by default
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#128
SidekiqUniqueJobs::Config::USE_LOCK_INFO = T.let(T.unsafe(nil), FalseClass)

# Error raised when a Lua script fails to execute
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#15
class SidekiqUniqueJobs::Conflict < ::SidekiqUniqueJobs::UniqueJobsError
  # @return [Conflict] a new instance of Conflict
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#16
  def initialize(item); end
end

# Shared module for dealing with redis connections
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/connection.rb#7
module SidekiqUniqueJobs::Connection
  # Creates a connection to redis
  #
  # @return [Sidekiq::RedisConnection] a connection to redis
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/connection.rb#14
  def redis(_r_pool = T.unsafe(nil), &block); end

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/connection.rb#8
    def included(base); end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#15
SidekiqUniqueJobs::DEAD_VERSION = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#16
SidekiqUniqueJobs::DIGESTS = T.let(T.unsafe(nil), String)

# Class Deprecation provides logging of deprecations
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/deprecation.rb#9
class SidekiqUniqueJobs::Deprecation
  class << self
    # Mute warnings from this gem in a threaded context
    #
    # @return [void] <description>
    # @yieldreturn [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/deprecation.rb#17
    def muted; end

    # Check if deprecation warnings have been muted
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/deprecation.rb#31
    def muted?; end

    # Warn about deprecation
    #
    # @param msg [String] a descriptive reason for why the deprecation
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/deprecation.rb#42
    def warn(msg); end

    # Warn about deprecation and provide a context
    #
    # @param msg [String] a descriptive reason for why the deprecation
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/deprecation.rb#56
    def warn_with_backtrace(msg); end
  end
end

# Class Changelogs provides access to the changelog entries
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#9
class SidekiqUniqueJobs::Digests < ::SidekiqUniqueJobs::Redis::SortedSet
  # @return [Digests] a new instance of Digests
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#20
  def initialize(digests_key = T.unsafe(nil)); end

  # Adds a digest
  #
  # @param digest [String] the digest to add
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#29
  def add(digest); end

  # Delete unique digests by digest
  #   Also deletes the :AVAILABLE, :EXPIRED etc keys
  #
  # @param digest [String] a unique digest to delete
  # @param queuetime [Boolean] Whether to delete queue locks.
  # @param runtime [Boolean] Whether to delete run locks.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#56
  def delete_by_digest(digest, queuetime: T.unsafe(nil), runtime: T.unsafe(nil)); end

  # Deletes unique digests by pattern
  #
  # @param pattern [String] a key pattern to match with
  # @param count [Integer] the maximum number
  # @return [Hash<String,Float>] Hash mapping of digest matching the given pattern and score
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#39
  def delete_by_pattern(pattern, count: T.unsafe(nil)); end

  # The entries in this sorted set
  #
  # @param pattern [String] SCAN_PATTERN the match pattern to search for
  # @param count [Integer] DEFAULT_COUNT the number of entries to return
  # @return [Array<String>] an array of digests matching the given pattern
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#77
  def entries(pattern: T.unsafe(nil), count: T.unsafe(nil)); end

  # Returns a paginated
  #
  # @param cursor [Integer] the cursor for this iteration
  # @param pattern [String] SCAN_PATTERN the match pattern to search for
  # @param page_size [Integer] 100 the size per page
  # @return [Array<Integer, Integer, Array<Lock>>] total_size, next_cursor, locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#90
  def page(cursor: T.unsafe(nil), pattern: T.unsafe(nil), page_size: T.unsafe(nil)); end

  private

  # @param digest [String, nil] The digest to form queuetime keys from.
  # @return [Array(String, String, String, String)] The list of queuetime keys or empty strings if +digest+ was +nil+.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#123
  def queuetime_keys(digest); end

  # @param digest [String, nil] The digest to form runtime keys from.
  # @return [Array(String, String, String, String)] The list of runtime keys or empty strings if +digest+ was +nil+.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#110
  def runtime_keys(digest); end
end

# @return [Integer] the number of matches to return by default
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#12
SidekiqUniqueJobs::Digests::DEFAULT_COUNT = T.let(T.unsafe(nil), Integer)

# @return [Array(String, String, String, String)] The empty runtime or queuetime keys.
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#18
SidekiqUniqueJobs::Digests::EMPTY_KEYS_SEGMENT = T.let(T.unsafe(nil), Array)

# @return [String] the default pattern to use for matching
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/digests.rb#15
SidekiqUniqueJobs::Digests::SCAN_PATTERN = T.let(T.unsafe(nil), String)

# Error raised when trying to add a duplicate lock
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#36
class SidekiqUniqueJobs::DuplicateLock < ::SidekiqUniqueJobs::UniqueJobsError; end

# Error raised when trying to add a duplicate stragegy
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#44
class SidekiqUniqueJobs::DuplicateStrategy < ::SidekiqUniqueJobs::UniqueJobsError; end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#19
SidekiqUniqueJobs::ERRORS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#17
SidekiqUniqueJobs::EXPIRING_DIGESTS = T.let(T.unsafe(nil), String)

# Class ExpiringDigests provides access to the expiring digests used by until_expired locks
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/expiring_digests.rb#9
class SidekiqUniqueJobs::ExpiringDigests < ::SidekiqUniqueJobs::Digests
  # @return [ExpiringDigests] a new instance of ExpiringDigests
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/expiring_digests.rb#10
  def initialize; end
end

# Error raised when an invalid argument is given
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#52
class SidekiqUniqueJobs::InvalidArgument < ::SidekiqUniqueJobs::UniqueJobsError; end

# Error raised when a Lua script fails to execute
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#72
class SidekiqUniqueJobs::InvalidUniqueArguments < ::SidekiqUniqueJobs::UniqueJobsError
  # @return [InvalidUniqueArguments] a new instance of InvalidUniqueArguments
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#73
  def initialize(options); end
end

# Raised when a workers configuration is invalid
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#60
class SidekiqUniqueJobs::InvalidWorker < ::SidekiqUniqueJobs::UniqueJobsError
  # @return [InvalidWorker] a new instance of InvalidWorker
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#61
  def initialize(lock_config); end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#20
SidekiqUniqueJobs::JID = T.let(T.unsafe(nil), String)

# Handles loading and dumping of json
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#7
module SidekiqUniqueJobs::JSON
  private

  # Dumps an object into a JSON string
  #
  # @param object [Object] a JSON convertible object
  # @return [String] a JSON string
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#43
  def dump_json(object); end

  # Parses a JSON string into an object
  #
  # @param string [String] the object to parse
  # @return [Object]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#17
  def load_json(string); end

  # Prevents trying JSON.load from raising errors given argument is a hash
  #
  # @param string [String, Hash] the JSON string to parse
  # @return [Hash, Array]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#30
  def safe_load_json(string); end

  class << self
    # Dumps an object into a JSON string
    #
    # @param object [Object] a JSON convertible object
    # @return [String] a JSON string
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#43
    def dump_json(object); end

    # Parses a JSON string into an object
    #
    # @param string [String] the object to parse
    # @return [Object]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#17
    def load_json(string); end

    # Prevents trying JSON.load from raising errors given argument is a hash
    #
    # @param string [String, Hash] the JSON string to parse
    # @return [Hash, Array]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/json.rb#30
    def safe_load_json(string); end
  end
end

# Utility class to append uniqueness to the sidekiq job hash
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#7
module SidekiqUniqueJobs::Job
  extend ::SidekiqUniqueJobs::Job

  # Adds lock_args, lock_prefix and lock_digest to the sidekiq job hash
  #
  # @return [Hash] the job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#22
  def add_digest(item); end

  # Adds lock, timeout, expiration, lock_args, lock_prefix, and lock_digest to the sidekiq job hash
  #
  # @return [Hash] the job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#12
  def prepare(item); end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#47
  def add_lock_args(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#51
  def add_lock_digest(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#55
  def add_lock_prefix(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#43
  def add_lock_timeout(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#39
  def add_lock_ttl(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#59
  def add_lock_type(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/job.rb#32
  def stringify_on_conflict_hash(item); end
end

# Key class wraps logic dealing with various lock keys
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#7
class SidekiqUniqueJobs::Key
  # Initialize a new Key
  #
  # @param digest [String] the digest to use as key
  # @return [Key] a new instance of Key
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#46
  def initialize(digest); end

  # Compares keys by digest
  #
  # @param other [Key] the key to compare with
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#79
  def ==(other); end

  # Returns the value of attribute changelog.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#31
  def changelog; end

  # Returns the value of attribute digest.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#11
  def digest; end

  # Returns the value of attribute digests.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#35
  def digests; end

  # Returns the value of attribute expiring_digests.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#39
  def expiring_digests; end

  # Returns the value of attribute info.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#27
  def info; end

  # @see to_s
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#68
  def inspect; end

  # Returns the value of attribute locked.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#23
  def locked; end

  # Returns the value of attribute primed.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#19
  def primed; end

  # Returns the value of attribute queued.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#15
  def queued; end

  # Returns all keys as an ordered array
  #
  # @return [Array] an ordered array with all keys
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#88
  def to_a; end

  # Provides the only important information about this keys
  #
  # @return [String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#63
  def to_s; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/key.rb#94
  def suffixed_key(variable); end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#21
SidekiqUniqueJobs::LIMIT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#22
SidekiqUniqueJobs::LIVE_VERSION = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#23
SidekiqUniqueJobs::LOCK = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#24
SidekiqUniqueJobs::LOCK_ARGS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#25
SidekiqUniqueJobs::LOCK_ARGS_METHOD = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#26
SidekiqUniqueJobs::LOCK_DIGEST = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#27
SidekiqUniqueJobs::LOCK_EXPIRATION = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#28
SidekiqUniqueJobs::LOCK_INFO = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#29
SidekiqUniqueJobs::LOCK_LIMIT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#30
SidekiqUniqueJobs::LOCK_PREFIX = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#31
SidekiqUniqueJobs::LOCK_TIMEOUT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#32
SidekiqUniqueJobs::LOCK_TTL = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#33
SidekiqUniqueJobs::LOCK_TYPE = T.let(T.unsafe(nil), String)

# Class Lock provides access to information about a lock
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#9
class SidekiqUniqueJobs::Lock
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Timing
  include ::SidekiqUniqueJobs::JSON
  extend ::SidekiqUniqueJobs::Connection

  # Initialize a new lock
  #
  # @param key [String, Key] either a digest or an instance of a {Key}
  # @param time [Timstamp, Float] nil optional timestamp to initiate this lock with
  # @return [Lock] a new instance of Lock
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#48
  def initialize(key, time: T.unsafe(nil)); end

  # Returns all job_id's for this lock
  #
  # @note a JID can be present in 3 different places
  # @return [Array<String>] an array with JIDs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#156
  def all_jids; end

  # A sorted set with changelog entries
  #
  # @return [Changelog]
  # @see Changelog for more information
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#263
  def changelog; end

  # Returns all matching changelog entries for this lock
  #
  # @return [Array<Hash>] an array with changelogs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#198
  def changelogs; end

  # Returns either the time the lock was initialized with or
  #   the first changelog entry's timestamp
  #
  # @return [Float] a floaty timestamp represantation
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#144
  def created_at; end

  # Deletes all the redis keys for this lock
  #
  # @return [Integer] the number of keys deleted in redis
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#128
  def del; end

  # The digest key
  #
  # @note Used for exists checks to avoid enqueuing
  #   the same lock twice
  # @return [Redis::String] a string representation of the key
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#211
  def digest; end

  # Information about the lock
  #
  # @return [Redis::Hash] with lock information
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#251
  def info; end

  # @see to_s
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#289
  def inspect; end

  # Returns the value of attribute key.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#25
  def key; end

  # Locks a job_id
  #
  # @note intended only for testing purposes
  # @param job_id [String] a sidekiq JID
  # @param lock_info [Hash] information about the lock
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#66
  def lock(job_id, lock_info = T.unsafe(nil), score = T.unsafe(nil)); end

  # The locked hash
  #
  # @return [Redis::Hash] for locked JIDs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#241
  def locked; end

  # Returns a collection of locked job_id's
  #
  # @param with_values [true, false] false provide the timestamp for the lock
  # @return [Hash<String, Float>] when given `with_values: true`
  # @return [Array<String>] when given `with_values: false`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#168
  def locked_jids(with_values: T.unsafe(nil)); end

  # Create the :PRIMED key
  #
  # @note intended only for testing purposes
  # @param job_id [String] a sidekiq JID
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#104
  def prime(job_id); end

  # The primed list
  #
  # @return [Redis::List] for primed JIDs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#231
  def primed; end

  # Returns the primed JIDs
  #
  # @return [Array<String>] an array with primed job_ids
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#188
  def primed_jids; end

  # Create the :QUEUED key
  #
  # @note intended only for testing purposes
  # @param job_id [String] a sidekiq JID
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#89
  def queue(job_id); end

  # The queued list
  #
  # @return [Redis::List] for queued JIDs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#221
  def queued; end

  # Returns the queued JIDs
  #
  # @return [Array<String>] an array with queued job_ids
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#178
  def queued_jids; end

  # A nicely formatted string with information about this lock
  #
  # @return [String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#273
  def to_s; end

  # Unlock a specific job_id
  #
  # @param job_id [String] a sidekiq JID
  # @return [true] when job_id was removed
  # @return [false] when job_id wasn't locked
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#118
  def unlock(job_id); end

  private

  # Add the digest to the correct sorted set
  #
  # @param pipeline [Object] a redis pipeline object for issue commands
  # @param lock_info [Hash] the lock info relevant to the digest
  # @return [nil]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#337
  def add_digest_to_set(pipeline, lock_info, score = T.unsafe(nil)); end

  # Generate a changelog entry for the given arguments
  #
  # @param job_id [String] a sidekiq JID
  # @param script [String] the name of the script generating this entry
  # @param message [String] a descriptive message for later review
  # @return [String] a JSON string matching the Lua script structure
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#319
  def changelog_json(job_id, script, message); end

  # Ensure the key is a {Key}
  #
  # @param key [String, Key]
  # @return [Key]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#302
  def get_key(key); end

  class << self
    # Initialize a locked lock
    #
    # @param digest [String] a unique digest
    # @param job_id [String] a sidekiq JID
    # @param lock_info [Hash] information about the lock
    # @return [Lock] a newly lock that has been locked
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock.rb#36
    def create(digest, job_id, lock_info: T.unsafe(nil), time: T.unsafe(nil), score: T.unsafe(nil)); end
  end
end

# Abstract base class for locks
#
# @abstract
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#9
class SidekiqUniqueJobs::Lock::BaseLock
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Reflectable
  extend ::Forwardable
  extend ::SidekiqUniqueJobs::Logging

  # @param item [Hash] the Sidekiq job hash
  # @param callback [Proc] the callback to use after unlock
  # @param redis_pool [Sidekiq::RedisConnection, ConnectionPool] the redis connection
  # @return [BaseLock] a new instance of BaseLock
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#38
  def initialize(item, callback, redis_pool = T.unsafe(nil)); end

  # Execute the job in the Sidekiq server processor
  #
  # @raise [NotImplementedError] needs to be implemented in child class
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#62
  def execute; end

  # Locks a sidekiq job
  #
  # @note Will call a conflict strategy if lock can't be achieved.
  # @raise [NotImplementedError]
  # @return [String, nil] the locked jid when properly locked, else nil.
  # @yield to the caller when given a block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#56
  def lock; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def locked?(*args, **_arg1, &block); end

  # The lock manager/client
  #
  # @api private
  # @return [SidekiqUniqueJobs::Locksmith] the locksmith for this sidekiq job
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#72
  def locksmith; end

  private

  # Returns the value of attribute attempt.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#92
  def attempt; end

  # Call whatever strategry that has been configured
  #
  # @param origin [Symbol] the origin `:client` or `:server`
  # @return [void] the return value is irrelevant
  # @yieldparam if [void] a new job id was set and a block is given
  # @yieldreturn [void] the yield is irrelevant, it only provides a mechanism in
  #   one specific situation to yield back to the middleware.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#119
  def call_strategy(origin:); end

  # Returns the value of attribute callback.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#89
  def callback; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#134
  def callback_safely; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#154
  def client_strategy; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#80
  def item; end

  # Returns the value of attribute lock_config.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#83
  def lock_config; end

  # Eases testing by allowing the lock implementation to add the missing
  # keys to the job hash.
  #
  # @return [void] the return value should be irrelevant
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#101
  def prepare_item; end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#86
  def redis_pool; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#159
  def server_strategy; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#142
  def strategy_for(origin); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#128
  def unlock_and_callback; end

  class << self
    # Validates that the sidekiq_options for the worker is valid
    #
    # @param options [Hash] the sidekiq_options given to the worker
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/base_lock.rb#27
    def validate_options(options = T.unsafe(nil)); end
  end
end

# Locks jobs while the job is executing in the server process
# - Locks on perform_in or perform_async (see {UntilExecuting})
# - Unlocks before yielding to the worker's perform method (see {UntilExecuting})
# - Locks before yielding to the worker's perform method (see {WhileExecuting})
# - Unlocks after yielding to the worker's perform method (see {WhileExecuting})
#
# See {#lock} for more information about the client.
# See {#execute} for more information about the server
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_and_while_executing.rb#15
class SidekiqUniqueJobs::Lock::UntilAndWhileExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  # Executes in the Sidekiq server process
  #
  # @yield to the worker class perform method
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_and_while_executing.rb#40
  def execute; end

  # Locks a sidekiq job
  #
  # @note Will call a conflict strategy if lock can't be achieved.
  # @return [String, nil] the locked jid when properly locked, else nil.
  # @yield to the caller when given a block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_and_while_executing.rb#25
  def lock(origin: T.unsafe(nil), &block); end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_and_while_executing.rb#57
  def ensure_relocked; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_and_while_executing.rb#66
  def runtime_lock; end
end

# Locks jobs until the server is done executing the job
# - Locks on perform_in or perform_async
# - Unlocks after yielding to the worker's perform method
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executed.rb#10
class SidekiqUniqueJobs::Lock::UntilExecuted < ::SidekiqUniqueJobs::Lock::BaseLock
  # Executes in the Sidekiq server process
  #
  # @yield to the worker class perform method
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executed.rb#35
  def execute; end

  # Locks a sidekiq job
  #
  # @note Will call a conflict strategy if lock can't be achieved.
  # @return [String, nil] the locked jid when properly locked, else nil.
  # @yield to the caller when given a block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executed.rb#20
  def lock(&block); end
end

# Locks jobs until {#execute} starts
# - Locks on perform_in or perform_async
# - Unlocks before yielding to the worker's perform method
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executing.rb#10
class SidekiqUniqueJobs::Lock::UntilExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  # Executes in the Sidekiq server process
  #
  # @yield to the worker class perform method
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executing.rb#33
  def execute; end

  # Locks a sidekiq job
  #
  # @note Will call a conflict strategy if lock can't be achieved.
  # @return [String, nil] the locked jid when properly locked, else nil.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_executing.rb#18
  def lock(&block); end
end

# UntilExpired locks until the job expires
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_expired.rb#10
class SidekiqUniqueJobs::Lock::UntilExpired < ::SidekiqUniqueJobs::Lock::UntilExecuted
  # Executes in the Sidekiq server process
  #
  # @yield to the worker class perform method
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_expired.rb#35
  def execute(&block); end

  # Locks a sidekiq job
  #
  # @note Will call a conflict strategy if lock can't be achieved.
  # @return [String, nil] the locked jid when properly locked, else nil.
  # @yield to the caller when given a block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/until_expired.rb#20
  def lock(&block); end
end

# Locks jobs while the job is executing in the server process
# - Locks before yielding to the worker's perform method
# - Unlocks after yielding to the worker's perform method
#
# See {#lock} for more information about the client.
# See {#execute} for more information about the server
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#13
class SidekiqUniqueJobs::Lock::WhileExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  include ::SidekiqUniqueJobs::OptionsWithFallback
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::Logging::Middleware
  extend ::SidekiqUniqueJobs::Logging::Middleware

  # @param item [Hash] the Sidekiq job hash
  # @param callback [Proc] callback to call after unlock
  # @param redis_pool [Sidekiq::RedisConnection, ConnectionPool] the redis connection
  # @return [WhileExecuting] a new instance of WhileExecuting
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#25
  def initialize(item, callback, redis_pool = T.unsafe(nil)); end

  # Executes in the Sidekiq server process.
  #   These jobs are locked in the server process not from the client
  #
  # @yield to the worker class perform method
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#43
  def execute(&block); end

  # Simulate that a client lock was achieved.
  #   These locks should only ever be created in the server process.
  #
  # @return [true] always returns true
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#33
  def lock; end

  private

  # This is safe as the base_lock always creates a new digest
  #   The append there for needs to be done every time
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#63
  def append_unique_key_suffix; end
end

# @return [String] returns :RUN
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing.rb#16
SidekiqUniqueJobs::Lock::WhileExecuting::RUN_SUFFIX = T.let(T.unsafe(nil), String)

# Locks jobs while executing
#   Locks from the server process
#   Unlocks after the server is done processing
#
# See {#lock} for more information about the client.
# See {#execute} for more information about the server
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing_reject.rb#13
class SidekiqUniqueJobs::Lock::WhileExecutingReject < ::SidekiqUniqueJobs::Lock::WhileExecuting
  # Overridden with a forced {OnConflict::Reject} strategy
  #
  # @return [OnConflict::Reject] a reject strategy
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock/while_executing_reject.rb#16
  def server_strategy; end
end

# Handles uniqueness of sidekiq arguments
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#7
class SidekiqUniqueJobs::LockArgs
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::JSON
  extend ::SidekiqUniqueJobs::Logging

  # @param item [Hash] a Sidekiq job hash
  # @return [LockArgs] a new instance of LockArgs
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#28
  def initialize(item); end

  # Returns the value of attribute args.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#25
  def args; end

  # The globally default worker options configured from Sidekiq
  #
  # @return [Hash<String, Object>]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#119
  def default_job_options; end

  # The global worker options defined in Sidekiq directly
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#108
  def default_lock_args_method; end

  # Filters unique arguments by proc configured in the sidekiq worker
  #
  # @param args [Array] the arguments passed to the sidekiq worker
  # @return [Array] with the filtered arguments
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#80
  def filter_by_proc(args); end

  # Filters unique arguments by method configured in the sidekiq worker
  #
  # @param args [Array] the arguments passed to the sidekiq worker
  # @return [Array] unfiltered unless {#job_method_defined?}
  # @return [Array] with the filtered arguments
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#88
  def filter_by_symbol(args); end

  # Filters unique arguments by proc or symbol
  #
  # @return [Array] {#filter_by_proc} when {#lock_args_method} is a Proc
  # @return [Array] {#filter_by_symbol} when {#lock_args_method} is a Symbol
  # @return [Array] args unfiltered when neither of the above
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#64
  def filtered_args; end

  # The sidekiq job hash
  #
  # @return [Hash] the Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#21
  def item; end

  # The unique arguments to use for creating a lock
  #
  # @return [Array] the arguments filters by the {#filtered_args} method if {#lock_args_enabled?}
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#36
  def lock_args; end

  # Checks if the worker class has disabled lock_args
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#56
  def lock_args_disabled?; end

  # Checks if the worker class has enabled lock_args
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#42
  def lock_args_enabled?; end

  # The method to use for filtering unique arguments
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#100
  def lock_args_method; end

  # Validate that the lock_args_method is acceptable
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#50
  def lock_args_method_valid?; end

  class << self
    # Convenience method for returning a digest
    #
    # @param item [Hash] a Sidekiq job hash
    # @return [String] a unique digest
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_args.rb#15
    def call(item); end
  end
end

# Gathers all configuration for a lock
#   which helps reduce the amount of instance variables
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#10
class SidekiqUniqueJobs::LockConfig
  # @return [LockConfig] a new instance of LockConfig
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#59
  def initialize(job_hash = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#46
  def errors; end

  # Return a nice descriptive message with all validation errors
  #
  # @return [String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#104
  def errors_as_string; end

  # Returns the value of attribute job.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#18
  def job; end

  # Returns the value of attribute limit.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#22
  def limit; end

  # Returns the value of attribute lock_info.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#38
  def lock_info; end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#74
  def lock_info?; end

  # the strategy to use as conflict resolution from sidekiq client
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#115
  def on_client_conflict; end

  # Returns the value of attribute on_conflict.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#42
  def on_conflict; end

  # the strategy to use as conflict resolution from sidekiq server
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#124
  def on_server_conflict; end

  # Returns the value of attribute pttl.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#34
  def pttl; end

  # Returns the value of attribute timeout.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#26
  def timeout; end

  # @return [Integer, nil] the time (in milliseconds) to live after successful
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#30
  def ttl; end

  # Returns the value of attribute type.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#14
  def type; end

  # Is the configuration valid?
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#94
  def valid?; end

  # Indicate if timeout was set
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#84
  def wait_for_lock?; end

  class << self
    # Instantiate a new lock_config based on sidekiq options in worker
    #
    # @param options [Hash] sidekiq_options for worker
    # @return [LockConfig]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_config.rb#55
    def from_worker(options); end
  end
end

# Handles uniqueness of sidekiq arguments
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#9
class SidekiqUniqueJobs::LockDigest
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::JSON
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  extend ::SidekiqUniqueJobs::Logging

  # @param item [Hash] a Sidekiq job hash
  # @return [LockDigest] a new instance of LockDigest
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#38
  def initialize(item); end

  # Creates a namespaced unique digest based on the {#digestable_hash} and the {#lock_prefix}
  #
  # @return [String] a unique digest
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#53
  def create_digest; end

  # Filter a hash to use for digest
  #
  # @return [Hash] to use for digest
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#60
  def digestable_hash; end

  # The sidekiq job hash
  #
  # @return [Hash] the Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#27
  def item; end

  # Returns the value of attribute lock_args.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#31
  def lock_args; end

  # Memoized lock_digest
  #
  # @return [String] a unique digest
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#47
  def lock_digest; end

  # Returns the value of attribute lock_prefix.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#35
  def lock_prefix; end

  # Checks if we should disregard the queue when creating the unique digest
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#69
  def unique_across_queues?; end

  # Checks if we should disregard the worker when creating the unique digest
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#75
  def unique_across_workers?; end

  class << self
    # Generates a new digest
    #
    # @param item [Hash] a sidekiq job hash
    # @return [String] a unique digest for the given arguments
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_digest.rb#21
    def call(item); end
  end
end

# Class Info provides information about a lock
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#9
class SidekiqUniqueJobs::LockInfo < ::SidekiqUniqueJobs::Redis::String
  # Quick access to the hash members for the value
  #
  # @param key [String, Symbol] the key who's value to retrieve
  # @return [Object]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#47
  def [](key); end

  # Check if this redis string is blank
  #
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#26
  def none?; end

  # Check if this redis string has a value
  #
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#36
  def present?; end

  # Writes the lock info to redis
  #
  # @param obj [Hash] the information to store at key
  # @raise [InvalidArgument]
  # @return [Hash]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#58
  def set(obj, pipeline = T.unsafe(nil)); end

  # Returns the value for this key as a hash
  #
  # @return [Hash]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_info.rb#16
  def value; end
end

# Calculates timeout and expiration
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#7
class SidekiqUniqueJobs::LockTTL
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods

  # @option item
  # @option item
  # @option item
  # @option item
  # @param item [Hash] the Sidekiq job hash
  # @return [LockTTL] a new instance of LockTTL
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#35
  def initialize(item); end

  # Computes lock ttl from job arguments, sidekiq_options.
  #   Falls back to {SidekiqUniqueJobs::Config#lock_ttl}
  #
  # @note this method takes into consideration the time
  #   until a job is scheduled
  # @return [Integer] the number of seconds to live
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#68
  def calculate; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#28
  def item; end

  # The time a job is scheduled
  #
  # @return [Float] the exact unix time the job is scheduled at
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#54
  def scheduled_at; end

  # Calculates the time until the job is scheduled starting from now
  #
  # @return [Integer] the number of seconds until job is scheduled
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#46
  def time_until_scheduled; end

  class << self
    # Computes lock ttl from job arguments, sidekiq_options.
    #   Falls back to {SidekiqUniqueJobs::Config#lock_ttl}
    #
    # @note this method takes into consideration the time
    #   until a job is scheduled
    # @return [Integer] the number of seconds to live
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_ttl.rb#22
    def calculate(item); end
  end
end

# Calculates timeout and expiration
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#7
class SidekiqUniqueJobs::LockTimeout
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods

  # @option item
  # @option item
  # @option item
  # @option item
  # @param item [Hash] the Sidekiq job hash
  # @return [LockTimeout] a new instance of LockTimeout
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#32
  def initialize(item); end

  # Finds a lock timeout in either of
  #  default worker options, {default_lock_timeout} or provided worker_options
  #
  # @return [Integer, nil]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#44
  def calculate; end

  # The configured default_lock_timeout
  #
  # @return [Integer, nil]
  # @see SidekiqUniqueJobs::Config#lock_timeout
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#58
  def default_lock_timeout; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#25
  def item; end

  class << self
    # Calculates the timeout for a Sidekiq job
    #
    # @param item [Hash] sidekiq job hash
    # @return [Integer] timeout in seconds
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_timeout.rb#19
    def calculate(item); end
  end
end

# Calculates the lock type
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_type.rb#6
class SidekiqUniqueJobs::LockType
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods

  # @option item
  # @option item
  # @param item [Hash] the Sidekiq job hash
  # @return [LockType] a new instance of LockType
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_type.rb#28
  def initialize(item); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_type.rb#33
  def call; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_type.rb#23
  def item; end

  class << self
    # Computes lock type from job arguments, sidekiq_options.
    #
    # @return [Symbol] the lock type
    # @return [NilClass] if no lock type is found.
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/lock_type.rb#17
    def call(item); end
  end
end

# Lock manager class that handles all the various locks
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#7
class SidekiqUniqueJobs::Locksmith
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Reflectable
  include ::SidekiqUniqueJobs::Timing
  include ::SidekiqUniqueJobs::Script::Caller
  include ::SidekiqUniqueJobs::JSON
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging

  # Initialize a new Locksmith instance
  #
  # @option item
  # @option item
  # @option item
  # @param item [Hash] a Sidekiq job hash
  # @param redis_pool [Sidekiq::RedisConnection, ConnectionPool] the redis connection
  # @return [Locksmith] a new instance of Locksmith
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#63
  def initialize(item, redis_pool = T.unsafe(nil)); end

  # Compare this locksmith with another
  #
  # @param other [Locksmith] the locksmith to compare with
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#175
  def ==(other); end

  # Returns the value of attribute config.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#48
  def config; end

  # Deletes the lock unless it has a pttl set
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#75
  def delete; end

  # Deletes the lock regardless of if it has a pttl set
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#84
  def delete!; end

  # @raise [SidekiqUniqueJobs::InvalidArgument]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#102
  def execute(&block); end

  # @see to_s
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#164
  def inspect; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#52
  def item; end

  # Returns the value of attribute job_id.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#44
  def job_id; end

  # Returns the value of attribute key.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#40
  def key; end

  # Create a lock for the Sidekiq job
  #
  # @return [String] the Sidekiq job_id that was locked/queued
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#93
  def lock(wait: T.unsafe(nil)); end

  # Checks if this instance is considered locked
  #
  # @param conn [Sidekiq::RedisConnection, ConnectionPool] the redis connection
  # @return [true, false] true when the :LOCKED hash contains the job_id
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#145
  def locked?(conn = T.unsafe(nil)); end

  # Nicely formatted string with information about self
  #
  # @return [String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#157
  def to_s; end

  # Removes the lock keys from Redis if locked by the provided jid/token
  #
  # @return [false] unless locked?
  # @return [String] Sidekiq job_id (jid) if successful
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#116
  def unlock(conn = T.unsafe(nil)); end

  # Removes the lock keys from Redis
  #
  # @return [false] unless locked?
  # @return [String] Sidekiq job_id (jid) if successful
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#128
  def unlock!(conn = T.unsafe(nil)); end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#348
  def add_drift(val); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#364
  def argv; end

  # @api private
  # @raise [InvalidArgument]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#307
  def brpoplpush(conn, wait); end

  # Used to combat redis imprecision with ttl/pttl
  #
  # @param val [Integer] the value to compute drift for
  # @return [Integer] a computed drift value
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#341
  def drift(val); end

  # Prepares all the various lock data
  #
  # @param conn [Redis] a redis connection
  # @return [nil] when redis was already prepared for this lock
  # @return [yield<String>] when successfully enqueued
  # @yield [job_id]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#221
  def enqueue(conn); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#281
  def handle_primed(primed_jid); end

  # Used to reduce some duplication from the two methods
  #
  # @param conn [Sidekiq::RedisConnection, ConnectionPool] the redis connection
  # @param primed_method [Method] reference to the method to use for getting a primed token
  # @param wait [nil, Integer, Float] time to wait before timeout
  # @see lock
  # @see execute
  # @yieldparam job_id [string] the sidekiq JID
  # @yieldreturn [void] whatever the calling block returns
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#195
  def lock!(conn, primed_method, wait = T.unsafe(nil)); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#372
  def lock_info; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#368
  def lock_score; end

  # Does the actual popping of the enqueued token
  #
  # @param conn [Redis] a redis connection
  # @return [String] a previously enqueued token (now taken off the queue)
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#294
  def pop_queued(conn, wait = T.unsafe(nil)); end

  # Pops an enqueued token
  #
  # @note Used for runtime locks to avoid problems with blocking commands
  #   in current thread
  # @param conn [Redis] a redis connection
  # @return [nil] when lock was not possible
  # @return [Object] whatever the block returns when lock was acquired
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#246
  def primed_async(conn, wait = T.unsafe(nil), &block); end

  # Pops an enqueued token
  #
  # @note Used for non-runtime locks
  # @param conn [Redis] a redis connection
  # @return [nil] when lock was not possible
  # @return [Object] whatever the block returns when lock was acquired
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#276
  def primed_sync(conn, wait = T.unsafe(nil), &block); end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#181
  def redis_pool; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#386
  def redis_version; end

  # @api private
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#317
  def rpoplpush(conn); end

  # Checks if the lock has been taken
  #
  # @param conn [Redis] a redis connection
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#360
  def taken?(conn); end

  # Writes lock information to redis.
  #   The lock information contains information about worker, queue, limit etc.
  #
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#328
  def write_lock_info(conn); end
end

# @return [Float] used to take into consideration the inaccuracy of redis timestamps
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#34
SidekiqUniqueJobs::Locksmith::CLOCK_DRIFT_FACTOR = T.let(T.unsafe(nil), Float)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/locksmith.rb#35
SidekiqUniqueJobs::Locksmith::NETWORK_FACTOR = T.let(T.unsafe(nil), Float)

# Utility module for reducing the number of uses of logger.
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#7
module SidekiqUniqueJobs::Logging
  # Build a log message
  #
  # @param message_or_exception [String, Exception] an entry to log
  # @param item [Hash] the sidekiq job hash
  # @return [String] a complete log entry
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#117
  def build_message(message_or_exception, item = T.unsafe(nil)); end

  # Logs a message at debug level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#32
  def log_debug(message_or_exception = T.unsafe(nil), item = T.unsafe(nil), &block); end

  # Logs a message at error level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#83
  def log_error(message_or_exception = T.unsafe(nil), item = T.unsafe(nil), &block); end

  # Logs a message at fatal level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#100
  def log_fatal(message_or_exception = T.unsafe(nil), item = T.unsafe(nil), &block); end

  # Logs a message at info level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#49
  def log_info(message_or_exception = T.unsafe(nil), item = T.unsafe(nil), &block); end

  # Logs a message at warn level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#66
  def log_warn(message_or_exception = T.unsafe(nil), item = T.unsafe(nil), &block); end

  # A convenience method for using the configured gem logger
  #
  # @return [Logger]
  # @see SidekiqUniqueJobs#.logger
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#19
  def logger; end

  # Setup some variables to add to each log line
  #
  # @raise [NotImplementedError]
  # @return [Hash] the context to use for each log line
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#166
  def logging_context; end

  # Attempt to setup context aware logging for the given logger
  #
  # @return [void]
  # @yield
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#156
  def with_configured_loggers_context(&block); end

  # Wraps the middleware logic with context aware logging
  #
  # @return [void]
  # @yieldreturn [void] yield to the middleware instance
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#140
  def with_logging_context; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#225
  def fake_logger_context(_context); end

  # Checks if the logger context takes a hash argument
  #
  # @note only used to remove the need for explicitly ignoring manual dispatch in other places.
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#205
  def logger_context_hash?; end

  # A memoized method to use for setting up a logging context
  #
  # @return [proc] the method to call
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#178
  def logger_method; end

  # Checks if the logger respond to `with_context`.
  #
  # @note only used to remove the need for explicitly ignoring manual dispatch in other places.
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#193
  def logger_respond_to_with_context?; end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#232
  def logging?; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#221
  def no_sidekiq_context_method; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#209
  def sidekiq_context_method; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#213
  def sidekiq_logger_context_method; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#217
  def sidekiq_logging_context_method; end

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging.rb#8
    def included(base); end
  end
end

# Context aware logging for Sidekiq Middlewares
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging/middleware_context.rb#15
module SidekiqUniqueJobs::Logging::Middleware
  include ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Logging

  # Provides a logging context for Sidekiq Middlewares
  #
  # @return [Hash] when logger responds to `:with_context`
  # @return [String] when logger does not responds to `:with_context`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging/middleware_context.rb#31
  def logging_context; end

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/logging/middleware_context.rb#18
    def included(base); end
  end
end

# Provides the sidekiq middleware that makes the gem work
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware.rb#9
module SidekiqUniqueJobs::Middleware
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Logging::Middleware
  include ::SidekiqUniqueJobs::OptionsWithFallback
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::JSON
  extend ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Logging::Middleware

  # This method runs before (prepended) the actual middleware implementation.
  #   This is done to reduce duplication
  #
  # @param worker_class [Sidekiq::Job]
  # @param item [Hash] a sidekiq job hash
  # @param queue [String] name of the queue
  # @param redis_pool [ConnectionPool] only used for compatility reasons
  # @return [yield<super>] call the rest of the middleware stack
  # @yieldparam if [void] uniquejobs is disable
  # @yieldreturn [void] delegate back to other sidekiq middleware
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware.rb#31
  def call(worker_class, item, queue, redis_pool = T.unsafe(nil)); end

  # The sidekiq job hash
  #
  # @return [Hash] the Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware.rb#16
  def item; end
end

# The unique sidekiq middleware for the client push
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware/client.rb#8
class SidekiqUniqueJobs::Middleware::Client
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Logging::Middleware
  include ::SidekiqUniqueJobs::OptionsWithFallback
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::JSON
  include ::SidekiqUniqueJobs::Middleware
  include ::Sidekiq::ServerMiddleware
  include ::SidekiqUniqueJobs::Reflectable

  # Calls this client middleware
  #   Used from Sidekiq.process_single
  #
  # @see SidekiqUniqueJobs::Middleware#call
  # @see https://github.com/mperham/sidekiq/wiki/Job-Format
  # @see https://github.com/mperham/sidekiq/wiki/Middleware
  # @yield when uniqueness is disable
  # @yield when the lock is successful
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware.rb#31
  def call(worker_class, item, queue, redis_pool = T.unsafe(nil)); end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware/client.rb#34
  def lock; end
end

# The unique sidekiq middleware for the server processor
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware/server.rb#8
class SidekiqUniqueJobs::Middleware::Server
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Logging::Middleware
  include ::SidekiqUniqueJobs::OptionsWithFallback
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::JSON
  include ::SidekiqUniqueJobs::Middleware
  include ::Sidekiq::ServerMiddleware

  # Runs the server middleware (used from Sidekiq::Processor#process)
  #
  # @see SidekiqUniqueJobs::Middleware#call
  # @see https://github.com/mperham/sidekiq/wiki/Job-Format
  # @see https://github.com/mperham/sidekiq/wiki/Middleware
  # @yield when uniqueness is disabled
  # @yield when owning the lock
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/middleware.rb#31
  def call(worker_class, item, queue, redis_pool = T.unsafe(nil)); end
end

# Raised when no block was given
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#24
class SidekiqUniqueJobs::NoBlockGiven < ::SidekiqUniqueJobs::UniqueJobsError; end

# Raised when a notification has been mistyped
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#29
class SidekiqUniqueJobs::NoSuchNotificationError < ::SidekiqUniqueJobs::UniqueJobsError; end

# Normalizes hashes by dumping them to json and loading them from json
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/normalizer.rb#7
module SidekiqUniqueJobs::Normalizer
  extend ::SidekiqUniqueJobs::JSON

  class << self
    # Changes hash to a json compatible hash
    #
    # @param args [Hash]
    # @return [Hash] a json compatible hash
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/normalizer.rb#13
    def jsonify(args); end
  end
end

# Raised when a workers configuration is invalid
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#94
class SidekiqUniqueJobs::NotUniqueWorker < ::SidekiqUniqueJobs::UniqueJobsError
  # @return [NotUniqueWorker] a new instance of NotUniqueWorker
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#95
  def initialize(options); end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#34
SidekiqUniqueJobs::ON_CLIENT_CONFLICT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#35
SidekiqUniqueJobs::ON_CONFLICT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#36
SidekiqUniqueJobs::ON_SERVER_CONFLICT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#18
SidekiqUniqueJobs::ORPHANED_DIGESTS = T.let(T.unsafe(nil), String)

# Provides lock conflict resolutions
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#4
module SidekiqUniqueJobs::OnConflict
  class << self
    # Find a strategy to use for conflicting locks
    #
    # @param strategy [Symbol] the key for the strategy
    # @return [OnConflict::Strategy] when found
    # @return [OnConflict::NullStrategy] when no other could be found
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict.rb#31
    def find_strategy(strategy); end

    # A convenience method for using the configured strategies
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict.rb#19
    def strategies; end
  end
end

# Strategy to log information about conflict
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/log.rb#8
class SidekiqUniqueJobs::OnConflict::Log < ::SidekiqUniqueJobs::OnConflict::Strategy
  # Logs an informational message about that the job was not unique
  #
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/log.rb#17
  def call; end
end

# Default conflict strategy class that does nothing
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/null_strategy.rb#8
class SidekiqUniqueJobs::OnConflict::NullStrategy < ::SidekiqUniqueJobs::OnConflict::Strategy
  # Do nothing on conflict
  #
  # @return [nil]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/null_strategy.rb#11
  def call; end
end

# Strategy to raise an error on conflict
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/raise.rb#8
class SidekiqUniqueJobs::OnConflict::Raise < ::SidekiqUniqueJobs::OnConflict::Strategy
  # Raise an error on conflict.
  #   This will cause Sidekiq to retry the job
  #
  # @raise [SidekiqUniqueJobs::Conflict]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/raise.rb#12
  def call; end
end

# Strategy to send jobs to dead queue
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#8
class SidekiqUniqueJobs::OnConflict::Reject < ::SidekiqUniqueJobs::OnConflict::Strategy
  # Send jobs to dead queue
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#12
  def call; end

  # An instance of Sidekiq::Deadset
  #
  # @api private
  # @return [Sidekiq::Deadset] >
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#60
  def deadset; end

  # Executes the kill instructions with arguments
  #
  # @api private
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#50
  def kill_job_with_options; end

  # Executes the kill instructions without arguments
  #
  # @api private
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#40
  def kill_job_without_options; end

  # Sidekiq version compatibility check
  #
  # @api private
  # @return [true] when Sidekiq::Deadset#kill takes more than 1 argument
  # @return [false] when Sidekiq::Deadset#kill does not take multiple arguments
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#30
  def kill_with_options?; end

  # The Sidekiq job hash as JSON
  #
  # @return [String] a JSON formatted string
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reject.rb#70
  def payload; end
end

# Strategy to replace the job on conflict
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#8
class SidekiqUniqueJobs::OnConflict::Replace < ::SidekiqUniqueJobs::OnConflict::Strategy
  # Initialize a new Replace strategy
  #
  # @param item [Hash] sidekiq job hash
  # @return [Replace] a new instance of Replace
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#23
  def initialize(item, redis_pool = T.unsafe(nil)); end

  # Replace the old job in the queue
  #
  # @return [void] <description>
  # @yield to retry the lock after deleting the old one
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#37
  def call(&block); end

  # Delete the job from either schedule, retry or the queue
  #
  # @return [String] the deleted job hash
  # @return [nil] when deleting nothing
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#55
  def delete_job_by_digest; end

  # Delete the keys belonging to the job
  #
  # @return [Integer] the number of keys deleted
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#67
  def delete_lock; end

  # Access to the {Digests}
  #
  # @return [Digests] and instance with digests
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#77
  def digests; end

  # Returns the value of attribute lock_digest.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#16
  def lock_digest; end

  # Returns the value of attribute queue.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/replace.rb#12
  def queue; end
end

# Strategy to reschedule job on conflict
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reschedule.rb#8
class SidekiqUniqueJobs::OnConflict::Reschedule < ::SidekiqUniqueJobs::OnConflict::Strategy
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods
  include ::SidekiqUniqueJobs::Reflectable

  # @param item [Hash] sidekiq job hash
  # @return [Reschedule] a new instance of Reschedule
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reschedule.rb#15
  def initialize(item, redis_pool = T.unsafe(nil)); end

  # Create a new job from the current one.
  #   This will mess up sidekiq stats because a new job is created
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reschedule.rb#22
  def call; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/reschedule.rb#34
  def schedule_in; end
end

# Abstract conflict strategy class
#
# @abstract
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#9
class SidekiqUniqueJobs::OnConflict::Strategy
  include ::SidekiqUniqueJobs::JSON
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Script::Caller
  include ::SidekiqUniqueJobs::Timing
  extend ::SidekiqUniqueJobs::Logging

  # Initialize a new Strategy
  #
  # @param item [Hash] sidekiq job hash
  # @param redis_pool [ConnectionPool] the connection pool instance
  # @return [Strategy] a new instance of Strategy
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#28
  def initialize(item, redis_pool = T.unsafe(nil)); end

  # Use strategy on conflict
  #
  # @raise [NotImplementedError] needs to be implemented in child class
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#35
  def call; end

  # Returns the value of attribute item.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#17
  def item; end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#20
  def redis_pool; end

  # Check if the strategy is kind of {Replace}
  #
  # @return [true] when the strategy is a {Replace}
  # @return [false] when the strategy is not a {Replace}
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/on_conflict/strategy.rb#46
  def replace?; end
end

# Module containing methods shared between client and server middleware
#
# Requires the following methods to be defined in the including class
#   1. item (required)
#   2. options (can be nil)
#   3. job_class (required, can be anything)
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#11
module SidekiqUniqueJobs::OptionsWithFallback
  include ::SidekiqUniqueJobs::SidekiqWorkerMethods

  # Returns the corresponding class for the lock_type
  #
  # @return [Class]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#48
  def lock_class; end

  # A new lock for this Sidekiq Job
  #
  # @return [Lock::BaseLock] an instance of a lock implementation
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#38
  def lock_instance; end

  # The type of lock for this worker
  #
  # @return [Symbol, NilClass]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#60
  def lock_type; end

  # A convenience method for using the configured locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#17
  def locks; end

  # The default options with any matching keys overridden from worker options
  #
  # @return [Hash<String, Object>]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#70
  def options; end

  # Check if unique has been disabled
  #
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#28
  def unique_disabled?; end

  # Check if unique has been enabled
  #
  # @return [true, false] indicate if the gem has been enabled
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#23
  def unique_enabled?; end

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/options_with_fallback.rb#12
    def included(base); end
  end
end

# Class DeleteOrphans provides deletion of orphaned digests
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
# @note this is a much slower version of the lua script but does not crash redis
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#4
module SidekiqUniqueJobs::Orphans; end

# Class DeleteOrphans provides deletion of orphaned digests
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
# @note this is a much slower version of the lua script but does not crash redis
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/lua_reaper.rb#12
class SidekiqUniqueJobs::Orphans::LuaReaper < ::SidekiqUniqueJobs::Orphans::Reaper
  # Delete orphaned digests
  #
  # @return [Integer] the number of reaped locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/lua_reaper.rb#19
  def call; end
end

# Manages the orphan reaper
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#12
module SidekiqUniqueJobs::Orphans::Manager
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging

  private

  # Current time (as integer value)
  #
  # @return [Integer]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#237
  def current_timestamp; end

  # A properly configured timer task
  #
  # @return [SidekiqUniqueJobs::TimerTask]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#85
  def default_task; end

  # Checks if reaping is disabled
  #
  # @return [true, false]
  # @see enabled?
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#176
  def disabled?; end

  # Reaper interval with a little drift
  #   Redis isn't exact enough so to give a little buffer,
  #   we add a tiny value to the reaper interval.
  #
  # @return [Integer] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#227
  def drift_reaper_interval; end

  # Checks if reaping is enabled
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#185
  def enabled?; end

  # A context to use for all log entries
  #
  # @return [Hash] when logger responds to `:with_context`
  # @return [String] when logger does not responds to `:with_context`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#138
  def logging_context; end

  # @see SidekiqUniqueJobs::Config#reaper
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#120
  def reaper; end

  # @see SidekiqUniqueJobs::Config#reaper_interval
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#127
  def reaper_interval; end

  # Updates mutex key
  #
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#205
  def refresh_reaper_mutex; end

  # Writes a mutex key to redis
  #
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#195
  def register_reaper_process; end

  # Checks if a reaper is registered
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#152
  def registered?; end

  # Starts a separate thread that periodically reaps orphans
  #
  # @return [SidekiqUniqueJobs::TimerTask] the task that was started
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#35
  def start(test_task = T.unsafe(nil)); end

  # Stops the thread that reaps orphans
  #
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#58
  def stop; end

  # The task that runs the reaper
  #
  # @return [<type>] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#75
  def task; end

  # Store a task to use for scheduled execution
  #
  # @param task [SidekiqUniqueJobs::TimerTask] the task to use
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#103
  def task=(task); end

  # Arguments passed on to the timer task
  #
  # @return [Hash]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#113
  def timer_task_options; end

  # Removes mutex key from redis
  #
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#215
  def unregister_reaper_process; end

  # Checks if that reapers are not registerd
  #
  # @return [true, false]
  # @see registered?
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#165
  def unregistered?; end

  class << self
    # Current time (as integer value)
    #
    # @return [Integer]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#237
    def current_timestamp; end

    # A properly configured timer task
    #
    # @return [SidekiqUniqueJobs::TimerTask]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#85
    def default_task; end

    # Checks if reaping is disabled
    #
    # @return [true, false]
    # @see enabled?
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#176
    def disabled?; end

    # Reaper interval with a little drift
    #   Redis isn't exact enough so to give a little buffer,
    #   we add a tiny value to the reaper interval.
    #
    # @return [Integer] <description>
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#227
    def drift_reaper_interval; end

    # Checks if reaping is enabled
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#185
    def enabled?; end

    # A context to use for all log entries
    #
    # @return [Hash] when logger responds to `:with_context`
    # @return [String] when logger does not responds to `:with_context`
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#138
    def logging_context; end

    # @see SidekiqUniqueJobs::Config#reaper
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#120
    def reaper; end

    # @see SidekiqUniqueJobs::Config#reaper_interval
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#127
    def reaper_interval; end

    # Updates mutex key
    #
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#205
    def refresh_reaper_mutex; end

    # Writes a mutex key to redis
    #
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#195
    def register_reaper_process; end

    # Checks if a reaper is registered
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#152
    def registered?; end

    # Starts a separate thread that periodically reaps orphans
    #
    # @return [SidekiqUniqueJobs::TimerTask] the task that was started
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#35
    def start(test_task = T.unsafe(nil)); end

    # Stops the thread that reaps orphans
    #
    # @return [Boolean]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#58
    def stop; end

    # The task that runs the reaper
    #
    # @return [<type>] <description>
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#75
    def task; end

    # Store a task to use for scheduled execution
    #
    # @param task [SidekiqUniqueJobs::TimerTask] the task to use
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#103
    def task=(task); end

    # Arguments passed on to the timer task
    #
    # @return [Hash]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#113
    def timer_task_options; end

    # Removes mutex key from redis
    #
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#215
    def unregister_reaper_process; end

    # Checks if that reapers are not registerd
    #
    # @return [true, false]
    # @see registered?
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#165
    def unregistered?; end
  end
end

# @return [Float] the amount to add to the reaper interval
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#17
SidekiqUniqueJobs::Orphans::Manager::DRIFT_FACTOR = T.let(T.unsafe(nil), Float)

# @return [Symbol] allowed reapers (:ruby or :lua)
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/manager.rb#20
SidekiqUniqueJobs::Orphans::Manager::REAPERS = T.let(T.unsafe(nil), Array)

# Class DeleteOrphans provides deletion of orphaned digests
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
# @note this is a much slower version of the lua script but does not crash redis
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/null_reaper.rb#12
class SidekiqUniqueJobs::Orphans::NullReaper < ::SidekiqUniqueJobs::Orphans::Reaper
  # Delete orphaned digests
  #
  # @return [Integer] the number of reaped locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/null_reaper.rb#19
  def call; end
end

# Observes the Orphan::Manager and provides information about each execution
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/observer.rb#17
class SidekiqUniqueJobs::Orphans::Observer
  include ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Logging

  # Runs every time the {Manager} executes the TimerTask
  #   used for logging information about the reaping
  #
  # @param time [Time] the time of the execution
  # @param result [Object] the result of the execution
  # @param ex [Exception] any error raised from the TimerTask
  # @return [<type>] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/observer.rb#30
  def update(time, result, ex); end
end

# Class DeleteOrphans provides deletion of orphaned digests
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
# @note this is a much slower version of the lua script but does not crash redis
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#12
class SidekiqUniqueJobs::Orphans::Reaper
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Script::Caller
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::JSON
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging

  # Initialize a new instance of DeleteOrphans
  #
  # @param conn [Redis] a connection to redis
  # @return [Reaper] a new instance of Reaper
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#56
  def initialize(conn); end

  # Delete orphaned digests
  #
  # @return [Integer] the number of reaped locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#106
  def call; end

  # Convenient access to the global configuration
  #
  # @return [SidekiqUniqueJobs::Config]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#66
  def config; end

  # Returns the value of attribute conn.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#49
  def conn; end

  # The reaper that was configured
  #
  # @return [Symbol]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#76
  def reaper; end

  # The number of locks to reap at a time
  #
  # @return [Integer]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#96
  def reaper_count; end

  # The configured timeout for the reaper
  #
  # @return [Integer] timeout in seconds
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#86
  def reaper_timeout; end

  class << self
    # Execute deletion of orphaned digests
    #
    # @param conn [Redis] nil a connection to redis
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#40
    def call(conn = T.unsafe(nil)); end
  end
end

# @return [Hash<Symbol, SidekiqUniqueJobs::Orphans::Reaper] the current implementation of reapers] Hash<Symbol, SidekiqUniqueJobs::Orphans::Reaper] the current implementation of reapers
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper.rb#24
SidekiqUniqueJobs::Orphans::Reaper::REAPERS = T.let(T.unsafe(nil), Hash)

# Restarts orphan manager if it is considered dead
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#6
module SidekiqUniqueJobs::Orphans::ReaperResurrector
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#165
  def current_timestamp; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#161
  def drift_reaper_interval; end

  # A context to use for all log entries
  #
  # @return [Hash] when logger responds to `:with_context`
  # @return [String] when logger does not responds to `:with_context`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#142
  def logging_context; end

  # Returns orphan manager
  #
  # @return [SidekiqUniqueJobs::Orphans::Manager]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#65
  def orphans_manager; end

  # @see SidekiqUniqueJobs::Config#reaper
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#120
  def reaper; end

  # Checks if reaping is disabled
  #
  # @return [true, false]
  # @see reaper_enabled?
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#94
  def reaper_disabled?; end

  # Checks if reaping is enabled
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#103
  def reaper_enabled?; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#157
  def reaper_interval; end

  # Checks if reaper is registered
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#111
  def reaper_registered?; end

  # @see SidekiqUniqueJobs::Config#reaper_resurrector_interval
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#153
  def reaper_resurrector_interval; end

  # Starts new instance of orphan reaper if reaper is considered dead (reaper mutex has not been refreshed lately)
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#54
  def restart_if_dead; end

  # Checks if resurrector is disabled
  #
  # @return [true, false]
  # @see resurrector_enabled?
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#75
  def resurrector_disabled?; end

  # Checks if resurrector is enabled
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#83
  def resurrector_enabled?; end

  # Runs reaper resurrector task
  #
  # @return [SidekiqUniqueJobs::TimerTask]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#33
  def run_task; end

  # Starts reaper resurrector that watches orphans reaper
  #
  # @return [SidekiqUniqueJobs::TimerTask] the task that was started
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#20
  def start; end

  # The task that runs the resurrector
  #
  # @return [SidekiqUniqueJobs::TimerTask]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#43
  def task; end

  # Arguments passed on to the timer task
  #
  # @return [Hash]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#130
  def timer_task_options; end

  class << self
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#165
    def current_timestamp; end

    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#161
    def drift_reaper_interval; end

    # A context to use for all log entries
    #
    # @return [Hash] when logger responds to `:with_context`
    # @return [String] when logger does not responds to `:with_context`
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#142
    def logging_context; end

    # Returns orphan manager
    #
    # @return [SidekiqUniqueJobs::Orphans::Manager]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#65
    def orphans_manager; end

    # @see SidekiqUniqueJobs::Config#reaper
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#120
    def reaper; end

    # Checks if reaping is disabled
    #
    # @return [true, false]
    # @see reaper_enabled?
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#94
    def reaper_disabled?; end

    # Checks if reaping is enabled
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#103
    def reaper_enabled?; end

    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#157
    def reaper_interval; end

    # Checks if reaper is registered
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#111
    def reaper_registered?; end

    # @see SidekiqUniqueJobs::Config#reaper_resurrector_interval
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#153
    def reaper_resurrector_interval; end

    # Starts new instance of orphan reaper if reaper is considered dead (reaper mutex has not been refreshed lately)
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#54
    def restart_if_dead; end

    # Checks if resurrector is disabled
    #
    # @return [true, false]
    # @see resurrector_enabled?
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#75
    def resurrector_disabled?; end

    # Checks if resurrector is enabled
    #
    # @return [true, false]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#83
    def resurrector_enabled?; end

    # Runs reaper resurrector task
    #
    # @return [SidekiqUniqueJobs::TimerTask]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#33
    def run_task; end

    # Starts reaper resurrector that watches orphans reaper
    #
    # @return [SidekiqUniqueJobs::TimerTask] the task that was started
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#20
    def start; end

    # The task that runs the resurrector
    #
    # @return [SidekiqUniqueJobs::TimerTask]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#43
    def task; end

    # Arguments passed on to the timer task
    #
    # @return [Hash]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#130
    def timer_task_options; end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#12
SidekiqUniqueJobs::Orphans::ReaperResurrector::DRIFT_FACTOR = T.let(T.unsafe(nil), Float)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/reaper_resurrector.rb#13
SidekiqUniqueJobs::Orphans::ReaperResurrector::REAPERS = T.let(T.unsafe(nil), Array)

# Class DeleteOrphans provides deletion of orphaned digests
#
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
# @note this is a much slower version of the lua script but does not crash redis
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#13
class SidekiqUniqueJobs::Orphans::RubyReaper < ::SidekiqUniqueJobs::Orphans::Reaper
  include ::SidekiqUniqueJobs::Timing

  # Initialize a new instance of DeleteOrphans
  #
  # @param conn [Redis] a connection to redis
  # @return [RubyReaper] a new instance of RubyReaper
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#59
  def initialize(conn); end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#200
  def active?(digest); end

  # Checks if the digest has a matching job.
  #   1. It checks the scheduled set
  #   2. It checks the retry set
  #   3. It goes through all queues
  #
  # @param digest [String] the digest to search for
  # @return [true] when either of the checks return true
  # @return [false] when no job was found for this digest
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#155
  def belongs_to_job?(digest); end

  # Delete orphaned digests
  #
  # @return [Integer] the number of reaped locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#75
  def call; end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#239
  def considered_active?(time_f); end

  # Returns the value of attribute digests.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#28
  def digests; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#139
  def elapsed_ms; end

  # Checks if the digest exists in a Sidekiq::Queue
  #
  # @param digest [String] the current digest
  # @return [true] when digest exists in any queue
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#188
  def enqueued?(digest); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#256
  def entries(conn, queue, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#92
  def expired_digests; end

  # Checks a sorted set for the existance of this digest
  #
  # @param key [String] the key for the sorted set
  # @param digest [String] the digest to scan for
  # @return [true] when found
  # @return [false] when missing
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#307
  def in_sorted_set?(key, digest); end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#233
  def match?(key_one, key_two); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#100
  def max_score; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#96
  def orphaned_digests; end

  # Find orphaned digests
  #
  # @return [Array<String>] an array of orphaned digests
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#110
  def orphans; end

  # Loops through all the redis queues and yields them one by one
  #
  # @param conn [Redis] the connection to use for fetching queues
  # @return [void]
  # @yield queues one at a time
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#252
  def queues(conn, &block); end

  # If sidekiq queues are very full, it becomes highly inefficient for the reaper
  # because it must check every queued job to verify a digest is safe to delete
  # The reaper checks queued jobs in batches of 50, adding 2 reads per digest
  # With a queue length of 1,000 jobs, that's over 20 extra reads per digest.
  #
  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#285
  def queues_very_full?; end

  # Returns the value of attribute retried.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#36
  def retried; end

  # Checks if the digest exists in the Sidekiq::RetrySet
  #
  # @param digest [String] the current digest
  # @return [true] when digest exists in retry set
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#177
  def retried?(digest); end

  # Returns the value of attribute scheduled.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#32
  def scheduled; end

  # Checks if the digest exists in the Sidekiq::ScheduledSet
  #
  # @param digest [String] the current digest
  # @return [true] when digest exists in scheduled set
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#166
  def scheduled?(digest); end

  # Returns the value of attribute start_source.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#47
  def start_source; end

  # @return [Integer] The clock stamp this execution started represented as integer
  #   (used for redis compatibility as it is more accurate than time)
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#41
  def start_time; end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#135
  def timeout?; end

  # Returns the value of attribute timeout_ms.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#52
  def timeout_ms; end
end

# @return [Integer] the maximum combined length of sidekiq queues for running the reaper
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#24
SidekiqUniqueJobs::Orphans::RubyReaper::MAX_QUEUE_LENGTH = T.let(T.unsafe(nil), Integer)

# @return [String] the suffix for :RUN locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#21
SidekiqUniqueJobs::Orphans::RubyReaper::RUN_SUFFIX = T.let(T.unsafe(nil), String)

# @return [Integer] a best guess of Sidekiq::Launcher::BEAT_PAUSE
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/orphans/ruby_reaper.rb#18
SidekiqUniqueJobs::Orphans::RubyReaper::SIDEKIQ_BEAT_PAUSE = T.let(T.unsafe(nil), Integer)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#37
SidekiqUniqueJobs::PAYLOAD = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#38
SidekiqUniqueJobs::PROCESSES = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#39
SidekiqUniqueJobs::QUEUE = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#40
SidekiqUniqueJobs::RETRY = T.let(T.unsafe(nil), String)

# Augments and enhances redis with object oriented methods
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis.rb#9
module SidekiqUniqueJobs::Redis; end

# Class Entity functions as a base class for redis types
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#10
class SidekiqUniqueJobs::Redis::Entity
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Connection
  include ::SidekiqUniqueJobs::Script::Caller
  include ::SidekiqUniqueJobs::JSON
  include ::SidekiqUniqueJobs::Timing
  extend ::SidekiqUniqueJobs::Logging

  # Initialize a new Entity
  #
  # @param key [String] the redis key for this entity
  # @return [Entity] a new instance of Entity
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#37
  def initialize(key); end

  # Returns the number of entries in this entity
  #
  # @return [Integer] 0
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#101
  def count; end

  # Checks if the key for this entity exists in redis
  #
  # @return [true] when exists
  # @return [false] when not exists
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#48
  def exist?; end

  # Check if the entity has expiration
  #
  # @return [true] when entity is set to exire
  # @return [false] when entity isn't expiring
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#91
  def expires?; end

  # Returns the value of attribute key.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#30
  def key; end

  # The number of microseconds until the key expires
  #
  # @return [Integer] expiration in milliseconds
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#70
  def pttl; end

  # The number of seconds until the key expires
  #
  # @return [Integer] expiration in seconds
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#80
  def ttl; end

  private

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/entity.rb#107
  def boolean?(value); end
end

# Class Hash provides convenient access to redis hashes
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/hash.rb#10
class SidekiqUniqueJobs::Redis::Hash < ::SidekiqUniqueJobs::Redis::Entity
  # Get a members value
  #
  # @param member [String] the member who's value to get
  # @return [Object] whatever is stored on this hash member
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/hash.rb#41
  def [](member); end

  # Returns the count for this hash
  #
  # @return [Integer] the length of this hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/hash.rb#51
  def count; end

  # Removes the key from redis
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/hash.rb#30
  def del(*fields); end

  # Return entries for this hash
  #
  # @param with_values [true, false] false return hash
  # @return [Array<Object>] when given with_values: false
  # @return [Hash<String, String>] when given with_values: true
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/hash.rb#19
  def entries(with_values: T.unsafe(nil)); end
end

# Class List provides convenient access to redis hashes
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/list.rb#10
class SidekiqUniqueJobs::Redis::List < ::SidekiqUniqueJobs::Redis::Entity
  # The number of entries in this list
  #
  # @return [Integer] the total number of entries
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/list.rb#27
  def count; end

  # Entries in this list
  #
  # @return [Array<Object>] the elements in this list
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/list.rb#17
  def entries; end
end

# Class Set provides convenient access to redis sets
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/set.rb#10
class SidekiqUniqueJobs::Redis::Set < ::SidekiqUniqueJobs::Redis::Entity
  # Returns the count for this sorted set
  #
  # @return [Integer] the number of entries
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/set.rb#27
  def count; end

  # Return entries for this set
  #
  # @return [Array<String>]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/set.rb#17
  def entries; end
end

# Class SortedSet provides convenient access to redis sorted sets
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#10
class SidekiqUniqueJobs::Redis::SortedSet < ::SidekiqUniqueJobs::Redis::Entity
  # Adds a value to the sorted set
  #
  # @param values [Array<Float, String>, String] the values to add
  # @return [Boolean, Integer] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#41
  def add(values); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#51
  def byscore(min, max, offset: T.unsafe(nil), count: T.unsafe(nil)); end

  # Clears the sorted set from all entries
  #
  # @return [Integer] number of entries removed
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#87
  def clear; end

  # Returns the count for this sorted set
  #
  # @return [Integer] the number of entries
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#97
  def count; end

  # Return entries for this sorted set
  #
  # @param with_scores [true, false] true return
  # @return [Array<Object>] when given with_scores: false
  # @return [Hash] when given with_scores: true
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#26
  def entries(with_scores: T.unsafe(nil)); end

  # Return the zrak of the member
  #
  # @param member [String] the member to pull rank on
  # @return [Integer]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#66
  def rank(member); end

  # Return score for a member
  #
  # @param member [String] the member for which score
  # @return [Integer, Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#77
  def score(member); end
end

# @return [Integer] the number of matches to return by default
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#13
SidekiqUniqueJobs::Redis::SortedSet::DEFAULT_COUNT = T.let(T.unsafe(nil), Integer)

# @return [String] the default pattern to use for matching
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/sorted_set.rb#16
SidekiqUniqueJobs::Redis::SortedSet::SCAN_PATTERN = T.let(T.unsafe(nil), String)

# Class String provides convenient access to redis strings
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/string.rb#10
class SidekiqUniqueJobs::Redis::String < ::SidekiqUniqueJobs::Redis::Entity
  # Used only for compatibility with other keys
  #
  # @return [1] when key exists
  # @return [0] when key does not exists
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/string.rb#46
  def count; end

  # Removes the key from redis
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/string.rb#37
  def del(*_arg0); end

  # Sets the value of the key to given object
  #
  # @param obj [String] the object to update the key with
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/string.rb#28
  def set(obj, pipeline = T.unsafe(nil)); end

  # Returns the value of the key
  #
  # @return [String]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/redis/string.rb#17
  def value; end
end

# Module Reflectable provides a method to notify subscribers
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflectable.rb#9
module SidekiqUniqueJobs::Reflectable
  # Reflects on specific event
  #
  # @param reflection [Symbol] the reflected event
  # @param args [Array] arguments to provide to reflector
  # @return [void]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflectable.rb#18
  def reflect(reflection, *args); end
end

# Class NotificationCollection provides a collection with known notifications
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#9
class SidekiqUniqueJobs::Reflections
  # @return [Reflections] a new instance of Reflections
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#41
  def initialize; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def after_unlock_callback_failed(*args, &block); end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#71
  def configured?(reflection); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def debug(*args, &block); end

  # Dispatch a reflected event
  #
  # @param reflection [reflection] the reflected event
  # @param args [Array] the arguments to provide to the block
  # @return [void] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#53
  def dispatch(reflection, *args); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def duplicate(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def error(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def execution_failed(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def lock_failed(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def locked(*args, &block); end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#75
  def misconfigured?(reflection); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def reschedule_failed(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def rescheduled(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def timeout(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def unknown_sidekiq_worker(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def unlock_failed(*args, &block); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#34
  def unlocked(*args, &block); end
end

# @return [Hash<Symbol, Array<Symbol, String>>] a hash with deprecated notifications
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#30
SidekiqUniqueJobs::Reflections::DEPRECATIONS = T.let(T.unsafe(nil), Hash)

# @return [Array<Symbol>] list of notifications
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/reflections.rb#12
SidekiqUniqueJobs::Reflections::REFLECTIONS = T.let(T.unsafe(nil), Array)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#41
SidekiqUniqueJobs::SCHEDULE = T.let(T.unsafe(nil), String)

# Interface to dealing with .lua files
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#7
module SidekiqUniqueJobs::Script
  include ::SidekiqUniqueJobs::Script::DSL
  extend ::SidekiqUniqueJobs::Script::DSL::ClassMethods

  class << self
    # The current logger
    #
    # @return [Logger] the configured logger
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script.rb#31
    def logger; end

    # Set a new logger
    #
    # @param other [Logger] another logger
    # @return [Logger] the new logger
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script.rb#42
    def logger=(other); end
  end
end

# Module Caller provides the convenience method #call_script
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#13
module SidekiqUniqueJobs::Script::Caller
  include ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Connection

  private

  # Convenience method to reduce typing,
  #   calls redis lua scripts.
  #
  # @overload call_script
  # @overload call_script
  # @return [true, false, String, Integer, Float, nil] returns the return value of the lua script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#41
  def call_script(file_name, *args); end

  # @see SidekiqUniqueJobs::Config#debug_lua
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#103
  def debug_lua; end

  # Only used to reduce a little bit of duplication
  #
  # @see call_script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#56
  def do_call(file_name, conn, keys, argv); end

  # Utility method to allow both symbol keys and arguments
  #
  # @overload call_script
  # @overload call_script
  # @return [Array<Redis, Array, Array>] <description>
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#81
  def extract_args(*args); end

  # @see SidekiqUniqueJobs::Config#max_history
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#110
  def max_history; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#121
  def normalize_argv(argv); end

  # @see SidekiqUniqueJobs#now_f
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#96
  def now_f; end

  # @see SidekiqUniqueJobs::Config#max_history
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#117
  def redis_version; end

  class << self
    # Convenience method to reduce typing,
    #   calls redis lua scripts.
    #
    # @overload call_script
    # @overload call_script
    # @return [true, false, String, Integer, Float, nil] returns the return value of the lua script
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#41
    def call_script(file_name, *args); end

    # @see SidekiqUniqueJobs::Config#debug_lua
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#103
    def debug_lua; end

    # Only used to reduce a little bit of duplication
    #
    # @see call_script
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#56
    def do_call(file_name, conn, keys, argv); end

    # Utility method to allow both symbol keys and arguments
    #
    # @overload call_script
    # @overload call_script
    # @return [Array<Redis, Array, Array>] <description>
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#81
    def extract_args(*args); end

    # @see SidekiqUniqueJobs::Config#max_history
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#110
    def max_history; end

    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#121
    def normalize_argv(argv); end

    # @see SidekiqUniqueJobs#now_f
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#96
    def now_f; end

    # @see SidekiqUniqueJobs::Config#max_history
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/caller.rb#117
    def redis_version; end
  end
end

# Interface to dealing with .lua files
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#8
class SidekiqUniqueJobs::Script::Client
  include ::SidekiqUniqueJobs::Script::Timing

  # @return [Client] a new instance of Client
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#24
  def initialize(config); end

  # Returns the value of attribute config.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#18
  def config; end

  # Execute a lua script with the provided script_name
  #
  # @note this method is recursive if we need to load a lua script
  #   that wasn't previously loaded.
  # @param script_name [Symbol] the name of the script to execute
  # @param conn [Redis] the redis connection to use for execution
  # @param keys [Array<String>] script keys
  # @param argv [Array<Object>] script arguments
  # @return value from script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#43
  def execute(script_name, conn, keys: T.unsafe(nil), argv: T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#14
  def logger; end

  # Returns the value of attribute scripts.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#22
  def scripts; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#85
  def handle_busy(conn); end

  # Handle errors to allow retrying errors that need retrying
  #
  # @param ex [RedisClient::CommandError] exception to handle
  # @raise [LuaError]
  # @return [void]
  # @yieldreturn [void] yields back to the caller when NOSCRIPT is raised
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#66
  def handle_error(script_name, conn, ex); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/client.rb#80
  def handle_noscript(script_name); end
end

# Class holding gem configuration
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#9
class SidekiqUniqueJobs::Script::Config
  # Initialize a new instance of {Config}
  #
  # @return [Config] a new instance of Config
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#23
  def initialize; end

  # Returns the value of attribute logger.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#13
  def logger; end

  # Sets a value for logger
  #
  # @param obj [Logger] a logger to use
  # @raise [ArgumentError] when given argument isn't a Logger
  # @return [Logger]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#61
  def logger=(obj); end

  # Returns the value of attribute scripts_path.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#17
  def scripts_path; end

  # Sets a value for scripts_path
  #
  # @param obj [String, Pathname] <description>
  # @raise [ArgumentError] when directory does not exist
  # @raise [ArgumentError] when argument isn't supported
  # @return [Pathname]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/config.rb#39
  def scripts_path=(obj); end
end

# Interface to dealing with .lua files
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#8
module SidekiqUniqueJobs::Script::DSL
  mixes_in_class_methods ::SidekiqUniqueJobs::Script::DSL::ClassMethods

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#11
    def included(base); end
  end
end

# Module ClassMethods extends the base class with necessary methods
#
# @author Mikael Henriksson <mikael@zoolutions.se>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#22
module SidekiqUniqueJobs::Script::DSL::ClassMethods
  # The current configuration (See: {.configure} on how to configure)
  #
  # @return [Script::Config] the gem configuration
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#52
  def config; end

  # Configure the gem
  #
  # This is usually called once at startup of an application
  #
  # @option options
  # @option options
  # @param options [Hash] global gem options
  # @yield control to the caller when given block
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#36
  def configure(options = T.unsafe(nil)); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#23
  def execute(file_name, conn, keys: T.unsafe(nil), argv: T.unsafe(nil)); end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/dsl.rb#9
SidekiqUniqueJobs::Script::DSL::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# Utility module for reducing the number of uses of logger.
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#8
module SidekiqUniqueJobs::Script::Logging
  # Logs a message at debug level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#33
  def log_debug(message_or_exception = T.unsafe(nil), &block); end

  # Logs a message at error level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#75
  def log_error(message_or_exception = T.unsafe(nil), &block); end

  # Logs a message at fatal level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#89
  def log_fatal(message_or_exception = T.unsafe(nil), &block); end

  # Logs a message at info level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#47
  def log_info(message_or_exception = T.unsafe(nil), &block); end

  # Logs a message at warn level
  #
  # @param message_or_exception [String, Exception] the message or exception to log
  # @return [void]
  # @yield [String, Exception] the message or exception to use for log message
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#61
  def log_warn(message_or_exception = T.unsafe(nil), &block); end

  # A convenience method for using the configured gem logger
  #
  # @return [Logger]
  # @see Script#.logger
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#20
  def logger; end

  class << self
    # @private
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/logging.rb#9
    def included(base); end
  end
end

# LuaError raised on errors in Lua scripts
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#16
class SidekiqUniqueJobs::Script::LuaError < ::RuntimeError
  # Initialize a new {LuaError} from an existing redis error, adjusting
  # the message and backtrace in the process.
  #
  # @param error [StandardError] the original error raised by redis
  # @param script [Script] a DTO with information about the script
  # @return [LuaError] a new instance of LuaError
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#43
  def initialize(error, script); end

  # Returns the value of attribute content.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#27
  def content; end

  # Returns the value of attribute error.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#27
  def error; end

  # Returns the value of attribute file.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#27
  def file; end

  private

  # :nocov:
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#86
  def backtrace_before_entering_gem(backtrace); end

  # :nocov:
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#76
  def generate_backtrace(file, line_number); end

  # :nocov:
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#62
  def generate_error_context(content, line_number); end

  # :nocov:
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#91
  def line_from_gem(line); end

  class << self
    # Is this error one that should be reformatted?
    #
    # @param error [StandardError] the original error raised by redis
    # @return [Boolean] is this an error that should be reformatted?
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#33
    def intercepts?(error); end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#25
SidekiqUniqueJobs::Script::LuaError::CONTEXT_LINE_NUMBER = T.let(T.unsafe(nil), Integer)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#24
SidekiqUniqueJobs::Script::LuaError::LIB_PATH = T.let(T.unsafe(nil), String)

# Reformats errors raised by redis representing failures while executing
# a lua script. The default errors have confusing messages and backtraces,
# and a type of +RuntimeError+. This class improves the message and
# modifies the backtrace to include the lua script itself in a reasonable
# way.
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#23
SidekiqUniqueJobs::Script::LuaError::PATTERN = T.let(T.unsafe(nil), Regexp)

# Misconfiguration is raised when gem is misconfigured
#
# @author Mikael Henriksson <mikael@zoolutions.se>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/lua_error.rb#10
class SidekiqUniqueJobs::Script::Misconfiguration < ::RuntimeError; end

# Interface to dealing with .lua files
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#8
class SidekiqUniqueJobs::Script::Script
  # @return [Script] a new instance of Script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#39
  def initialize(name:, root_path:); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#48
  def ==(other); end

  # Returns the value of attribute call_count.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#37
  def call_count; end

  # @return [Boolean]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#56
  def changed?; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#64
  def compiled_sha; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#52
  def increment_call_count; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#68
  def load(conn); end

  # Returns the value of attribute name.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#17
  def name; end

  # Returns the value of attribute path.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#21
  def path; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#60
  def render_file; end

  # Returns the value of attribute root_path.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#25
  def root_path; end

  # Returns the value of attribute sha.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#33
  def sha; end

  # Returns the value of attribute source.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#29
  def source; end

  class << self
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/script.rb#9
    def load(name, root_path, conn); end
  end
end

# Interface to dealing with .lua files
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#8
class SidekiqUniqueJobs::Script::Scripts
  # @raise [ArgumentError]
  # @return [Scripts] a new instance of Scripts
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#62
  def initialize(path); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#118
  def count; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#84
  def delete(script); end

  # Execute a lua script with given name
  #
  # @note this method is recursive if we need to load a lua script
  #   that wasn't previously loaded.
  # @param name [Symbol] the name of the script to execute
  # @param conn [Redis] the redis connection to use for execution
  # @param keys [Array<String>] script keys
  # @param argv [Array<Object>] script arguments
  # @return value from script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#113
  def execute(name, conn, keys: T.unsafe(nil), argv: T.unsafe(nil)); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#69
  def fetch(name, conn); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#92
  def kill(conn); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#77
  def load(name, conn); end

  # Returns the value of attribute root_path.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#60
  def root_path; end

  # Returns the value of attribute scripts.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#55
  def scripts; end

  class << self
    # Create a new scripts collection based on path
    #
    # @param root_path [Pathname] the path to scripts
    # @return [Scripts] a collection of scripts
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#35
    def create(root_path); end

    # Fetch a scripts configuration for path
    #
    # @param root_path [Pathname] the path to scripts
    # @return [Scripts] a collection of scripts
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#20
    def fetch(root_path); end

    # Store the scripts collection in memory
    #
    # @param scripts [Scripts] the path to scripts
    # @return [Scripts] the scripts instance that was stored
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#47
    def store(scripts); end
  end
end

# @return [Concurrent::Map] a map with configured script paths
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/scripts.rb#11
SidekiqUniqueJobs::Script::Scripts::SCRIPT_PATHS = T.let(T.unsafe(nil), Concurrent::Map)

# Class Template provides LUA script partial template rendering
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#13
class SidekiqUniqueJobs::Script::Template
  # @return [Template] a new instance of Template
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#14
  def initialize(script_path); end

  # helper method to include a lua partial within another lua script
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#33
  def include_partial(relative_path); end

  # Renders a Lua script and includes any partials in that file
  #  all `<%= include_partial '' %>` replaced with the actual contents of the partial
  #
  # @param pathname [Pathname] the path to the
  # @return [String] the rendered Luascript
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/template.rb#26
  def render(pathname); end
end

# Handles timing> of things
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/timing.rb#8
module SidekiqUniqueJobs::Script::Timing
  private

  # Returns a float representation of the current time.
  #   Either from Process or Time
  #
  # @return [Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/timing.rb#30
  def now; end

  # Used for timing method calls
  #
  # @return [yield return, Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/timing.rb#17
  def timed; end

  class << self
    # Returns a float representation of the current time.
    #   Either from Process or Time
    #
    # @return [Float]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/timing.rb#30
    def now; end

    # Used for timing method calls
    #
    # @return [yield return, Float]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/script/timing.rb#17
    def timed; end
  end
end

# The unique sidekiq middleware for the server processor
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#7
class SidekiqUniqueJobs::Server
  class << self
    # Configure the server middleware
    #
    # @return [Sidekiq] the sidekiq configuration
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#21
    def configure(config); end

    # A death handler for dead jobs
    #
    # @return [lambda]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#58
    def death_handler; end

    # Start the sidekiq unique jobs server process
    #
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#36
    def start; end

    # Stop the sidekiq unique jobs server process
    #
    # @return [void]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#48
    def stop; end
  end
end

# @return [Proc] returns a default death handler for the gem to cleanup dead locks
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/server.rb#10
SidekiqUniqueJobs::Server::DEATH_HANDLER = T.let(T.unsafe(nil), Proc)

# Module with convenience methods for the Sidekiq::Job class
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#7
module SidekiqUniqueJobs::SidekiqWorkerMethods
  # The hook to call after a successful unlock
  #
  # @return [Proc]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#42
  def after_unlock_hook; end

  # Returns the default worker options from Sidekiq
  #
  # @return [Hash<Symbol, Object>]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#76
  def default_job_options; end

  # Returns the value of attribute job_class.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#11
  def job_class; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#34
  def job_class=(obj); end

  # Attempt to constantize a string worker_class argument, always
  # failing back to the original argument when the constant can't be found
  #
  # @return [Sidekiq::Job]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#66
  def job_class_constantize(klazz = T.unsafe(nil)); end

  # Avoids duplicating worker_class.respond_to? in multiple places
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#15
  def job_method_defined?(method_sym); end

  # Wraps #get_sidekiq_options to always work with a hash
  #
  # @return [Hash] of the worker class sidekiq options
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#21
  def job_options; end

  # Tests that the
  #
  # @return [true] if job_class responds to get_sidekiq_options
  # @return [false] if job_class does not respond to get_sidekiq_options
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/sidekiq_worker_methods.rb#30
  def sidekiq_job_class?; end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#42
SidekiqUniqueJobs::TIME = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#43
SidekiqUniqueJobs::TIMEOUT = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#44
SidekiqUniqueJobs::TTL = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#45
SidekiqUniqueJobs::TYPE = T.let(T.unsafe(nil), String)

# ThreadSafe config exists to be able to document the config class without errors
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/config.rb#5
SidekiqUniqueJobs::ThreadSafeConfig = Concurrent::MutableStruct::ThreadSafeConfig

# A very common concurrency pattern is to run a thread that performs a task at
# regular intervals. The thread that performs the task sleeps for the given
# interval then wakes up and performs the task. Lather, rinse, repeat... This
# pattern causes two problems. First, it is difficult to test the business
# logic of the task because the task itself is tightly coupled with the
# concurrency logic. Second, an exception raised while performing the task can
# cause the entire thread to abend. In a long-running application where the
# task thread is intended to run for days/weeks/years a crashed task thread
# can pose a significant problem. `TimerTask` alleviates both problems.
#
# When a `TimerTask` is launched it starts a thread for monitoring the
# execution interval. The `TimerTask` thread does not perform the task,
# however. Instead, the TimerTask launches the task on a separate thread.
# Should the task experience an unrecoverable crash only the task thread will
# crash. This makes the `TimerTask` very fault tolerant. Additionally, the
# `TimerTask` thread can respond to the success or failure of the task,
# performing logging or ancillary operations.
#
# One other advantage of `TimerTask` is that it forces the business logic to
# be completely decoupled from the concurrency logic. The business logic can
# be tested separately then passed to the `TimerTask` for scheduling and
# running.
#
# In some cases it may be necessary for a `TimerTask` to affect its own
# execution cycle. To facilitate this, a reference to the TimerTask instance
# is passed as an argument to the provided block every time the task is
# executed.
#
# The `TimerTask` class includes the `Dereferenceable` mixin module so the
# result of the last execution is always available via the `#value` method.
# Dereferencing options can be passed to the `TimerTask` during construction or
# at any later time using the `#set_deref_options` method.
#
# `TimerTask` supports notification through the Ruby standard library
# {http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html
# Observable} module. On execution the `TimerTask` will notify the observers
# with three arguments: time of execution, the result of the block (or nil on
# failure), and any raised exceptions (or nil on success).
#
# @example Basic usage
#   task = Concurrent::TimerTask.new{ puts 'Boom!' }
#   task.execute
#
#   task.execution_interval #=> 60 (default)
#
#   # wait 60 seconds...
#   #=> 'Boom!'
#
#   task.shutdown #=> true
# @example Configuring `:execution_interval`
#   task = Concurrent::TimerTask.new(execution_interval: 5) do
#   puts 'Boom!'
#   end
#
#   task.execution_interval #=> 5
# @example Immediate execution with `:run_now`
#   task = Concurrent::TimerTask.new(run_now: true){ puts 'Boom!' }
#   task.execute
#
#   #=> 'Boom!'
# @example Last `#value` and `Dereferenceable` mixin
#   task = Concurrent::TimerTask.new(
#   dup_on_deref: true,
#   execution_interval: 5
#   ){ Time.now }
#
#   task.execute
#   Time.now   #=> 2013-11-07 18:06:50 -0500
#   sleep(10)
#   task.value #=> 2013-11-07 18:06:55 -0500
# @example Controlling execution from within the block
#   timer_task = Concurrent::TimerTask.new(execution_interval: 1) do |task|
#   task.execution_interval.times{ print 'Boom! ' }
#   print "\n"
#   task.execution_interval += 1
#   if task.execution_interval > 5
#   puts 'Stopping...'
#   task.shutdown
#   end
#   end
#
#   timer_task.execute # blocking call - this task will stop itself
#   #=> Boom!
#   #=> Boom! Boom!
#   #=> Boom! Boom! Boom!
#   #=> Boom! Boom! Boom! Boom!
#   #=> Boom! Boom! Boom! Boom! Boom!
#   #=> Stopping...
# @example Observation
#   class TaskObserver
#   def update(time, result, ex)
#   if result
#   print "(#{time}) Execution successfully returned #{result}\n"
#   else
#   print "(#{time}) Execution failed with error #{ex}\n"
#   end
#   end
#   end
#
#   task = Concurrent::TimerTask.new(execution_interval: 1){ 42 }
#   task.add_observer(TaskObserver.new)
#   task.execute
#   sleep 4
#
#   #=> (2013-10-13 19:08:58 -0400) Execution successfully returned 42
#   #=> (2013-10-13 19:08:59 -0400) Execution successfully returned 42
#   #=> (2013-10-13 19:09:00 -0400) Execution successfully returned 42
#   task.shutdown
#
#   task = Concurrent::TimerTask.new(execution_interval: 1){ sleep }
#   task.add_observer(TaskObserver.new)
#   task.execute
#
#   #=> (2013-10-13 19:07:25 -0400) Execution timed out
#   #=> (2013-10-13 19:07:27 -0400) Execution timed out
#   #=> (2013-10-13 19:07:29 -0400) Execution timed out
#   task.shutdown
#
#   task = Concurrent::TimerTask.new(execution_interval: 1){ raise StandardError }
#   task.add_observer(TaskObserver.new)
#   task.execute
#
#   #=> (2013-10-13 19:09:37 -0400) Execution failed with error StandardError
#   #=> (2013-10-13 19:09:38 -0400) Execution failed with error StandardError
#   #=> (2013-10-13 19:09:39 -0400) Execution failed with error StandardError
#   task.shutdown
# @see http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html
# @see http://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#149
class SidekiqUniqueJobs::TimerTask < ::Concurrent::RubyExecutorService
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable

  # Create a new TimerTask with the given task and configuration.
  #
  # @option opts
  # @option opts
  # @param opts [Hash] the options defining task execution.
  # @raise ArgumentError when no block is given.
  # @return [TimerTask] the new `TimerTask`
  # @yield to the block after :execution_interval seconds have passed since
  #   the last yield
  # @yieldparam task a reference to the `TimerTask` instance so that the
  #   block can control its own lifecycle. Necessary since `self` will
  #   refer to the execution context of the block rather than the running
  #   `TimerTask`.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#181
  def initialize(opts = T.unsafe(nil), &task); end

  # Execute a previously created `TimerTask`.
  #
  # @example Instance and execute in separate steps
  #   task = Concurrent::TimerTask.new(execution_interval: 10){ print "Hello World\n" }
  #   task.running? #=> false
  #   task.execute
  #   task.running? #=> true
  # @example Instance and execute in one line
  #   task = Concurrent::TimerTask.new(execution_interval: 10){ print "Hello World\n" }.execute
  #   task.running? #=> true
  # @return [TimerTask] a reference to `self`
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#208
  def execute; end

  # @return [Fixnum] Number of seconds after the task completes before the
  #   task is performed again.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#232
  def execution_interval; end

  # @raise [ArgumentError]
  # @return [Fixnum] Number of seconds after the task completes before the
  #   task is performed again.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#239
  def execution_interval=(value); end

  # Is the executor running?
  #
  # @return [Boolean] `true` when running, `false` when shutting down or shutdown
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#191
  def running?; end

  private

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/executor/executor_service.rb#166
  def <<(task); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#284
  def execute_task(completion); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#249
  def ns_initialize(opts, &task); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#271
  def ns_kill_execution; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#265
  def ns_shutdown_execution; end

  # source://concurrent-ruby/1.3.4/lib/concurrent-ruby/concurrent/executor/ruby_executor_service.rb#17
  def post(*args, &task); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#277
  def schedule_next_task(interval = T.unsafe(nil)); end

  class << self
    # Create and execute a new `TimerTask`.
    #
    # @example
    #   task = Concurrent::TimerTask.execute(execution_interval: 10){ print "Hello World\n" }
    #   task.running? #=> true
    # @option opts
    # @option opts
    # @param opts [Hash] the options defining task execution.
    # @raise ArgumentError when no block is given.
    # @return [TimerTask] the new `TimerTask`
    # @yield to the block after :execution_interval seconds have passed since
    #   the last yield
    # @yieldparam task a reference to the `TimerTask` instance so that the
    #   block can control its own lifecycle. Necessary since `self` will
    #   refer to the execution context of the block rather than the running
    #   `TimerTask`.
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#225
    def execute(opts = T.unsafe(nil), &task); end
  end
end

# Default `:execution_interval` in seconds.
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#154
SidekiqUniqueJobs::TimerTask::EXECUTION_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default `:timeout_interval` in seconds.
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timer_task.rb#157
SidekiqUniqueJobs::TimerTask::TIMEOUT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Handles timing of things
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#7
module SidekiqUniqueJobs::Timing
  private

  # Returns a float representation of the current time.
  #   Either from Process or Time
  #
  # @return [Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#50
  def clock_stamp; end

  # Returns the current time as float
  #
  # @return [Float]
  # @see SidekiqUniqueJobs.now_f
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#39
  def now_f; end

  # Used to get a current representation of time as Integer
  #
  # @return [Integer]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#28
  def time_source; end

  # Used for timing method calls
  #
  # @return [yield return, Float]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#16
  def timed; end

  class << self
    # Returns a float representation of the current time.
    #   Either from Process or Time
    #
    # @return [Float]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#50
    def clock_stamp; end

    # Returns the current time as float
    #
    # @return [Float]
    # @see SidekiqUniqueJobs.now_f
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#39
    def now_f; end

    # Used to get a current representation of time as Integer
    #
    # @return [Integer]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#28
    def time_source; end

    # Used for timing method calls
    #
    # @return [yield return, Float]
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/timing.rb#16
    def timed; end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#46
SidekiqUniqueJobs::UNIQUE = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#47
SidekiqUniqueJobs::UNIQUE_ACROSS_QUEUES = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#48
SidekiqUniqueJobs::UNIQUE_ACROSS_WORKERS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#49
SidekiqUniqueJobs::UNIQUE_ARGS = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#50
SidekiqUniqueJobs::UNIQUE_ARGS_METHOD = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#51
SidekiqUniqueJobs::UNIQUE_DIGEST = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#52
SidekiqUniqueJobs::UNIQUE_PREFIX = T.let(T.unsafe(nil), String)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#53
SidekiqUniqueJobs::UNIQUE_REAPER = T.let(T.unsafe(nil), String)

# Base class for all exceptions raised from the gem
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#9
class SidekiqUniqueJobs::UniqueJobsError < ::RuntimeError; end

# Error raised from {OptionsWithFallback#lock_class}
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/exceptions.rb#103
class SidekiqUniqueJobs::UnknownLock < ::SidekiqUniqueJobs::UniqueJobsError; end

# Utility module to help manage unique keys in redis.
# Useful for deleting keys that for whatever reason wasn't deleted
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#8
module SidekiqUniqueJobs::Unlockable
  private

  # Deletes a lock unless it has ttl
  #
  # This is good for situations when a job is locked by another item
  #
  # @param item [Hash] a Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#29
  def delete(item); end

  # Deletes a lock regardless of if it was locked or has ttl.
  #
  # This is good for situations when a job is locked by another item
  #
  # @param item [Hash] a Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#38
  def delete!(item); end

  # Unlocks a job.
  #
  # @param item [Hash] a Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#13
  def unlock(item); end

  # Unlocks a job.
  #
  # @param item [Hash] a Sidekiq job hash
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#20
  def unlock!(item); end

  class << self
    # Deletes a lock unless it has ttl
    #
    # This is good for situations when a job is locked by another item
    #
    # @param item [Hash] a Sidekiq job hash
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#29
    def delete(item); end

    # Deletes a lock regardless of if it was locked or has ttl.
    #
    # This is good for situations when a job is locked by another item
    #
    # @param item [Hash] a Sidekiq job hash
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#38
    def delete!(item); end

    # Unlocks a job.
    #
    # @param item [Hash] a Sidekiq job hash
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#13
    def unlock(item); end

    # Unlocks a job.
    #
    # @param item [Hash] a Sidekiq job hash
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/unlockable.rb#20
    def unlock!(item); end
  end
end

# Class UpdateVersion sets the right version in redis
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/update_version.rb#9
class SidekiqUniqueJobs::UpdateVersion
  class << self
    # Sets the right versions in redis
    #
    # @note the version isn't used yet but will be for automatic upgrades
    # @return [true] when version changed
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/update_version.rb#17
    def call; end
  end
end

# Upgrades locks between gem version upgrades
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#9
class SidekiqUniqueJobs::UpgradeLocks
  include ::SidekiqUniqueJobs::Logging
  include ::SidekiqUniqueJobs::Connection
  extend ::SidekiqUniqueJobs::Logging
  extend ::SidekiqUniqueJobs::Connection

  # @return [UpgradeLocks] a new instance of UpgradeLocks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#39
  def initialize(conn); end

  # Performs upgrade of old locks
  #
  # @return [Integer] the number of upgrades locks
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#51
  def call; end

  # Returns the value of attribute conn.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#37
  def conn; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#115
  def batch_delete(*keys); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#123
  def batch_scan(match:, count:); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#109
  def delete_suffix(suffix); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#105
  def delete_supporting_v6_keys; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#97
  def delete_unused_v6_keys; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#144
  def logging_context; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#136
  def now_f; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#140
  def redis_version; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#86
  def upgrade_v6_lock(grabbed_key); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#76
  def upgrade_v6_locks; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#72
  def upgraded_key; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#132
  def version; end

  class << self
    # Performs upgrade of old locks
    #
    # @return [Integer] the number of upgrades locks
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#31
    def call; end
  end
end

# @return [Integer] the number of keys to batch upgrade
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#12
SidekiqUniqueJobs::UpgradeLocks::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# @return [Array<String>] suffixes for old version
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/upgrade_locks.rb#15
SidekiqUniqueJobs::UpgradeLocks::OLD_SUFFIXES = T.let(T.unsafe(nil), Array)

# @return [String] the current SidekiqUniqueJobs version
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version.rb#6
SidekiqUniqueJobs::VERSION = T.let(T.unsafe(nil), String)

# Handles checking if a version is compliant with given constraint
#
# @author Mikael Henriksson <mikael@mhenrixon.com>
#
# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#9
class SidekiqUniqueJobs::VersionCheck
  # Initialize a new VersionCheck instance
  #
  # @param version [String] a version string `5.0.0`
  # @param constraint [String] a version constraint `>= 5.0.0 <= 5.1.1`
  # @raise [ArgumentError]
  # @return [VersionCheck] a new instance of VersionCheck
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#65
  def initialize(version, constraint); end

  # Returns the value of attribute match.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#57
  def match; end

  # Checks if all constraints were met
  #
  # @return [true, false]
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#79
  def satisfied?; end

  # Returns the value of attribute version.
  #
  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#53
  def version; end

  private

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#87
  def compare(expected, operator); end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#91
  def constraints; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#102
  def operator_one; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#110
  def operator_two; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#98
  def version_one; end

  # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#106
  def version_two; end

  class << self
    # Checks if a version is constraint is satisfied
    #
    # @example A satisfied constraint
    #   VersionCheck.satisfied?("5.0.0", ">= 4.0.0") #=> true
    # @example An unsatisfied constraint
    #   VersionCheck.satisfied?("5.0.0", "<= 4.0.0") #=> false
    # @param version [String] a version string `5.0.0`
    # @param constraint [String] a version constraint `>= 5.0.0 <= 5.1.1`
    # @return [true, false] <description>
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#27
    def satisfied?(version, constraint); end

    # Checks if a version is constraint is unfulfilled
    #
    # @example A satisfied constraint
    #   VersionCheck.unfulfilled?("5.0.0", ">= 4.0.0") #=> false
    # @example An unfulfilled constraint
    #   VersionCheck.unfulfilled?("5.0.0", "<= 4.0.0") #=> true
    # @param version [String] a version string `5.0.0`
    # @param constraint [String] a version constraint `>= 5.0.0 <= 5.1.1`
    # @return [true, false] <description>
    #
    # source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#46
    def unfulfilled?(version, constraint); end
  end
end

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/version_check.rb#10
SidekiqUniqueJobs::VersionCheck::PATTERN = T.let(T.unsafe(nil), Regexp)

# source://sidekiq-unique-jobs//lib/sidekiq_unique_jobs/constants.rb#54
SidekiqUniqueJobs::WORKER = T.let(T.unsafe(nil), String)
